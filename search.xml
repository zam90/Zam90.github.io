<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TCA腾讯云开发工程师课程学习笔记（二）|Zam9036博客</title>
    <url>/2021/01/03/38-TCA-study-notes-2/</url>
    <content><![CDATA[<h1 id="3-本地应用迁移到云端"><a href="#3-本地应用迁移到云端" class="headerlink" title="3.本地应用迁移到云端"></a>3.本地应用迁移到云端</h1><h2 id="3-1本地应用上云基础"><a href="#3-1本地应用上云基础" class="headerlink" title="3.1本地应用上云基础"></a>3.1本地应用上云基础</h2><h3 id="3-1-1传统Web应用架构"><a href="#3-1-1传统Web应用架构" class="headerlink" title="3.1.1传统Web应用架构"></a>3.1.1传统Web应用架构</h3><p>单体架构：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/1.png" alt="传统Web应用架构"></p>
<h3 id="3-1-2本地应用上云基本步骤"><a href="#3-1-2本地应用上云基本步骤" class="headerlink" title="3.1.2本地应用上云基本步骤"></a>3.1.2本地应用上云基本步骤</h3><ul>
<li>本地服务器→云服务器</li>
<li>本地数据库→云数据库</li>
<li>本地存储→云存储</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/2.png" alt="本地应用上云"></p>
<h2 id="3-2应用上云场景介绍"><a href="#3-2应用上云场景介绍" class="headerlink" title="3.2应用上云场景介绍"></a>3.2应用上云场景介绍</h2><p>以简单的图书管理系统为例</p>
<h3 id="3-2-1迁移方案"><a href="#3-2-1迁移方案" class="headerlink" title="3.2.1迁移方案"></a>3.2.1迁移方案</h3><p>云数据盘：云服务器一台，数据盘60G以上</p>
<blockquote>
<p>安装MySQL数据库，用于数据库存储</p>
</blockquote>
<p>云服务器：云服务器一台</p>
<blockquote>
<p>部署TOMCAT及相关应用，保存图片资源</p>
</blockquote>
<h3 id="3-2-2本地应用迁移云上架构"><a href="#3-2-2本地应用迁移云上架构" class="headerlink" title="3.2.2本地应用迁移云上架构"></a>3.2.2本地应用迁移云上架构</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/3.png" alt="本地应用迁移云上架构"></p>
<h2 id="3-3云服务器简介"><a href="#3-3云服务器简介" class="headerlink" title="3.3云服务器简介"></a>3.3云服务器简介</h2><ul>
<li>云服务器CVM：通用场景，对性能要求不高……（不独享物理资源）</li>
<li>GPU云服务器：深度学习，科学计算，视频编码……（不独享物理资源）</li>
<li>FPGA云服务器：硬件加速，可编程阵列，深度学习，实时图像压缩……（不独享物理资源）</li>
<li>专用宿主机CDH：金融业务，高性能业务……（独享物理资源，搭载虚拟化系统）</li>
<li>黑石物理服务器CPM：大数据，虚拟化，游戏……（独享物理资源，不搭载虚拟化系统）</li>
</ul>
<h3 id="3-3-1云服务器CVM"><a href="#3-3-1云服务器CVM" class="headerlink" title="3.3.1云服务器CVM"></a>3.3.1云服务器CVM</h3><p>云服务器CVM（Cloud Virtual Machine）是一种弹性可伸缩的计算服务</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/4.png" alt="CVM与传统服务器"></p>
<h3 id="3-3-2云服务器CVM概念关系"><a href="#3-3-2云服务器CVM概念关系" class="headerlink" title="3.3.2云服务器CVM概念关系"></a>3.3.2云服务器CVM概念关系</h3><p>镜像：操作系统的镜像</p>
<p>存储：硬盘存储空间</p>
<p>实例：在存储空间内安装一个镜像即构建了一个实例</p>
<p>快照：记录当时云服务器状态，设置保存点</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/5.png" alt="云服务器CVM概念关系"></p>
<h3 id="3-3-3云服务器存储"><a href="#3-3-3云服务器存储" class="headerlink" title="3.3.3云服务器存储"></a>3.3.3云服务器存储</h3><p>存储介质：普通硬盘、SSD硬盘（固态）</p>
<p>使用场景：系统盘、数据盘</p>
<p>架构模式：云硬盘（推荐）、本地盘（服务器的物理盘）、对象存储</p>
<h3 id="3-3-4块存储设备映射"><a href="#3-3-4块存储设备映射" class="headerlink" title="3.3.4块存储设备映射"></a>3.3.4块存储设备映射</h3><p>服务器<strong>挂载</strong>云硬盘</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/6.png" alt="块存储设备映射"></p>
<h3 id="3-3-5API访问CVM"><a href="#3-3-5API访问CVM" class="headerlink" title="3.3.5API访问CVM"></a>3.3.5API访问CVM</h3><p>参考API文档</p>
<h3 id="3-3-6SDK访问CVM"><a href="#3-3-6SDK访问CVM" class="headerlink" title="3.3.6SDK访问CVM"></a>3.3.6SDK访问CVM</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/7.png" alt="SDK访问CVM"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/8.png" alt="SDK查询CVM信息"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/9.png" alt="SDK新建CVM"></p>
<h3 id="3-3-7CVM最佳实践"><a href="#3-3-7CVM最佳实践" class="headerlink" title="3.3.7CVM最佳实践"></a>3.3.7CVM最佳实践</h3><ul>
<li>限制访问：通过安全组允许受信任的地址访问实例来限制访问，在安全组中配置最严格的规则。例如，限制端口访问、IP地址访问等。</li>
<li>安全登录：尽量使用SSH密钥的方式登录用户Linux类型实例。使用密码登录的实例需要不定期修改密码</li>
<li>硬件存储：对于可靠性极高的数据，请使用云硬盘（自动备份）保证数据的持久存储可靠性，尽量不要选择本地盘</li>
</ul>
<h2 id="3-4本地应用迁移上云流程"><a href="#3-4本地应用迁移上云流程" class="headerlink" title="3.4本地应用迁移上云流程"></a>3.4本地应用迁移上云流程</h2><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/10.png" alt="本地应用迁移上云流程"></p>
<h2 id="3-5负载均衡"><a href="#3-5负载均衡" class="headerlink" title="3.5负载均衡"></a>3.5负载均衡</h2><p>用户规模增大，云服务器单机部署已经不能满足需求，如何提高应用负载能力？</p>
<p>采用<strong>集群部署</strong>：多个云服务器实例部署同一个应用</p>
<p>集群部署带来的问题：</p>
<ul>
<li>统一用户访问入口</li>
<li>各个云服务器实例流量分配</li>
<li>状态问题，如session</li>
</ul>
<h3 id="3-5-1负载均衡CLB"><a href="#3-5-1负载均衡CLB" class="headerlink" title="3.5.1负载均衡CLB"></a>3.5.1负载均衡CLB</h3><ul>
<li>对多台云服务器进行流量分发服务</li>
<li>负载均衡可以通过流量分发扩展应用系统对外的服务能力，通过消除单点故障提升应用系统的可用性</li>
<li>负载均衡服务会检查云服务器池中云服务器实例的健康状态，自动隔离异常状态的实例</li>
<li>负载均衡服务具备自助管理、自故障修复，防网络攻击等高级功能，适用于企业、社区、电子商务、游戏等多种用户场景</li>
</ul>
<p>用户访问负载均衡CLB的地址，CLB会自动进行流量分发，将用户访问转发至合适服务器</p>
<p>多协议转发：</p>
<ul>
<li>四层负载均衡（包含TCP、UDP协议）</li>
<li>七层负载均衡（包含HTTP、HTTPS协议）</li>
</ul>
<p>流量分配算法：</p>
<ul>
<li>加权轮询算法</li>
<li>加权最小连接数算法</li>
<li>源地址散列调度算法（IP HASH）</li>
</ul>
<p>跨可用区容灾：</p>
<ul>
<li>在同一个地域内采用多可用区部署</li>
</ul>
<h3 id="3-5-2负载均衡CLB分类"><a href="#3-5-2负载均衡CLB分类" class="headerlink" title="3.5.2负载均衡CLB分类"></a>3.5.2负载均衡CLB分类</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/11.png" alt="CLB分类"></p>
<h3 id="3-5-3负载均衡CLB使用步骤"><a href="#3-5-3负载均衡CLB使用步骤" class="headerlink" title="3.5.3负载均衡CLB使用步骤"></a>3.5.3负载均衡CLB使用步骤</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/12.png" alt="负载均衡CLB使用步骤"></p>
<h3 id="3-5-4负载均衡最佳实践"><a href="#3-5-4负载均衡最佳实践" class="headerlink" title="3.5.4负载均衡最佳实践"></a>3.5.4负载均衡最佳实践</h3><ul>
<li>推荐使用<strong>负载均衡</strong>（原“应用型负载均衡”）</li>
<li>推荐负载均衡<strong>开启Gzip配置</strong>，对网页进行压缩，有效降低网络传输数据量，提升客户端浏览器访问速度</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/13.png" alt="负载均衡算法最佳使用"></p>
<h2 id="3-6弹性伸缩"><a href="#3-6弹性伸缩" class="headerlink" title="3.6弹性伸缩"></a>3.6弹性伸缩</h2><p>通过集群+负载均衡极大的提高了应用负载能力，但是业务访问有明显的高低谷，如何灵活应对？</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/14.png" alt="传统应对方法"></p>
<h3 id="3-6-1弹性伸缩AS"><a href="#3-6-1弹性伸缩AS" class="headerlink" title="3.6.1弹性伸缩AS"></a>3.6.1弹性伸缩AS</h3><p>根据业务需求和策略<strong>自动</strong>调整CVM计算资源，确保在合适的流量下有合适数量的服务器工作，减少资源浪费和资源不足的情况出现。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/15.png" alt="AS方法"></p>
<h3 id="3-6-2弹性伸缩AS优势"><a href="#3-6-2弹性伸缩AS优势" class="headerlink" title="3.6.2弹性伸缩AS优势"></a>3.6.2弹性伸缩AS优势</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/16.png" alt="AS优势"></p>
<h3 id="3-6-3弹性伸缩AS使用步骤"><a href="#3-6-3弹性伸缩AS使用步骤" class="headerlink" title="3.6.3弹性伸缩AS使用步骤"></a>3.6.3弹性伸缩AS使用步骤</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/17.png" alt="AS使用步骤"></p>
<p>创建启动配置：弹性伸缩AS根据流量动态的创建和销毁实例，在创建实例的时候需要确定实例的配置</p>
<p>创建伸缩组：将弹性伸缩AS和均衡负载相绑定，使该弹性伸缩AS操作特定负载均衡</p>
<p>创建伸缩策略：在<strong>告警</strong>后触发弹性伸缩或<strong>定时</strong>触发弹性伸缩</p>
<h3 id="3-6-4弹性伸缩AS最佳实践"><a href="#3-6-4弹性伸缩AS最佳实践" class="headerlink" title="3.6.4弹性伸缩AS最佳实践"></a>3.6.4弹性伸缩AS最佳实践</h3><ul>
<li>提前部署扩缩容</li>
<li>低成本应对业务浪涌</li>
<li>自动替换不健康CVM</li>
</ul>
<h2 id="3-7存储扩容"><a href="#3-7存储扩容" class="headerlink" title="3.7存储扩容"></a>3.7存储扩容</h2><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/18.png" alt="传统存储扩容"></p>
<h3 id="3-7-1腾讯云存储产品"><a href="#3-7-1腾讯云存储产品" class="headerlink" title="3.7.1腾讯云存储产品"></a>3.7.1腾讯云存储产品</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/19.png" alt="腾讯云存储产品"></p>
<h3 id="3-7-2云硬盘CBS"><a href="#3-7-2云硬盘CBS" class="headerlink" title="3.7.2云硬盘CBS"></a>3.7.2云硬盘CBS</h3><p>云硬盘是腾讯云提供的用于CVM实例的持久性数据块级存储。云硬盘中的数据自动地在可用区内以多副本冗余方式存储，避免数据单点故障风险。</p>
<p>CBS特性：</p>
<ul>
<li>多种磁盘选择</li>
<li>弹性挂载卸载</li>
<li>弹性扩容</li>
<li>快照备份</li>
</ul>
<h3 id="3-7-3云硬盘分类"><a href="#3-7-3云硬盘分类" class="headerlink" title="3.7.3云硬盘分类"></a>3.7.3云硬盘分类</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/20.png" alt="腾讯云硬盘分类"></p>
<h3 id="3-7-4云硬盘最佳实践"><a href="#3-7-4云硬盘最佳实践" class="headerlink" title="3.7.4云硬盘最佳实践"></a>3.7.4云硬盘最佳实践</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/21.png" alt="云硬盘最佳实践"></p>
<h3 id="3-7-5文件存储CFS"><a href="#3-7-5文件存储CFS" class="headerlink" title="3.7.5文件存储CFS"></a>3.7.5文件存储CFS</h3><p>CFS提供<strong>可扩展</strong>的<strong>共享</strong>文件存储服务</p>
<p>特点：</p>
<ul>
<li>集成管理</li>
<li>自动扩展</li>
<li>安全可靠</li>
<li>成本低廉</li>
</ul>
<h3 id="3-7-6文件存储与云硬盘的区别"><a href="#3-7-6文件存储与云硬盘的区别" class="headerlink" title="3.7.6文件存储与云硬盘的区别"></a>3.7.6文件存储与云硬盘的区别</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/22.png" alt="文件存储与云硬盘"></p>
<h3 id="3-7-7文件存储使用步骤"><a href="#3-7-7文件存储使用步骤" class="headerlink" title="3.7.7文件存储使用步骤"></a>3.7.7文件存储使用步骤</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/23.png" alt="文件存储使用步骤"></p>
<h2 id="3-8本地应用上云后仍存在的问题"><a href="#3-8本地应用上云后仍存在的问题" class="headerlink" title="3.8本地应用上云后仍存在的问题"></a>3.8本地应用上云后仍存在的问题</h2><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/24.png" alt="本地应用上云后仍存在的问题"></p>
<h1 id="4-云端应用开发"><a href="#4-云端应用开发" class="headerlink" title="4.云端应用开发"></a>4.云端应用开发</h1><h2 id="4-1数据库简介"><a href="#4-1数据库简介" class="headerlink" title="4.1数据库简介"></a>4.1数据库简介</h2><h3 id="4-1-1数据库分类"><a href="#4-1-1数据库分类" class="headerlink" title="4.1.1数据库分类"></a>4.1.1数据库分类</h3><p>数据库通常可以按<strong>数据组织方式</strong>和<strong>架构</strong>进行分类</p>
<p>按数据组织方式进行分类：关系型数据库、非关系型数据库</p>
<p>按数据库架构进行分类：集中式数据库、分布式数据库</p>
<h3 id="4-1-2腾讯云数据库分类"><a href="#4-1-2腾讯云数据库分类" class="headerlink" title="4.1.2腾讯云数据库分类"></a>4.1.2腾讯云数据库分类</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/25.png" alt="腾讯云数据库分类"></p>
<h3 id="4-1-3云数据库CDB"><a href="#4-1-3云数据库CDB" class="headerlink" title="4.1.3云数据库CDB"></a>4.1.3云数据库CDB</h3><p>云数据库CDB是<strong>关系型数据库云服务</strong>，CDB主要包含：云MySQL、云SQL Server、云TDSQL、云PostgreSQL，易于实现数据迁移、高可用等特性</p>
<h2 id="4-2云数据库MySQL"><a href="#4-2云数据库MySQL" class="headerlink" title="4.2云数据库MySQL"></a>4.2云数据库MySQL</h2><p>CDB for MySQL对开源MySQL进行了<strong>内核级优化</strong>，包含主从同步多线程优化、数据库间同步性能瓶颈优化。</p>
<h3 id="4-2-1云数据库MySQL优势"><a href="#4-2-1云数据库MySQL优势" class="headerlink" title="4.2.1云数据库MySQL优势"></a>4.2.1云数据库MySQL优势</h3><ul>
<li>轻松管理海量数据库</li>
<li>数据导入与备份回档</li>
<li>专业监控与告警</li>
<li>多种接入方式</li>
</ul>
<h3 id="4-2-2云数据库MySQL应用场景"><a href="#4-2-2云数据库MySQL应用场景" class="headerlink" title="4.2.2云数据库MySQL应用场景"></a>4.2.2云数据库MySQL应用场景</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/26.png" alt="电商场景"></p>
<h3 id="4-2-3云数据库MySQL使用"><a href="#4-2-3云数据库MySQL使用" class="headerlink" title="4.2.3云数据库MySQL使用"></a>4.2.3云数据库MySQL使用</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/27.png" alt="云数据库MySQL使用步骤"></p>
<h2 id="4-3数据迁移"><a href="#4-3数据迁移" class="headerlink" title="4.3数据迁移"></a>4.3数据迁移</h2><p>传统数据库迁移常见问题</p>
<ul>
<li>遗留数据</li>
<li>服务停机</li>
<li>数据量大、耗时长</li>
<li>故障处理</li>
</ul>
<h3 id="4-3-1数据迁移到云数据库MySQL方案"><a href="#4-3-1数据迁移到云数据库MySQL方案" class="headerlink" title="4.3.1数据迁移到云数据库MySQL方案"></a>4.3.1数据迁移到云数据库MySQL方案</h3><p>SQL文件导入：数据量小（单文件不超过2G）</p>
<p>在线迁移：DTS数据迁移工具迁移（实时不停服同步）</p>
<p>离线迁移：备份文件还原</p>
<h3 id="4-3-2SQL文件导入"><a href="#4-3-2SQL文件导入" class="headerlink" title="4.3.2SQL文件导入"></a>4.3.2SQL文件导入</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/28.png" alt="SQL文件导入操作步骤"></p>
<h3 id="4-3-3DTS在线导入"><a href="#4-3-3DTS在线导入" class="headerlink" title="4.3.3DTS在线导入"></a>4.3.3DTS在线导入</h3><p>DTS传输服务-数据迁移</p>
<h2 id="4-4读写分离"><a href="#4-4读写分离" class="headerlink" title="4.4读写分离"></a>4.4读写分离</h2><p>互联网常见业务中，读数据库的次数往往大于写数据库的次数，数据库的读负载远高于写负载，如何缓解数据库大量的读请求压力？</p>
<h3 id="4-4-1读写分离"><a href="#4-4-1读写分离" class="headerlink" title="4.4.1读写分离"></a>4.4.1读写分离</h3><p>读写分离基本原理是让<strong>主数据库</strong>处理事务性<strong>增添、删除、修改</strong>操作，让<strong>从数据库</strong>处理<strong>查询</strong>操作</p>
<p>数据库复制被用来把事务性操作导致的变更<strong>同步</strong>到集群中的从数据库</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/29.png" alt="SQL文件导入操作步骤"></p>
<h3 id="4-4-2云数据库MySQL只读实例"><a href="#4-4-2云数据库MySQL只读实例" class="headerlink" title="4.4.2云数据库MySQL只读实例"></a>4.4.2云数据库MySQL只读实例</h3><p>云数据库MySQL支持用户创建一个或多个只读实例，以支持用户的<strong>读写分离</strong>和<strong>一主多从</strong>的应用场景，可显著提高用户数据库的读负载能力</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/30.png" alt="数据库只读实例"></p>
<h3 id="4-4-3读写分离实现步骤"><a href="#4-4-3读写分离实现步骤" class="headerlink" title="4.4.3读写分离实现步骤"></a>4.4.3读写分离实现步骤</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/31.png" alt="读写分离实现步骤"></p>
<h3 id="4-4-4应用读写分离后架构变化"><a href="#4-4-4应用读写分离后架构变化" class="headerlink" title="4.4.4应用读写分离后架构变化"></a>4.4.4应用读写分离后架构变化</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/32.png" alt="应用读写分离后架构变化"></p>
<h2 id="4-5云数据库MongoDB简介"><a href="#4-5云数据库MongoDB简介" class="headerlink" title="4.5云数据库MongoDB简介"></a>4.5云数据库MongoDB简介</h2><p>关系型数据库瓶颈</p>
<ul>
<li>高并发读写需求</li>
<li>海量数据高效读写</li>
<li>高扩展性和可用性</li>
<li>互联网时代，关系型数据库很多特性已经不再需要了（事务强一致性、读写强实时性、多表关联查询弱化）</li>
</ul>
<h3 id="4-5-1云数据库MongoDB"><a href="#4-5-1云数据库MongoDB" class="headerlink" title="4.5.1云数据库MongoDB"></a>4.5.1云数据库MongoDB</h3><p>基于开源NoSQL数据MongoDB打造的高性能、分布式数据存储服务，完全兼容MongoDB协议，适用于面向<strong>非关系型数据库</strong>的场景</p>
<p>MongoDB和MySQL的区别</p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/33.png" alt="MongoDB和MySQL的区别"></p>
<h3 id="4-5-2MongoDB应用场景"><a href="#4-5-2MongoDB应用场景" class="headerlink" title="4.5.2MongoDB应用场景"></a>4.5.2MongoDB应用场景</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/34.png" alt="游戏开发"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/35.png" alt="移动行业"></p>
<h2 id="4-6云数据库MongoDB使用"><a href="#4-6云数据库MongoDB使用" class="headerlink" title="4.6云数据库MongoDB使用"></a>4.6云数据库MongoDB使用</h2><h3 id="4-6-1云数据库MongoDB使用"><a href="#4-6-1云数据库MongoDB使用" class="headerlink" title="4.6.1云数据库MongoDB使用"></a>4.6.1云数据库MongoDB使用</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/36.png" alt="云数据库MongoDB操作步骤"></p>
<h3 id="4-6-2云数据库MongoDB数据迁移"><a href="#4-6-2云数据库MongoDB数据迁移" class="headerlink" title="4.6.2云数据库MongoDB数据迁移"></a>4.6.2云数据库MongoDB数据迁移</h3><ul>
<li>云服务器CVM自建实例迁移</li>
<li>外网实例迁移</li>
<li>数据传输服务DTS快速数据迁移</li>
</ul>
<h3 id="4-6-3引入云数据库MongoDB后架构变化"><a href="#4-6-3引入云数据库MongoDB后架构变化" class="headerlink" title="4.6.3引入云数据库MongoDB后架构变化"></a>4.6.3引入云数据库MongoDB后架构变化</h3><p><img src="https://zam9036.gitee.io/img/postimg/38-TCA-study-notes-2/37.png" alt="引入云数据库MongoDB后架构变化"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>TCA认证课程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCA腾讯云开发工程师课程学习笔记（一）|Zam9036博客</title>
    <url>/2021/01/02/37-TCA-study-notes-1/</url>
    <content><![CDATA[<p>[TOC]</p>
<p><a href="https://cloud.tencent.com/document/product" target="_blank" rel="noopener">腾讯云文档中心</a></p>
<h1 id="1-云开发基础"><a href="#1-云开发基础" class="headerlink" title="1.云开发基础"></a>1.云开发基础</h1><h2 id="1-1传统IT架构的特点"><a href="#1-1传统IT架构的特点" class="headerlink" title="1.1传统IT架构的特点"></a>1.1传统IT架构的特点</h2><h3 id="1-1-1传统应用的开发特点"><a href="#1-1-1传统应用的开发特点" class="headerlink" title="1.1.1传统应用的开发特点"></a>1.1.1传统应用的开发特点</h3><ul>
<li>企业内部应用</li>
<li>需求变化量慢</li>
<li>技术复杂度低</li>
<li>迭代升级缓慢</li>
<li>用户规模小</li>
<li>需求明确</li>
</ul>
<h3 id="1-1-2传统应用的开发方式"><a href="#1-1-2传统应用的开发方式" class="headerlink" title="1.1.2传统应用的开发方式"></a>1.1.2传统应用的开发方式</h3><p>软件开发模式：<strong>瀑布开发模型</strong>（标准化、阶段清晰、环环相扣）+软件架构：<strong>单体架构</strong>（开发速度快、成本低）</p>
<p>瀑布开发模型：软件定义（问题定义可行性分析、需求分析）、软件开发（设计、编码、测试）、软件维护（运营维护）</p>
<p>单体架构：最简单的软件架构，功能点+UI界面+后台服务放入同一个包进行开发，然后统一部署</p>
<h2 id="1-2业务驱动下的IT架构变革"><a href="#1-2业务驱动下的IT架构变革" class="headerlink" title="1.2业务驱动下的IT架构变革"></a>1.2业务驱动下的IT架构变革</h2><h3 id="1-2-1业务发展带来的挑战"><a href="#1-2-1业务发展带来的挑战" class="headerlink" title="1.2.1业务发展带来的挑战"></a>1.2.1业务发展带来的挑战</h3><ul>
<li>资源利用率差</li>
<li>功能重复开发</li>
<li>不同开发语言</li>
<li>维护困难</li>
<li>信息孤岛</li>
</ul>
<h3 id="1-2-2IT架构如何支撑业务发展"><a href="#1-2-2IT架构如何支撑业务发展" class="headerlink" title="1.2.2IT架构如何支撑业务发展"></a>1.2.2IT架构如何支撑业务发展</h3><p>硬件基础设施：用户数量增多，服务器集群规模也需要不断扩大</p>
<blockquote>
<p>自建机房、集群扩展（成本太高）→IDC互联网数据中心（租用服务器）</p>
</blockquote>
<p>软件架构：传统的单体架构造成大量信息孤岛，各业务部门软件不能互通，代码复用度低</p>
<blockquote>
<p>SOA：面向服务的架构，微服务的前身。将重复公用的功能抽取为组件，以服务的方式给各个系统提供服务。</p>
<p>ESB企业服务总线作为项目与服务之间通信的桥梁。</p>
</blockquote>
<h2 id="1-3“互联网-”带来的挑战"><a href="#1-3“互联网-”带来的挑战" class="headerlink" title="1.3“互联网+”带来的挑战"></a>1.3“互联网+”带来的挑战</h2><h3 id="1-3-1“互联网-”时代业务特征"><a href="#1-3-1“互联网-”时代业务特征" class="headerlink" title="1.3.1“互联网+”时代业务特征"></a>1.3.1“互联网+”时代业务特征</h3><ul>
<li>用户规模大、接入方式多</li>
<li>集中式访问、流量突增</li>
<li>大数据</li>
<li>市场需求变化快</li>
</ul>
<h3 id="1-3-2传统基础设施局限性"><a href="#1-3-2传统基础设施局限性" class="headerlink" title="1.3.2传统基础设施局限性"></a>1.3.2传统基础设施局限性</h3><ul>
<li>服务器设备、机房维护，前期投入成本高</li>
<li>倍数部署，资源利用率差，资源浪费</li>
<li>流量突增难以应对，不够灵活</li>
</ul>
<h2 id="1-4云计算简介"><a href="#1-4云计算简介" class="headerlink" title="1.4云计算简介"></a>1.4云计算简介</h2><p>云计算是一种新的提供资源按需租用的服务模式、一种新型互联网数据中心业务</p>
<h3 id="1-4-1云计算与传统IDC区别"><a href="#1-4-1云计算与传统IDC区别" class="headerlink" title="1.4.1云计算与传统IDC区别"></a>1.4.1云计算与传统IDC区别</h3><ul>
<li>租用资源范围：云计算租用资源范围更广</li>
<li>服务能力：服务能力更弹性、灵活，“按需付费”</li>
<li>资源透明性：云计算业务中，用户不需要了解资源的物理信息</li>
<li>运维难度低：云计算业务中，沟通较多、运维较少</li>
</ul>
<h3 id="1-4-2云计算的特征"><a href="#1-4-2云计算的特征" class="headerlink" title="1.4.2云计算的特征"></a>1.4.2云计算的特征</h3><ul>
<li>超大规模</li>
<li>高可靠性</li>
<li>多用户阻隔</li>
<li>弹性扩展</li>
<li>按需服务</li>
<li>资源可监控计量</li>
<li>低成本</li>
</ul>
<h3 id="1-4-3云计算服务模式"><a href="#1-4-3云计算服务模式" class="headerlink" title="1.4.3云计算服务模式"></a>1.4.3云计算服务模式</h3><p>IaaS基础设施即服务：通过互联网从资源池中获取IT相关基础设施资源</p>
<p>PaaS平台即服务：以服务器平台或者开发环境提供服务</p>
<p>SaaS软件即服务：通过互联网提供软件程序服务</p>
<h2 id="1-5云计算解决的问题"><a href="#1-5云计算解决的问题" class="headerlink" title="1.5云计算解决的问题"></a>1.5云计算解决的问题</h2><h3 id="1-5-1云计算优势"><a href="#1-5-1云计算优势" class="headerlink" title="1.5.1云计算优势"></a>1.5.1云计算优势</h3><ul>
<li>规模大、按需付费：成本大幅降低</li>
<li>弹性：优雅应对流量突增，灵活扩展</li>
<li>可靠快速故障恢复：保证应用高可用</li>
<li>极速安全易用</li>
</ul>
<h3 id="1-5-2云计算服务模式关注点区别"><a href="#1-5-2云计算服务模式关注点区别" class="headerlink" title="1.5.2云计算服务模式关注点区别"></a>1.5.2云计算服务模式关注点区别</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/1.png" alt="关注点区别"></p>
<h3 id="1-5-3仍然存在的问题"><a href="#1-5-3仍然存在的问题" class="headerlink" title="1.5.3仍然存在的问题"></a>1.5.3仍然存在的问题</h3><ul>
<li>有扩展能力但不够灵活</li>
<li>迭代、更新困难</li>
<li>代码有一定复用能力、复用度较低</li>
<li>各业务系统数据部分开始打通，但是数据孤岛仍然存在</li>
</ul>
<h2 id="1-6云时代开发方式"><a href="#1-6云时代开发方式" class="headerlink" title="1.6云时代开发方式"></a>1.6云时代开发方式</h2><p>基于云特性进行开发，开发出来的软件具有水平扩展、低门槛准入和高解耦复用等云计算特性</p>
<h3 id="1-6-1开发模式演变"><a href="#1-6-1开发模式演变" class="headerlink" title="1.6.1开发模式演变"></a>1.6.1开发模式演变</h3><p>传统<strong>瀑布开发模型</strong>转变为<strong>敏捷开发</strong></p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/2.png" alt="敏捷开发"></p>
<p>DevOps为了填补开发端和运维端的信息鸿沟，改善团队间协作关系，包含3部分：开发、测试、运维</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/3.png" alt="DevOps"></p>
<h3 id="1-6-2软件架构的演变-微服务架构"><a href="#1-6-2软件架构的演变-微服务架构" class="headerlink" title="1.6.2软件架构的演变-微服务架构"></a>1.6.2软件架构的演变-微服务架构</h3><p>传统<strong>单体架构</strong>转变为<strong>微服务架构</strong></p>
<p>微服务架构：将一个大项目拆成几个小的独立的服务，再把独立的服务串起来</p>
<p>微服务架构特性：</p>
<ul>
<li>日日可更新</li>
<li>实时可更新</li>
<li>能力可积累</li>
<li>技术可共存</li>
</ul>
<h3 id="1-6-3软件架构的演变-Serverless"><a href="#1-6-3软件架构的演变-Serverless" class="headerlink" title="1.6.3软件架构的演变-Serverless"></a>1.6.3软件架构的演变-Serverless</h3><p>无服务器模式</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/4.png" alt="无服务器模式"></p>
<h3 id="1-6-4传统应用和云端应用开发的区别"><a href="#1-6-4传统应用和云端应用开发的区别" class="headerlink" title="1.6.4传统应用和云端应用开发的区别"></a>1.6.4传统应用和云端应用开发的区别</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/5.png" alt="传统应用和云端应用开发的区别"></p>
<h3 id="1-6-5传统应用和云端应用技术栈的区别"><a href="#1-6-5传统应用和云端应用技术栈的区别" class="headerlink" title="1.6.5传统应用和云端应用技术栈的区别"></a>1.6.5传统应用和云端应用技术栈的区别</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/6.png" alt="传统应用和云端应用技术栈的区别"></p>
<h3 id="1-6-6云时代开发的分类"><a href="#1-6-6云时代开发的分类" class="headerlink" title="1.6.6云时代开发的分类"></a>1.6.6云时代开发的分类</h3><ul>
<li>本地应用迁移到云</li>
<li>基于云端特性开发</li>
<li>云原生应用开发</li>
<li>无服务器Serverless</li>
</ul>
<h1 id="2-腾讯云开发入门"><a href="#2-腾讯云开发入门" class="headerlink" title="2.腾讯云开发入门"></a>2.腾讯云开发入门</h1><h2 id="2-1腾讯云简介"><a href="#2-1腾讯云简介" class="headerlink" title="2.1腾讯云简介"></a>2.1腾讯云简介</h2><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/7.png" alt="腾讯云简介"></p>
<p>强大的研发实力：云CDB内核级复制优化</p>
<p>大规模运营经验：成熟的计算架构和团队，支撑着超大规模应用经验</p>
<p>采购能力</p>
<p>服务提供能力</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/8.png" alt="服务提供能力"></p>
<h2 id="2-2云管理平台以及云产品概述"><a href="#2-2云管理平台以及云产品概述" class="headerlink" title="2.2云管理平台以及云产品概述"></a>2.2云管理平台以及云产品概述</h2><h3 id="2-2-1云管理平台Vstation"><a href="#2-2-1云管理平台Vstation" class="headerlink" title="2.2.1云管理平台Vstation"></a>2.2.1云管理平台Vstation</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/9.png" alt="腾讯云管理平台VStation"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/10.png" alt="VStation架构"></p>
<h3 id="2-2-2云产品概览"><a href="#2-2-2云产品概览" class="headerlink" title="2.2.2云产品概览"></a>2.2.2云产品概览</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/11.png" alt="云产品概览"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/12.png" alt="云上开发各阶段对应云产品概览"></p>
<h2 id="2-3腾讯云全球基础设施简介"><a href="#2-3腾讯云全球基础设施简介" class="headerlink" title="2.3腾讯云全球基础设施简介"></a>2.3腾讯云全球基础设施简介</h2><h3 id="2-3-1地域和可用区简介"><a href="#2-3-1地域和可用区简介" class="headerlink" title="2.3.1地域和可用区简介"></a>2.3.1地域和可用区简介</h3><p>地域：独立的地理区域（通常用城市命名）</p>
<p>可用区：同一地域内的电力和网络相互独立的物理数据中心</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/13.png" alt="地域概念"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/14.png" alt="可用区概念"></p>
<h3 id="2-3-2为什么需要地域和可用区的概念"><a href="#2-3-2为什么需要地域和可用区的概念" class="headerlink" title="2.3.2为什么需要地域和可用区的概念"></a>2.3.2为什么需要地域和可用区的概念</h3><ul>
<li>高可用，容灾</li>
<li>降低访问时延</li>
<li>数据管理，数据保护（法律要求）</li>
<li>成本（不同地域收费不同）</li>
</ul>
<h2 id="2-4开发接入流程"><a href="#2-4开发接入流程" class="headerlink" title="2.4开发接入流程"></a>2.4开发接入流程</h2><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/15.png" alt="开发接入流程"></p>
<h3 id="2-4-1获取主账号"><a href="#2-4-1获取主账号" class="headerlink" title="2.4.1获取主账号"></a>2.4.1获取主账号</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/16.png" alt="获取主账号"></p>
<h3 id="2-4-2实名认证"><a href="#2-4-2实名认证" class="headerlink" title="2.4.2实名认证"></a>2.4.2实名认证</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/17.png" alt="实名认证"></p>
<h3 id="2-4-3账号分类"><a href="#2-4-3账号分类" class="headerlink" title="2.4.3账号分类"></a>2.4.3账号分类</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/18.png" alt="账号分类"></p>
<h3 id="2-4-4能否直接使用主账号"><a href="#2-4-4能否直接使用主账号" class="headerlink" title="2.4.4能否直接使用主账号"></a>2.4.4能否直接使用主账号</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/19.png" alt="能否直接使用主账号"></p>
<h2 id="2-5云产品使用方式"><a href="#2-5云产品使用方式" class="headerlink" title="2.5云产品使用方式"></a>2.5云产品使用方式</h2><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/20.png" alt="云产品使用方式"></p>
<p><a href="https://cloud.tencent.com/document/api" target="_blank" rel="noopener">腾讯云API参考文档</a></p>
<h2 id="2-6账号使用安全"><a href="#2-6账号使用安全" class="headerlink" title="2.6账号使用安全"></a>2.6账号使用安全</h2><h3 id="2-6-1访问管理CAM"><a href="#2-6-1访问管理CAM" class="headerlink" title="2.6.1访问管理CAM"></a>2.6.1访问管理CAM</h3><p>腾讯云提供的Web服务，用于帮助客户安全管理腾讯云账户下的资源访问权限</p>
<p>主要功能：</p>
<ul>
<li>管理访问权限</li>
<li>精细化权限管理</li>
<li>联合身份</li>
<li>最终一致性</li>
</ul>
<h3 id="2-6-2CAM概念关系"><a href="#2-6-2CAM概念关系" class="headerlink" title="2.6.2CAM概念关系"></a>2.6.2CAM概念关系</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/21.png" alt="CAM概念关系"></p>
<p>角色：角色类似于腾讯云用户，可以看做腾讯云的“虚拟账号”</p>
<p>角色载体：能够申请担任角色的对象</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/22.png" alt="CAM概念关系2"></p>
<h3 id="2-6-3通过CAM创建子账号"><a href="#2-6-3通过CAM创建子账号" class="headerlink" title="2.6.3通过CAM创建子账号"></a>2.6.3通过CAM创建子账号</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/23.png" alt="通过CAM创建子账号"></p>
<h3 id="2-6-4获取访问密钥"><a href="#2-6-4获取访问密钥" class="headerlink" title="2.6.4获取访问密钥"></a>2.6.4获取访问密钥</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/24.png" alt="获取访问密钥"></p>
<h3 id="2-6-5CAM最佳实践"><a href="#2-6-5CAM最佳实践" class="headerlink" title="2.6.5CAM最佳实践"></a>2.6.5CAM最佳实践</h3><ul>
<li>使用用户组给子账号分配权限</li>
<li>最小权限原则</li>
<li>定期轮转身份凭证</li>
<li>删除不需要的证书和权限</li>
<li>使用临时密钥</li>
</ul>
<h2 id="2-7开发环境准备"><a href="#2-7开发环境准备" class="headerlink" title="2.7开发环境准备"></a>2.7开发环境准备</h2><p>两种开发环境策略：本地开发环境+云平台、在线开发环境+云平台</p>
<h3 id="2-7-1本地开发环境"><a href="#2-7-1本地开发环境" class="headerlink" title="2.7.1本地开发环境"></a>2.7.1本地开发环境</h3><p>开发语言环境、编译器、版本控制工具、网络环境、云服务依赖包</p>
<h3 id="2-7-2云端开发环境"><a href="#2-7-2云端开发环境" class="headerlink" title="2.7.2云端开发环境"></a>2.7.2云端开发环境</h3><p>CloudStudio（腾讯的云IDE）+云平台</p>
<h2 id="2-8云API"><a href="#2-8云API" class="headerlink" title="2.8云API"></a>2.8云API</h2><p>快速：通过云API使用少量代码即可快速操作云产品</p>
<p>高效：使用云API完成一些频繁调用的功能可以极大提高效率</p>
<p>灵活：通过API可以组合功能，实现更高级的功能，易于自动化，易于远程调用</p>
<p>兼容性强，对系统要求低</p>
<h2 id="2-9云API请求结构"><a href="#2-9云API请求结构" class="headerlink" title="2.9云API请求结构"></a>2.9云API请求结构</h2><p>请求Url+请求头部+请求体</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/25.png" alt="云API请求结构"></p>
<h3 id="2-9-1请求方法"><a href="#2-9-1请求方法" class="headerlink" title="2.9.1请求方法"></a>2.9.1请求方法</h3><p>通信协议：HTTPS</p>
<p>支持的请求方法：POST（推荐）、GET</p>
<p>字符编码：UTF-8</p>
<h3 id="2-9-2服务地址"><a href="#2-9-2服务地址" class="headerlink" title="2.9.2服务地址"></a>2.9.2服务地址</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/26.png" alt="云API服务地址"></p>
<h3 id="2-9-3公共参数"><a href="#2-9-3公共参数" class="headerlink" title="2.9.3公共参数"></a>2.9.3公共参数</h3><p>公共参数：标识用户、接口鉴权</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/27.png" alt="公共参数"></p>
<h3 id="2-9-4签名方法V3"><a href="#2-9-4签名方法V3" class="headerlink" title="2.9.4签名方法V3"></a>2.9.4签名方法V3</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/28.png" alt="签名方法V3"></p>
<h3 id="2-9-5地域列表"><a href="#2-9-5地域列表" class="headerlink" title="2.9.5地域列表"></a>2.9.5地域列表</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/29.png" alt="地域列表"></p>
<h3 id="2-9-6云API接口鉴权"><a href="#2-9-6云API接口鉴权" class="headerlink" title="2.9.6云API接口鉴权"></a>2.9.6云API接口鉴权</h3><p>腾讯云API会对每个访问请求进行身份验证</p>
<p>每个请求都需要在公共请求参数中包含签名信息以验证请求者身份</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/30.png" alt="云API接口鉴权"></p>
<h3 id="2-9-7接口鉴权分类"><a href="#2-9-7接口鉴权分类" class="headerlink" title="2.9.7接口鉴权分类"></a>2.9.7接口鉴权分类</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/31.png" alt="云API接口鉴权分类"></p>
<h3 id="2-9-8云API接口鉴权V3使用步骤"><a href="#2-9-8云API接口鉴权V3使用步骤" class="headerlink" title="2.9.8云API接口鉴权V3使用步骤"></a>2.9.8云API接口鉴权V3使用步骤</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/32.png" alt="云API接口鉴权V3使用步骤"></p>
<h3 id="2-9-9签名失败"><a href="#2-9-9签名失败" class="headerlink" title="2.9.9签名失败"></a>2.9.9签名失败</h3><p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/33.png" alt="错误码"></p>
<h2 id="2-10-API3-0Explorer"><a href="#2-10-API3-0Explorer" class="headerlink" title="2.10 API3.0Explorer"></a>2.10 API3.0Explorer</h2><p>API访问云资源时<strong>必须携带公共参数</strong>，公共参数签名计算流程非常<strong>复杂</strong>，可以使用API3.0Explorer<strong>简化签名过程以及接口访问</strong></p>
<p>API3.0Explorer提供在线调用、签名验证、SDK代码生成和快速检索接口等能力，能显著降低云API3.0使用难度</p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/34.png" alt="API3.0Explorer"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/37-TCA-study-notes-1/35.png" alt="腾讯云开发接入流程"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>课程链接：<a href="https://cloud.tencent.com/edu/learning/course-2216-31477" target="_blank" rel="noopener">腾讯云开发工程师认证课程</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2021/01/02/37-TCA-study-notes-1">https://zam9036.gitee.io/2021/01/02/37-TCA-study-notes-1</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>TCA认证课程</tag>
      </tags>
  </entry>
  <entry>
    <title>初识PHP——PHP学习笔记（1）|Zam9036博客</title>
    <url>/2020/09/11/36-PHP-study-notes-1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="PHP概述"><a href="#PHP概述" class="headerlink" title="PHP概述"></a>PHP概述</h1><h2 id="什么是PHP"><a href="#什么是PHP" class="headerlink" title="什么是PHP"></a>什么是PHP</h2><p>PHP：超文本预处理器（Hypertext Preprocessor），是一种服务器端、跨平台、HTML嵌入式的<strong>脚本</strong>语言</p>
<p>PHP是B/S（浏览器/服务器结构）体系结构，属于三层结构。</p>
<blockquote>
<p>三层架构就是为了符合“高内聚，低耦合”思想，把各个功能模块划分为表示层（UI）、业务逻辑层（BLL）和数据访问层（DAL）三层架构。</p>
</blockquote>
<h2 id="PHP优势"><a href="#PHP优势" class="headerlink" title="PHP优势"></a>PHP优势</h2><ul>
<li>安全性高：开源软件</li>
<li>跨平台特性</li>
<li>支持广泛的数据库</li>
<li>易学性</li>
<li>执行速度快：占用系统资源少</li>
<li>免费：LAMP全部开源免费</li>
<li>模板化：程序逻辑与用户界面分离</li>
<li>支持面向对象与面向过程</li>
</ul>
<h2 id="PHP应用领域"><a href="#PHP应用领域" class="headerlink" title="PHP应用领域"></a>PHP应用领域</h2><ul>
<li>中小型网站的开发</li>
<li>大型网站的业务逻辑结果展示</li>
<li>Web应用系统</li>
<li>硬件管控软件的GUI</li>
<li>电子商务</li>
<li>多媒体系统</li>
<li>企业级应用</li>
<li>移动互联网</li>
</ul>
<h1 id="PHP扩展库"><a href="#PHP扩展库" class="headerlink" title="PHP扩展库"></a>PHP扩展库</h1><p>PHP5扩展库包括<strong>标准库SPL</strong>和<strong>外部扩展库PECL</strong></p>
<p>PHP扩展库的dll文件都具有<strong>“php_”</strong>前缀</p>
<p>在Windows下加载PHP扩展库，是通过<strong>修改php.ini文件</strong>来完成的；用户也可以在脚本中使用<strong>dl()函数</strong>实现动态加载。</p>
<pre><code class="php.ini">#通过修改php.ini开启/关闭扩展库
#打开php.ini，搜索“.dll”
#以下所示均为扩展库
#“extension”前有“;”即表示该扩展库未启用，若想启用扩展库删除“;”即可。
#更改PHP扩展库配置后，需要对Web服务器进行重启方可生效

extension=bz2    #bz2扩展库已启用
extension=curl
;extension=dba    #dba扩展库未启用
extension=com_dotnet
;extension=enchant
extension=fileinfo
;extension=ftp
extension=gd2
extension=gettext
extension=gmp
extension=intl
extension=imap
;extension=interbase
extension=ldap
extension=mbstring
extension=exif      ; Must be after mbstring as it depends on it
extension=mysqli
;extension=odbc
extension=openssl
;extension=pdo_firebird
extension=pdo_mysql
;extension=pdo_oci
;extension=oci8_12c  ; Use with Oracle Database 12c Instant Client
;extension=pdo_odbc
;extension=pdo_pgsql
extension=pdo_sqlite
;extension=pgsql
;extension=phpdbg_webhelper
;extension=shmop</code></pre>
<blockquote>
<p>修改php.ini配置后，需要重启Web服务器，改动才能生效</p>
</blockquote>
<p>PHP5.3不再支持php_mssql.dll扩展库，即使使用PHP5.2中的php_mssql.dll也无法使用。想要使用PHP5.3连接SQL Server数据库，需要使用微软为PHP专门推出的SQL Server扩展库。</p>
<h1 id="PHP开发"><a href="#PHP开发" class="headerlink" title="PHP开发"></a>PHP开发</h1><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Dreamweaver、PhpStorm</p>
<h2 id="开发手册"><a href="#开发手册" class="headerlink" title="开发手册"></a>开发手册</h2><p><a href="https://www.php.net/docs.php" target="_blank" rel="noopener">点此下载</a></p>
<h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ul>
<li>学会配置PHP开发环境</li>
<li>选择一种适合自己的开发工具</li>
<li>了解设计模式</li>
<li>多实践，多借鉴</li>
<li>遇到bug要冷静</li>
<li>养成良好的开发习惯</li>
<li>学会查看技术手册</li>
</ul>
<h1 id="网站建设基本流程"><a href="#网站建设基本流程" class="headerlink" title="网站建设基本流程"></a>网站建设基本流程</h1><p>确定主题——搜索资料——规划网站——选择开发工具——制作网页——测试网站——上传网站——宣传推广——维护更新</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/09/11/36-PHP-study-notes-1">https://zam9036.gitee.io/2020/09/11/36-PHP-study-notes-1</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在手机上使用Google服务|Zam9036博客</title>
    <url>/2020/07/15/35-How-to-use-Google-services-on-mobile-phones/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/35-How-to-use-Google-services-on-mobile-phones/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="适用平台"><a href="#适用平台" class="headerlink" title="适用平台"></a>适用平台</h1><p>Android</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于众所周知的原因，Google无法在国内访问。所以国内手机厂商并没有在国产手机上提供Google服务框架，这也导致了安装Google应用变得十分困难，有些游戏在国产手机上因没有Google服务而闪退。</p>
<p>本文仅介绍如何在手机上安装Google服务，不提供虚拟专用网络（VPN）相关内容</p>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>本文提供极简安装方法，适用于新手小白。</p>
<p>首先下载<a href="https://pan.baidu.com/s/1K5aLLVxvcdb7Sthe5Q1V_w" target="_blank" rel="noopener">Google服务安装器</a>（提取码：5oea），然后在手机上安装即可。</p>
<p>安装完成后根据提示，一键安装Google服务。注意安装过程中会多次启用应用安装程序，请注意点击“安装”按钮</p>
<p><img src="https://zam9036.gitee.io/img/postimg/35-How-to-use-Google-services-on-mobile-phones/1.jpg" alt="Google服务安装器"></p>
<p>所有服务安装完成后，连接国际互联网，然后就可以访问Google Play商店了</p>
<p><img src="https://zam9036.gitee.io/img/postimg/35-How-to-use-Google-services-on-mobile-phones/2.jpg" alt="Google Play商店"></p>
<p>此时手机可以运行绝大部分Google软件了，但是部分游戏仍不能运行</p>
<p>还需要安装Google Play服务</p>
<p>下载<a href="https://pan.baidu.com/s/1i9SRDCLHJdMGI3CnYOtgAw" target="_blank" rel="noopener">OurPlay</a>（提取码：02ig），安装并启动应用，应用会自动检查Google相关服务，并自动安装。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/35-How-to-use-Google-services-on-mobile-phones/3.jpg" alt="OurPlay"></p>
<p>待安装完毕，手机就成功安装了所有Google服务。</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/07/15/35-How-to-use-Google-services-on-mobile-phones">https://zam9036.gitee.io/2020/07/15/35-How-to-use-Google-services-on-mobile-phones</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036博客</a>！</p>
]]></content>
      <categories>
        <category>极客玩法</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记本拆机初体验|Zam9036博客</title>
    <url>/2020/07/01/34-First-experience-of-laptop-disassembly/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这学期学习了计算机组成原理，但是这门课太过于理论了啊，完全就是纸上谈兵。身为计算机专业的人r，我也就在计算机导论课上拆过一次台式电脑，实在不太行。刚好手边有台很古董的笔记本电脑（十几年前），性能就不谈了，起码能用就行了，不如拆机来看看。</p>
<blockquote>
<p>前方多图预警</p>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先准备好必备的物品：电脑、鼠标、电源线、螺丝刀套装（专业拆机工具包）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/1.jpg" alt="准备物品"></p>
<p>这里螺丝刀套装选用米家的产品，不仅好用而且颜值在线！</p>
<blockquote>
<p>各有喜好，选用其他工具也可以</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/2.jpg" alt="准备物品"></p>
<p>然后来验证一下它是不是还能正常工作吧！开机！</p>
<p>久违的古董XP系统？？？？</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/3.jpg" alt="验证开机"></p>
<p>来看一下参数配置</p>
<table>
<thead>
<tr>
<th align="center">部件</th>
<th align="center">配置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CPU</td>
<td align="center">Intel 凌动N270（1.6GHz）</td>
</tr>
<tr>
<td align="center">屏幕</td>
<td align="center">LED高亮屏（1024*600）、可顺时针180度旋转折叠、支持触屏</td>
</tr>
<tr>
<td align="center">硬盘</td>
<td align="center">SATA硬盘160GB</td>
</tr>
<tr>
<td align="center">内存</td>
<td align="center">DDR2内存1G</td>
</tr>
<tr>
<td align="center">显卡</td>
<td align="center">Intel GMA950</td>
</tr>
<tr>
<td align="center">摄像头</td>
<td align="center">支持夜视</td>
</tr>
<tr>
<td align="center">触摸板</td>
<td align="center">支持手写</td>
</tr>
<tr>
<td align="center">读卡器</td>
<td align="center">Memory Card Read</td>
</tr>
<tr>
<td align="center">连接功能</td>
<td align="center">支持蓝牙、WIFI 802.11b/g</td>
</tr>
</tbody></table>
<p>来看看背面</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/4.jpg" alt="主机背面"></p>
<blockquote>
<p>不得不说，这台笔记本在设计上在当时算比较先进的（尤其是屏幕：180度旋转折叠还支持触屏！（就变成了平板）试问现在有几台笔记本能做到），而且还在背面单独提供了内存条和硬盘的面板，极大的方便了更换内存条和硬盘，可拓展性很强。当然它也暴露了一定的设计缺陷：就拿屏幕来说，频繁的开合和旋转对屏幕连接处造成了很严重的破坏，导致显示器部分脱离了笔记本外壳，产生的突起还把键盘翘起来了。</p>
</blockquote>
<h1 id="拆机过程"><a href="#拆机过程" class="headerlink" title="拆机过程"></a>拆机过程</h1><p>不同的笔记本设计不同，所以拆机步骤需要按照笔记本的设计进行。拆机过程中所有操作应处于断电状态下进行。拆卸下来的螺丝为防止混乱应该单独成堆存放。</p>
<h2 id="拆卸电池"><a href="#拆卸电池" class="headerlink" title="拆卸电池"></a>拆卸电池</h2><p>开始拆卸任何电子设备之前都应该保证其处于断电状态，否则轻会导致线路短路烧坏电路元器件，重会导致引起火灾发生危险。所以拆电脑的第一步：拆电池。</p>
<p>这个笔记本的电池也是可拆卸式的，在电池长条的两边分别有锁。将锁打开将电池取出。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/5.jpg" alt="拆卸电池"></p>
<h2 id="拆卸内存条-amp-硬盘"><a href="#拆卸内存条-amp-硬盘" class="headerlink" title="拆卸内存条&amp;硬盘"></a>拆卸内存条&amp;硬盘</h2><p>这个笔记本的有单独的内存条和硬盘的面板，所以直接从电脑后方拆卸掉面板的螺丝，然后取下内存条和硬盘即可。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/6.jpg" alt="拆卸内存条&amp;硬盘"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/7.jpg" alt="拆卸下来的内存条&amp;硬盘"></p>
<h2 id="拆卸键盘-amp-键盘托壳"><a href="#拆卸键盘-amp-键盘托壳" class="headerlink" title="拆卸键盘&amp;键盘托壳"></a>拆卸键盘&amp;键盘托壳</h2><p>拆卸完内存条和硬盘之后，主机背面已经没有任何可以拆卸的东西。所以我们转战主机正面。松动键盘和键盘托壳，然后观察线路连接结构。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/8.jpg" alt="结构"></p>
<p>可以看出<code>底板-主板-键盘托壳-键盘</code>的结构，键盘穿过键盘托壳与主板相连，键盘托壳上有触控板和两个按钮与主板相连。所以应先拆卸键盘，再拆卸键盘托壳，才能全方位看到主板。</p>
<p>键盘-主板连接就一根线，将这根线去除，键盘就被拆卸下来。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/9.jpg" alt="键盘-主板"></p>
<p>然后来拆卸键盘托壳-主板，先观察结构。</p>
<p>将触控板-主板连接线、指示灯（指示灯的连接线无法拆卸，只能将指示灯从键盘托壳上拆下来）、双扬声器-主板连接线拆卸，键盘托壳就能被拆卸下来。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/10.jpg" alt="键盘托壳-主板"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/11.jpg" alt="主板全貌"></p>
<h2 id="拆卸散热器"><a href="#拆卸散热器" class="headerlink" title="拆卸散热器"></a>拆卸散热器</h2><p>继续拆卸散热器，散热器固定了2颗螺丝，将其一一卸下，然后拆卸散热器-主板连接线，散热器便拆卸完成。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/12.jpg" alt="散热器"></p>
<h2 id="拆卸网卡-amp-显示器"><a href="#拆卸网卡-amp-显示器" class="headerlink" title="拆卸网卡&amp;显示器"></a>拆卸网卡&amp;显示器</h2><p>观察结构，网卡和显示通过一根不可拆卸的线相连接（我也没想清楚这是为什么？），将显示器-主板连接线和网卡相应螺丝拆卸即可。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/13.jpg" alt="拆卸网卡&amp;显示器"></p>
<h2 id="脱离外壳"><a href="#脱离外壳" class="headerlink" title="脱离外壳"></a>脱离外壳</h2><p>将主板与主机外壳螺丝卸下，将外壳的电源线与主板分离，主板就可以取出。（主机正常使用时，主板向上的一面为正面，向地的一面为反面）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/14.jpg" alt="主板正面"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/15.jpg" alt="主板反面"></p>
<h1 id="拆机清单"><a href="#拆机清单" class="headerlink" title="拆机清单"></a>拆机清单</h1><p>详细列举了拆机涉及的所有物品</p>
<p>（螺丝第二行标注的PH0、PH00、PH000等参数为螺丝规格）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/16.jpg" alt="拆机清单"></p>
<h1 id="连线装机"><a href="#连线装机" class="headerlink" title="连线装机"></a>连线装机</h1><p>不要外壳，直接连线装机，还原一下计算机的本质。丢掉风扇，玩个Warcraft3试试？</p>
<blockquote>
<p>危险操作，请勿模仿</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/34-First-experience-of-laptop-disassembly/17.jpg" alt="连线装机"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/07/01/34-First-experience-of-laptop-disassembly">https://zam9036.gitee.io/2020/07/01/34-First-experience-of-laptop-disassembly</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036博客</a>！</p>
]]></content>
      <categories>
        <category>极客玩法</category>
      </categories>
      <tags>
        <tag>实践项目</tag>
        <tag>硬件</tag>
        <tag>课程：计算机导论</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell|Zam9036博客</title>
    <url>/2020/04/26/33-Linux-Shell/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/33-Linux-Shell/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h1><h2 id="什么是shell？"><a href="#什么是shell？" class="headerlink" title="什么是shell？"></a>什么是shell？</h2><p>命令行模式下，用户和UNIX/Linux操作系统内核间的接口。它接收用户输入的命令或数据，并解释执行，之后，将命令的执行结果在显示器等输出设备上显示出来。Shell：外壳，也就是界面</p>
<h2 id="Shell的作用"><a href="#Shell的作用" class="headerlink" title="Shell的作用"></a>Shell的作用</h2><ul>
<li><p>接受输入</p>
</li>
<li><p>解释执行接受到的输入信息</p>
</li>
<li><p>输出结果</p>
</li>
</ul>
<h2 id="Shell提示符"><a href="#Shell提示符" class="headerlink" title="Shell提示符"></a>Shell提示符</h2><p><img src="https://zam9036.gitee.io/img/postimg/33-Linux-Shell/1.png" alt="提示符"></p>
<p>图中<code>zam9036@zam9036-PC:~$</code> 是shell的主提示符，是shell准备接受命令时显示的字符串。</p>
<p><code>zam9036</code>是当前用户名，<code>zam9036-PC</code>是主机名，<code>~</code>表示用户主目录，<code>$</code> 表示用户是普通用户</p>
<blockquote>
<p>对于超级用户（root）来说，<code>$</code>的位置出现的是<code>#</code></p>
</blockquote>
<p>在提示符之后，用户输入命令，然后按Enter键。shell命令解释程序将接收、分析、解释并执行相应的命令，执行结果将在屏幕上显示。</p>
<h3 id="主提示符"><a href="#主提示符" class="headerlink" title="主提示符"></a>主提示符</h3><p>在bash（Linux系统默认的shell）中，主提示符用环境变量PS1表示。</p>
<p>bash默认的主提示符是<code>\s-\v\ $</code> ，其中<code>\s</code>表示shell名称，<code>\v</code>表示bash版本号</p>
<p>可以利用命令修改默认的主提示符</p>
<pre><code class="bash">PS1 = &quot;?&quot;    #将默认主提示符改为？</code></pre>
<h1 id="常用shell命令"><a href="#常用shell命令" class="headerlink" title="常用shell命令"></a>常用shell命令</h1><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>Linux命令的一般格式：<strong>命令名 [<u>选项</u>] [<u>参数</u>]</strong></p>
<p>bash注意事项：</p>
<ul>
<li>命令名必须是小写字母</li>
<li>命令名、选项和参数之间必须用空格或者制表符隔开；连续的空格shell会解释为单空格</li>
<li>一般格式[]括起来的部分是可选的，可有可无；选项是对命令的特别定义，要求该命令执行特定功能</li>
<li>命令在正确执行后会返回一个0值，以表示执行成功。若命令执行出错或中断，会返回一个非零值（可用变量“$ ?”查看）</li>
<li>可以使用man来获取命令的联机说明。如：<code>man ls</code></li>
</ul>
<p>更多详细的命令格式，请参考<a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux命令大全</a></p>
<h2 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h2><h3 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h3><p><code>who</code>列出所有正在使用系统的用户、终端名和注册到系统的时间。</p>
<p><code>whoami</code>列出使用该命令的当前用户信息。</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ who
zam9036  tty1         2020-04-26 12:21 (:0)
zam9036@zam9036-PC:~$ whoami
zam9036</code></pre>
<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><p>将命令行中的参数显示到输出上</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ echo This is Zam9036
This is Zam9036</code></pre>
<h3 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h3><p>显示系统日期和时间</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ date
2020年 04月 26日 星期日 14:27:42 CST</code></pre>
<h3 id="cal命令"><a href="#cal命令" class="headerlink" title="cal命令"></a>cal命令</h3><p>显示一年或一个月的日历</p>
<p>如果cal命令后只有一个参数，则该参数解释为年份；如有两个参数，则第一个为月份，第二个为年份</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ cal 2020
                            2020
         一月                    二月                    三月           
日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六  
          1  2  3  4                     1   1  2  3  4  5  6  7  
 5  6  7  8  9 10 11   2  3  4  5  6  7  8   8  9 10 11 12 13 14  
12 13 14 15 16 17 18   9 10 11 12 13 14 15  15 16 17 18 19 20 21  
19 20 21 22 23 24 25  16 17 18 19 20 21 22  22 23 24 25 26 27 28  
26 27 28 29 30 31     23 24 25 26 27 28 29  29 30 31              


         四月                    五月                    六月           

日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六  
          1  2  3  4                  1  2      1  2  3  4  5  6  
 5  6  7  8  9 10 11   3  4  5  6  7  8  9   7  8  9 10 11 12 13  
12 13 14 15 16 17 18  10 11 12 13 14 15 16  14 15 16 17 18 19 20  
19 20 21 22 23 24 25  17 18 19 20 21 22 23  21 22 23 24 25 26 27  
26 27 28 29 30        24 25 26 27 28 29 30  28 29 30              
                      31                                          

         七月                    八月                    九月           

日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六  
          1  2  3  4                     1         1  2  3  4  5  
 5  6  7  8  9 10 11   2  3  4  5  6  7  8   6  7  8  9 10 11 12  
12 13 14 15 16 17 18   9 10 11 12 13 14 15  13 14 15 16 17 18 19  
19 20 21 22 23 24 25  16 17 18 19 20 21 22  20 21 22 23 24 25 26  
26 27 28 29 30 31     23 24 25 26 27 28 29  27 28 29 30           
                      30 31                                       

         十月                   十一月                   十二月           

日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六  
             1  2  3   1  2  3  4  5  6  7         1  2  3  4  5  
 4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12  
11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19  
18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26  
25 26 27 28 29 30 31  29 30                 27 28 29 30 31        

zam9036@zam9036-PC:~$ cal 10 2020
      十月 2020         
日 一 二 三 四 五 六  
             1  2  3  
 4  5  6  7  8  9 10  
11 12 13 14 15 16 17  
18 19 20 21 22 23 24  
25 26 27 28 29 30 31  
</code></pre>
<h3 id="clear命令"><a href="#clear命令" class="headerlink" title="clear命令"></a>clear命令</h3><p>清除屏幕上所有信息</p>
<h3 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h3><p>更改用户密码</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ passwd
为 zam9036 更改 STRESS 密码。
（当前）UNIX 密码：
输入新的 UNIX 密码：
重新输入新的 UNIX 密码：
passwd：已成功更新密码</code></pre>
<blockquote>
<p>出于安全考虑，用户输入的密码不在屏幕上显示。如果密码不正确，系统会给出提示。</p>
</blockquote>
<h3 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h3><p>更改用户身份</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ sudo su root
[sudo] zam9036 的密码：
root@zam9036-PC:/home/zam9036# sudo su zam9036    #root用户的主提示符为#
zam9036@zam9036-PC:~$ </code></pre>
<h2 id="系统控制命令"><a href="#系统控制命令" class="headerlink" title="系统控制命令"></a>系统控制命令</h2><h3 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h3><p>运行指令<code>exit</code>或<code>logout</code>，亦或直接使用快捷键Ctrl+D</p>
<h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><p>这些指令可以关闭linux操作系统。但作为一个普通用户是不能够随便关闭系统的，因为虽然你用完了机器，可是这时候可能还有其它的用户正在使用系统。因此，关闭系统的操作<strong>只有管理员才有权限执行</strong>。</p>
<pre><code class="bash">#shutdown -h now #下完这个指令，系统立刻关机
#shutdown -h 20:25 #系统会在今天的20：25 关机
#shutdown -h +10 #系统会在十分钟后关机
#halt #效果和shutdown -h now 是完全一样的</code></pre>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>这些指令是用来重新启动系统的。当你输入重启命令后，你就会看到系统正在将一个一个的服务都关闭掉，然后再关闭文件系统和硬件，接着机器开始重新自检，重新引导，再次进入linux 系统。重新启动系统的操作<strong>只有管理员才有权限执行</strong>。</p>
<pre><code class="bash">#shutdown -r now #下完这个指令，系统立刻重启
#shutdown -r 20:25 #系统会在今天的20：25 重启
#shutdown -r +10 #系统会在十分钟后重启
#reboot</code></pre>
<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>LINUX操作系统采用树型的目录结构。在这种结构中，一个文件的名字是由根目录到该文件的路径上的所有节点名按顺序构成的，相互之间用“/”分开。如文件prog的全路径名为：/usr/smith/prog，根目录用“/”表示。</p>
<table>
<thead>
<tr>
<th align="center">目录</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/bin</td>
<td align="center">大部分可执行的Linux命令和共用程序</td>
</tr>
<tr>
<td align="center">/dev</td>
<td align="center">设备文件，如/dev/cd0</td>
</tr>
<tr>
<td align="center">/etc</td>
<td align="center">系统管理命令和数据文件</td>
</tr>
<tr>
<td align="center">/lib</td>
<td align="center">C程序库</td>
</tr>
<tr>
<td align="center">/usr</td>
<td align="center">存放用户的家目录和用户共用程序或文件</td>
</tr>
<tr>
<td align="center">/home</td>
<td align="center">用户的家目录</td>
</tr>
</tbody></table>
<p><strong>家目录:/home</strong></p>
<p>LINUX在创建用户名时，自动在/home目录下创建与用户名同名的子目录，这个子目录成为此用户的家目录（HomeDirectory）。</p>
<p>如：/home/student家目录中有一个文件比较特殊：“.profile”(或“.login”)文件。当以该家目录的用户名登录LINUX时，会自动执行“.profile”文件。</p>
<p>“.profile”文件中常有一行：<code>PATH=$HOME:$HOME/bin</code><!--$HOME表示用户的家目录--></p>
<p>目录区分大小写（abc和Abc表示两个不同的目录）</p>
<table>
<thead>
<tr>
<th align="center">特殊目录</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/</td>
<td align="center">表示根目录</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">表示当前目录</td>
</tr>
<tr>
<td align="center">..</td>
<td align="center">表示当前目录的父目录</td>
</tr>
</tbody></table>
<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p>显示当前目录</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ pwd
/home/zam9036</code></pre>
<h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><p>改变目录</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ cd /home/zam9036/Desktop
zam9036@zam9036-PC:~/Desktop$ </code></pre>
<p>进入家目录</p>
<pre><code class="bash">zam9036@zam9036-PC:~/Desktop$ cd
zam9036@zam9036-PC:~$ </code></pre>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>创建目录</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ mkdir abc
zam9036@zam9036-PC:~$ mkdir /home/zam9036/bcd
zam9036@zam9036-PC:~$ ls
abc  bcd  Desktop  Documents  Downloads  Music  Pictures  Videos  模板</code></pre>
<h3 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h3><p>删除空目录</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ rmdir abc
zam9036@zam9036-PC:~$ rmdir /home/zam9036/bcd
zam9036@zam9036-PC:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Videos  模板</code></pre>
<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p>显示目录内容</p>
<pre><code class="bash">zam9036@zam9036-PC:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Videos  模板
zam9036@zam9036-PC:~$ ls /home/zam9036/Desktop
1234.sh               deepin-appstore.desktop  wps-office-pdf.desktop
123456.docx           deepin-terminal.desktop  wps-office-wpp.desktop
dde-computer.desktop  google-chrome.desktop    wps-office-wps.desktop
dde-trash.desktop     wps-office-et.desktop    新建Word文档.doc</code></pre>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通文件(ordinaryfile)</td>
<td align="center">文本文件、二进制文件</td>
</tr>
<tr>
<td align="center">目录文件(directory)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">特殊文件(specialfile)</td>
<td align="center">块设备文件、字符设备文件</td>
</tr>
<tr>
<td align="center">符号链接文件(symboliclinks)</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">普通文件</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">目录文件</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">块设备文件</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">字符设备文件</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">符号链接文件</td>
</tr>
</tbody></table>
<pre><code class="bash">zam9036@zam9036-PC:~/Desktop$ ls -l
总用量 3176
-rw-r--r-- 1 zam9036 zam9036 3162004 3月  26 11:21 123456.docx
-rw-r--r-- 1 zam9036 zam9036      26 4月  21 16:25 1234.sh
-rw-r--r-- 1 zam9036 zam9036    5243 2月  29 16:06 dde-computer.desktop
-rw-r--r-- 1 zam9036 zam9036    4045 2月  29 16:06 dde-trash.desktop
-rw-r--r-- 1 zam9036 zam9036    2331 2月  29 16:07 deepin-appstore.desktop
-rw-r--r-- 1 zam9036 zam9036    6992 2月  29 16:06 deepin-terminal.desktop
-rw-r--r-- 1 zam9036 zam9036    8491 2月  29 16:05 google-chrome.desktop
-rwxr-xr-x 1 zam9036 root        837 2月  29 15:59 wps-office-et.desktop
-rwxr-xr-x 1 zam9036 root        492 2月  29 15:59 wps-office-pdf.desktop
-rwxr-xr-x 1 zam9036 root       1006 2月  29 15:59 wps-office-wpp.desktop
-rwxr-xr-x 1 zam9036 root        937 2月  29 15:59 wps-office-wps.desktop
-rw-r--r-- 1 zam9036 zam9036   30208 4月  10 12:50 新建Word文档.doc</code></pre>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>LINUX文件有三种存取权限：</p>
<table>
<thead>
<tr>
<th align="center">权限</th>
<th align="center">普通文件的存取权限</th>
<th align="center">目录的存取权限</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">具有读取文件的权利</td>
<td align="center">能读取文件名称和内容</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">具有写入文件的权利</td>
<td align="center">能修改和删除文件，可以改变文件名</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">具有执行文件的权利</td>
<td align="center">能使用该目录下的文件(如cd命令)搜索文件等</td>
</tr>
</tbody></table>
<p>有三种类型的用户可以存取文件：</p>
<table>
<thead>
<tr>
<th align="center">用户类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">owner</td>
<td align="center">文件的所有者(创建该文件的用户)</td>
</tr>
<tr>
<td align="center">group</td>
<td align="center">文件的所有者所在的组</td>
</tr>
<tr>
<td align="center">other</td>
<td align="center">其他用户(非owner和非group)</td>
</tr>
</tbody></table>
<p>文件权限可以通过<code>ls -l</code>命令显示</p>
<pre><code class="bash">zam9036@zam9036-PC:~/Desktop$ ls -l 1234.sh
-rw-r--r-- 1 zam9036 zam9036 26 4月  21 16:25 1234.sh</code></pre>
<h3 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h3><p>以圆点（.）开头的文件为Linux的隐藏文件，如”.profile”</p>
<p>默认情况下，通配符不匹配这类文件名</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th align="center">通配符</th>
<th align="center">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="center">与0个或多个任意字符匹配，如le<em>可以代表letter、lease、le|.\</em>只与隐藏文件匹配</td>
</tr>
<tr>
<td align="center">？</td>
<td align="center">?与单个任意字符匹配，如le??仅能匹配leee，无法匹配letter、lee</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td align="center">[ ]与单个[ ]内的字符匹配，如le[123]仅能匹配le1或le2或le3，不能匹配le12</td>
</tr>
</tbody></table>
<h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><p>chmod用于改变或设置文件或目录的存储权限</p>
<p><strong>符号模式</strong></p>
<p>格式：<code>chmod 用户类型[+-=]文件权限 文件名</code></p>
<ul>
<li>用户类型：u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>[+-=]：+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>文件权限：r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<pre><code class="bash">zam9036@zam9036-PC:~/Desktop/test$ ls -l 1.doc
-rw-r--r-- 1 zam9036 zam9036 15360 4月  26 17:39 1.doc
zam9036@zam9036-PC:~/Desktop/test$ chmod g+w 1.doc
zam9036@zam9036-PC:~/Desktop/test$ ls -l 1.doc
-rw-rw-r-- 1 zam9036 zam9036 15360 4月  26 17:39 1.doc</code></pre>
<pre><code class="bash">zam9036@zam9036-PC:~/Desktop/test$ ls -l 5.sh
-rw-r--r-- 1 zam9036 zam9036 15360 4月  26 17:39 5.sh
zam9036@zam9036-PC:~/Desktop/test$ chmod go+wx 5.sh
zam9036@zam9036-PC:~/Desktop/test$ ls -l 5.sh
-rw-rwxrwx 1 zam9036 zam9036 15360 4月  26 17:39 5.sh</code></pre>
<p><strong>绝对方式</strong></p>
<p>格式：<code>chmod abc 文件名</code></p>
<p>abc计算方法：a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1</p>
<ul>
<li>若要rwx属性则4+2+1=7</li>
<li>若要rw-属性则4+2=6</li>
<li>若要r-x属性则4+1=5</li>
</ul>
<pre><code class="bash">zam9036@zam9036-PC:~/Desktop/test$ ls -l 3.ppt
-rw-r--r-- 1 zam9036 zam9036 9216 4月  26 17:39 3.ppt
zam9036@zam9036-PC:~/Desktop/test$ chmod 754 3.ppt
zam9036@zam9036-PC:~/Desktop/test$ ls -l 3.ppt
-rwxr-xr-- 1 zam9036 zam9036 9216 4月  26 17:39 3.ppt</code></pre>
<pre><code class="bash">chmod a=rwx file
chmod 777 file
#以上两条语句效果相同</code></pre>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>参考资料：<a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux命令大全-菜鸟教程</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/04/26/33-Linux-Shell">https://zam9036.gitee.io/2020/04/26/33-Linux-Shell</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>操作系统</tag>
        <tag>课程：Linux系统实践</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层-计算机网络知识汇总（二）|Zam9036博客</title>
    <url>/2020/03/09/32-Physical-layer-computer-network-knowledge-summary-2/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="数据通信基础"><a href="#数据通信基础" class="headerlink" title="数据通信基础"></a>数据通信基础</h1><h2 id="数据通信系统"><a href="#数据通信系统" class="headerlink" title="数据通信系统"></a>数据通信系统</h2><p>基本组成：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/1.png" alt="基本组成"></p>
<ul>
<li>发送端：实现数据的产生及发送，亦称为信源</li>
<li>中间设备：泛指转发器、网桥、交换机、路由器、网关等</li>
<li>介质：传输介质，实现数据传输的物理通路</li>
<li>报文：泛指在传输信道上承载的具有特定结构的数据单元</li>
<li>接收端：实现数据的接收，亦称为信宿</li>
<li>协议：通信的各方为进行数据交换必须共同遵循的规则</li>
</ul>
<h2 id="通信方式与通信制式"><a href="#通信方式与通信制式" class="headerlink" title="通信方式与通信制式"></a>通信方式与通信制式</h2><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p><strong>并行通信</strong></p>
<p>每个数据编码的各个比特都是同时发送的。</p>
<blockquote>
<p>通常用于计算机系统内部及与外设之间大量频繁的数据传输</p>
</blockquote>
<p><strong>串行通信</strong></p>
<p>比特(bit)的逐位传送(从低位到高位)。</p>
<blockquote>
<p>线路成本低、无串扰，远距离数据传输较好的选择</p>
</blockquote>
<p>远距离网络传输？</p>
<p>—— 线路的成本、串扰等原因，一般不采用并行通信。</p>
<h3 id="通信制式"><a href="#通信制式" class="headerlink" title="通信制式"></a>通信制式</h3><p><strong>单工通信</strong></p>
<p>利用一条物理信道(2线制）进行单向信息传输。</p>
<blockquote>
<p>多用于测试或控制环境下的数据传输</p>
</blockquote>
<p><strong>半双工通信</strong></p>
<p>可以进行双向传输，但由于只有一条物理信道(2线制)，因此，同一时刻只限于一个方向传输。</p>
<blockquote>
<p>广泛应用于交互式会话通信情况下</p>
</blockquote>
<p><strong>全双工通信</strong></p>
<p>通信双方在任何时刻，均可进行双向通信，无任何限制。</p>
<blockquote>
<p>需要两条以上的物理信道(3线制或4线制)</p>
<p>可以构成全双工网络</p>
</blockquote>
<h2 id="数据的同步方式"><a href="#数据的同步方式" class="headerlink" title="数据的同步方式"></a>数据的同步方式</h2><p><strong>什么叫同步？</strong></p>
<p>数据发送者和数据接收者协调一致，密切配合。</p>
<p><strong>为什么要同步？</strong></p>
<p>如果发送端和接收端的<strong>时钟</strong>不同步，即使只有极小的误差，随着时间的增加，误差逐渐积累，终究会造成收发之间的<strong>失步</strong>。</p>
<blockquote>
<p>同步技术直接影响着通信的质量</p>
</blockquote>
<p><strong>如何同步？</strong></p>
<p><strong>接收端</strong>不但要知道<strong>一组二进制位的开始与结束</strong>，还需要知道<strong>每位的持续时间</strong>，这样才能做到用合适的采样频率适时采样所接收到的数据。—— 与发送端同步</p>
<p><strong>能否利用各自的时钟信号同步？</strong></p>
<p>由于发送端和接收端的时钟信号不可能绝对一致，因此不够可靠。—— 往往需要另外采取一定的同步手段。</p>
<h3 id="异步传输控制-字符同步方式"><a href="#异步传输控制-字符同步方式" class="headerlink" title="异步传输控制(字符同步方式)"></a>异步传输控制(字符同步方式)</h3><p><strong>如何使接收端能准确判断出数据的开始与结束</strong></p>
<p>以一个<strong>字符</strong>作为数据传输的基本单位，首末分别<strong>增加1位起始位和1位停止位</strong>，表示字符的开始和结束。—— 通常，起始位是“0”，结束位是“1”</p>
<p><strong>数据传输形式</strong></p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/2.png" alt="传输形式"></p>
<p><strong>位的持续时间</strong></p>
<p>由于位数少，不至于失步，不考虑。</p>
<h3 id="同步传输控制"><a href="#同步传输控制" class="headerlink" title="同步传输控制"></a>同步传输控制</h3><p>以“<strong>数据块</strong>”(几千个数据位)为单位进行传输。</p>
<p><strong>特定要求</strong></p>
<p>由于单位大，为了防止发送端和接收端的失步，发送时钟和接收时钟必须<strong>高度同步</strong>。</p>
<p><strong>如何使接收端能准确判断出数据的开始与结束</strong></p>
<p>做法：在数据块前面加一个确定长度的位模式，称为前文，数据结束后也加上后文—— <strong>帧</strong></p>
<p><strong>位持续时间</strong></p>
<p><strong>自同步法</strong>，即从所接收的数据中提取时钟的特征。因为其发送数据中包含着发送时钟信号。——实现了双方采样点的同步</p>
<p><strong>帧的接收过程</strong></p>
<p>接收端检测到前文后，即说明有数据到达，接收端利用从数据中提取的时钟信号作为接收时钟，按顺序接收前文后的数据信息，直至接收到后文为止。</p>
<blockquote>
<p>效率高</p>
</blockquote>
<h1 id="数据传输介质"><a href="#数据传输介质" class="headerlink" title="数据传输介质"></a>数据传输介质</h1><h2 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h2><p>4对铜线，每对按螺旋结构排列</p>
<blockquote>
<p>电磁干扰(串扰)最小</p>
</blockquote>
<p>3类/5类/5e类/6类，屏蔽/非屏蔽 ，100米远</p>
<h2 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h2><p>现已很少使用</p>
<h2 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h2><p><strong>原理</strong>：光信号，在玻璃等纤维中全反射传输，光电转换</p>
<p><strong>分类</strong>：</p>
<ul>
<li><strong>单模</strong>（纤芯：8~10μm，光源：单色(激)光，带宽大，传输距离远，主要用于城域网/广域网） </li>
<li><strong>多模</strong>（纤芯：10~75μm，光源：多色(可见)光，带宽小，传输距离近，主要用于园区网）</li>
<li>光纤跳线：SC/ST/FC/MT-RJ/LC连接器</li>
</ul>
<p><strong>通信光缆</strong></p>
<p>多芯（2/4/8/12/16等）光纤，保护层，钢丝，护套</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/3.png" alt="各类光纤"></p>
<h2 id="网络综合布线"><a href="#网络综合布线" class="headerlink" title="网络综合布线"></a>网络综合布线</h2><h3 id="网络综合布线概念"><a href="#网络综合布线概念" class="headerlink" title="网络综合布线概念"></a>网络综合布线概念</h3><p>结构化综合布线系统（Premises Distribution System，PDS）最早由贝尔（Bell）实验室首先提出，并于20世纪80年代末期率先推出产品。</p>
<p><strong>什么是PDS</strong></p>
<p>将分布在网络不同覆盖区域的所有线缆按照一定的标准和结构，并通过专用的器件集成起来，不仅满足网络设备连接的需要，而且方便网络设备的灵活调整和网络的维护。在形式上呈现一种立体交叉的层次化结构。</p>
<p><strong>说明</strong>：电信网络、数据网络、监控网络目前大多因分别设计而呈分离状态。结构化综合布线系统主要指数据网络。</p>
<p><strong>特点</strong>：网络综合布线系统本身与网络设备独立。每个部分都是相对独立的单元（模块化），所有连接器件都是标准化的，每个单元的改变都不会影响其它子系统。</p>
<p>情况比较：</p>
<p>情况1：按照网络连接原理：设备在哪里，线就布到哪里。</p>
<p>后果：一旦增加设备或设备位置发生变化就要增加或者重新布线。</p>
<p>情况2：按照结构化综合布线要求：先按结构化综合布线的规范将线路部署好，然后再将不同位置的设备接入到网络。</p>
<p>效果：</p>
<ul>
<li>布线层次清晰，标注明确，便于管理和维护。</li>
<li>如果增加设备或设备位置发生变化，不必重新布线，只要简单的调整配线间或设备间的跳接即可。</li>
</ul>
<h3 id="综合布线产品系列"><a href="#综合布线产品系列" class="headerlink" title="综合布线产品系列"></a>综合布线产品系列</h3><p>机柜、配线架、理线器、信息面板、跳线、工具。</p>
<h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p><strong>概念</strong>：信道复用即<strong>信道共享</strong></p>
<p><strong>目的</strong>：充分利用信道的容量，提高信道的利用率。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/4.png" alt="信道复用技术"></p>
<p><strong>逻辑思想</strong>： 把<strong>单条物理信道</strong>划分成<strong>多条逻辑信道</strong>，每一条逻辑信道传输一路数据，那么，一条物理信道就可以传输多路数据。</p>
<p><strong>使用设备</strong>：各种不同形式的“多路复用器”</p>
<p>技术实现：</p>
<ul>
<li><p>频分多路复用 (FDM)</p>
</li>
<li><p>时分多路复用 (TDM)</p>
</li>
<li><p>统计时分多路复用（STDM）</p>
</li>
<li><p>波分多路复用(WDM)</p>
</li>
<li><p>码分多路复用（CDM）&amp;码分多址复用（CDMA）</p>
</li>
</ul>
<h2 id="频分多路复用-FDM"><a href="#频分多路复用-FDM" class="headerlink" title="频分多路复用 (FDM)"></a>频分多路复用 (FDM)</h2><p>按信号占用的<strong>频谱范围</strong>对信道的(频)带宽(度)进行分割。</p>
<p>在传输多路信号时，通过调制技术将不同路的信号搬到不同频段，使每路信号占用互不重叠的频率范围，在共享信道传输完成后，再利用解调技术将各路信号搬回原来的频段上。</p>
<blockquote>
<p>更适于模拟数据信号的传输</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/5.png" alt="FDM"></p>
<h2 id="时分多路复用-TDM"><a href="#时分多路复用-TDM" class="headerlink" title="时分多路复用 (TDM)"></a>时分多路复用 (TDM)</h2><p>多路信号<strong>对信道的传输时间进行周期性分割</strong>，每路信号占用互不重叠的时间片。</p>
<blockquote>
<p>利用不同时隙传送不同路信号</p>
</blockquote>
<p>主要特点：</p>
<ul>
<li>各路信号在频谱上是重叠的(占用同样带宽)</li>
<li>但在时间上是不重叠的。 </li>
</ul>
<blockquote>
<p>更适合于数字信号的传输</p>
</blockquote>
<p>传输形式：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/6.png" alt="TDM1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/7.png" alt="TDM2"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/8.png" alt="TDM3"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/9.png" alt="TDM4"></p>
<p>T1载波系统：将24路音频信道复用在一条通信线路上。24路PCM信号的每一路，轮流将一个字节插入到帧中。每帧由24×8＝192位组成，附加一位作为帧开始标志位，每帧共有193位。发送一帧需要125毫秒，T1载波的数据传输速率为：193/125=1.544Mbps 。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/10.png" alt="TDM5"></p>
<p>30路的E1载波系统</p>
<p>效率分析：由于数据的<strong>突发性</strong>，用户对分配到的时隙利用率不高。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/11.png" alt="TDM6"></p>
<h2 id="统计时分多路复用（STDM）"><a href="#统计时分多路复用（STDM）" class="headerlink" title="统计时分多路复用（STDM）"></a>统计时分多路复用（STDM）</h2><p>统计时分多路复用 STDM (Statistic TDM)—— 不固定分配时隙，而是按需动态分配时隙。</p>
<p>特点：</p>
<ul>
<li>每路的帧无固定插入位置</li>
<li>每个帧必须给出地址信息，以便识别</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/12.png" alt="STDM"></p>
<h2 id="波分多路复用-WDM"><a href="#波分多路复用-WDM" class="headerlink" title="波分多路复用(WDM)"></a>波分多路复用(WDM)</h2><p>按信号的波长(频率)对光纤信道的(频)带宽(度)进行分割。</p>
<p>—— 通过调制技术使不同路的光信号具有不同的波长，在共享信道传输完成后，再利用解调技术将各路信号恢复为原来的波长。</p>
<p>波分多路复用原理示意图 ：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/13.png" alt="WDM1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/14.png" alt="WDM2"></p>
<h2 id="码分多路复用（CDM）-amp-码分多址复用（CDMA）"><a href="#码分多路复用（CDM）-amp-码分多址复用（CDMA）" class="headerlink" title="码分多路复用（CDM）&amp;码分多址复用（CDMA）"></a>码分多路复用（CDM）&amp;码分多址复用（CDMA）</h2><p>码分多路复用CDM (Code Division Multiplexing)</p>
<p>码分多址复用CDMA (Code Division MultipleAccess)</p>
<p>利用不同的编码(码形)实现多目标信息传输的系统。该技术建立在正交编码、相关接收的理论基础上。</p>
<p>各个目标的数字化信号，经正交PN码扩频调制，使频谱扩展几百倍至上千倍，然后分别调制到上千兆赫兹的同一频率的载波上发送；接收端利用PN码的正交特性进行相关解扩，再经窄带滤波，恢复出与本地PN码所对应的目标信号。</p>
<p>主要特点：</p>
<ul>
<li>扩频后，信号功率分布在很宽的频带中，接收不易发生“阻塞”现象</li>
<li>抗干扰能力强，保密性好，误码率低</li>
<li>使用的载波频率不需要向有关部门申请</li>
</ul>
<h1 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h1><h2 id="宽带接入技术概述"><a href="#宽带接入技术概述" class="headerlink" title="宽带接入技术概述"></a>宽带接入技术概述</h2><h3 id="为什么要接入互联网"><a href="#为什么要接入互联网" class="headerlink" title="为什么要接入互联网"></a>为什么要接入互联网</h3><ul>
<li><p>Internet网上资源和服务越来越丰富</p>
</li>
<li><p>人们已经不满足于在单一的物理网络范围内进行相互通信和共享资源</p>
</li>
</ul>
<blockquote>
<p>进行更大范围的信息传递和获取更广泛的资源</p>
</blockquote>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>信息高速公路的最后一公里问题</p>
<blockquote>
<p>直接连接到Internet的主干网或区域网上是<strong>不太现实的</strong></p>
</blockquote>
<h3 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h3><p>通过接入网</p>
<p>接入形式：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/15.png" alt="接入形式"></p>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网的形式</p>
<ul>
<li><p>计算机网：传输数字信号</p>
</li>
<li><p>公共电话网：传输语音/传真信号</p>
</li>
<li><p>广播电视网：传输视频信号。</p>
</li>
</ul>
<h3 id="目前可提供的宽带接入技术"><a href="#目前可提供的宽带接入技术" class="headerlink" title="目前可提供的宽带接入技术"></a>目前可提供的宽带接入技术</h3><ul>
<li><p>局域网接入技术</p>
</li>
<li><p>借助于公共电话网的xDSL接入技术</p>
</li>
<li><p>基于广播电视网的光纤-同轴电缆混合HFC接入技术</p>
</li>
<li><p>光纤接入技术</p>
</li>
<li><p>无线网接入技术</p>
</li>
<li><p>移动网接入技术</p>
</li>
<li><p>微波接入技术</p>
</li>
<li><p>电力载波接入技术</p>
</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/16.png" alt="宽带接入技术"></p>
<h2 id="数字用户线xDSL接入技术"><a href="#数字用户线xDSL接入技术" class="headerlink" title="数字用户线xDSL接入技术"></a>数字用户线xDSL接入技术</h2><h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p>ADSL即非对称数字用户线</p>
<p>在现有的普通电话线上提供：</p>
<ul>
<li><p>6~8Mbit/s的高速下行速率</p>
</li>
<li><p>640Kbit/s~1Mbit/s的上行速率</p>
</li>
<li><p>传输距离可达2.7km-3.6km</p>
</li>
</ul>
<p>形式：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/17.png" alt="ADSL接入形式"></p>
<p><strong>AAA服务器的作用</strong></p>
<ul>
<li><p>负责接收用户的连接请求（同时提供用户名和密码）</p>
</li>
<li><p>对用户身份进行认证</p>
</li>
<li><p>并为客户端返回所有为用户提供服务所必须的配置信息</p>
</li>
</ul>
<p><strong>如何确保在不安全的网络上传输信息的安全性</strong></p>
<p>客户端和AAA服务器之间的所有交互都需要经过共享保密字的认证</p>
<blockquote>
<p>在客户端和AAA服务器之间的任何用户密码都是被加密后传输的</p>
</blockquote>
<p><strong>基于RADIUS协议的典型认证授权工作过程</strong><br>1、用户输入用户名、密码等信息到客户端</p>
<p>2、客户端产生一个“接入请求（Access-Request）”报文到AAA服务器，其中包括用户名、口令、客户端（NAS）ID 和用户访问端口的ID。口令经过MD5算法进行加密</p>
<p>3、AAA服务器对用户进行认证</p>
<p>4、若认证成功，AAA服务器向客户端发送允许接入包（Access-Accept），否则发送拒绝接入包（Access-Reject） </p>
<p>5、若客户端接收到允许接入包，则为用户建立连接，对用户进行授权和提供服务，并转入6；若接收到拒绝接入包，则拒绝用户的连接请求，结束协商过程</p>
<p>6、客户端发送计费请求包给AAA服务器</p>
<p>7、AAA服务器接收到计费请求包后开始计费，并向客户端回送开始计费响应包</p>
<p>8、用户断开连接，客户端发送停止计费包给AAA服务器</p>
<p>9、AAA服务器接收到停止计费包后停止计费，并向客户端回送停止计费响应包，完成该用户的一次计费，记录计费信息</p>
<p><strong>ADSL实现原理</strong></p>
<p>ADSL调制解调器使用频分多路复用技术，将用户电话线带宽划分为3个频段:</p>
<ul>
<li><p>0~4kHz用于传送电话信号</p>
</li>
<li><p>20~50kHz用于传送上行数字信息</p>
</li>
<li><p>140~1100kHz用于速率为8Mbps的下行数字信息的传输</p>
</li>
</ul>
<blockquote>
<p>其中150~500kHz用于速率为1.5Mbps的下行数字信息的传输</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/18.png" alt="ADSL实现原理1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/19.png" alt="ADSL实现原理2"></p>
<blockquote>
<p>将数字用户线路改造成为具有3条独立信道的通信管道，彼此可以互不干扰的传输各自的数据</p>
</blockquote>
<p>接入方式：</p>
<ul>
<li>家庭用户：一般提供<strong>虚拟拨号(无固定IP)</strong>接入方式</li>
<li>局域网用户：一般提供专线(静态IP)接入方式</li>
</ul>
<p>采用协议：<strong>PPPoE协议</strong></p>
<h3 id="其他DSL接入技术"><a href="#其他DSL接入技术" class="headerlink" title="其他DSL接入技术"></a>其他DSL接入技术</h3><ul>
<li>HDSL（High-bit-rate DSL）通过使用2对双绞线以全双工方式进行传输，支持N×64kbps的各种速率，最高可达E1（2.048Mbps)速率，传输距离可达3.6km</li>
<li>SDSL（Single-line DSL）即为HDSL的单线对版本，性能与HDSL基本相同</li>
<li>RADSL（Rate Adaptive DSL）即速率自适应技术，它允许服务提供者调整xDSL连接的带宽，以解决线长和传输质量问题，适应实际需要。下行速率的范围为640kbps到12Mbps，上行速率范围为128kbps到1Mbps。它利用一对双绞线同时支持语音和数据传输，而且支持同步和非同步两种传输方式</li>
<li>VDSL（Very-high-data-rate DSL）为超高速数字用户线技术，该技术可以支持在相对较短的距离内（如300m）达到最高52-55 Mbps的下行传输速率和6.4Mbps的上行速率。当用户线路长度在1000-1500m时，下行速率可以达到13 Mbps或更高；上行速率可以达到1.3 Mbps，甚至更高</li>
</ul>
<h2 id="光纤同轴混合HFC接入技术"><a href="#光纤同轴混合HFC接入技术" class="headerlink" title="光纤同轴混合HFC接入技术"></a>光纤同轴混合HFC接入技术</h2><ul>
<li>主干网为光缆，将光信号从局端传输到居民小区</li>
<li>光信号转换为电信号后，再通过同轴电缆传输到用户家中</li>
<li>用户则使用电缆调制解调器Cable Modem(机顶盒）接入到网络</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/20.png" alt="HFC"></p>
<p>目前，HFC网络的频带划分情况：</p>
<ul>
<li>5~42MHz为上行通道，用于传输VOD信令、IP电话和状态信息等</li>
<li>54<del>550 MHz为下行通道，用于传输模拟电视节目，按照每路带宽为6</del>8 MHz，可以传送各种不同制式的电视信号达60-80路</li>
<li>550~750 MHz：用于传送数字视频信号以及各种双向交互通信业务</li>
<li>750~1000 MHz：用于未来可能出现的各种双向通信业务</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/21.png" alt="HFC网络频谱划分"></p>
<p><strong>性能指标</strong></p>
<ul>
<li>Cable Modem的下行速率：3~10Mbps</li>
<li>最高可达36Mbps；而上行速率一般为0.2~2 Mbps，最高可达10Mbps</li>
</ul>
<p><strong>HFC网络的有利条件</strong></p>
<ul>
<li>模拟信号与数字信号可以共存</li>
<li>已经基本实现对现有的CATV网络的双向传输改造</li>
</ul>
<p><strong>存在的主要问题</strong></p>
<p>由于上行信道采用共享方式，因此存在传输冲突问题；而且下行信道的带宽也略显不足。</p>
<h2 id="FTTx接入技术"><a href="#FTTx接入技术" class="headerlink" title="FTTx接入技术"></a>FTTx接入技术</h2><p>光接入网（OAN）：从本地交换机到用户之间全部或部分采用光纤通信的系统。</p>
<p>同xDSL的表示方式相似，FTTx是光纤接入技术的总称。</p>
<ul>
<li>光纤到路边（Fiber To The Curb，FTTC）</li>
<li>光纤到小区（Fiber To The Zone，FTTZ）</li>
<li>光纤到楼（Fiber To The Building，FTTB）</li>
<li>光纤到户（Fiber To The Home，FTTH）</li>
</ul>
<p>FTTC、FTTZ、FTTB接入技术的共同特点：</p>
<p>光纤到达相应的位置后就通过光电转换器转换成电信号，然后再通过双绞线（或同轴电缆等）分配给每个用户。</p>
<blockquote>
<p>FTTH是家庭接入的最终解决方案，速率可以达到155Mbps</p>
</blockquote>
<h2 id="宽带无线接入（BWA）技术"><a href="#宽带无线接入（BWA）技术" class="headerlink" title="宽带无线接入（BWA）技术"></a>宽带无线接入（BWA）技术</h2><p>宽带无线接入服务：带宽超过2Mbps的无线接入技术。</p>
<ul>
<li>802.11无线局域网（WLAN）重点解决小范围内的移动结点通信问题。但由于用户数和覆盖范围的限制，无法用于大范围的无线接入</li>
<li>802.16无线城域网（WMAN）的重点是解决更大范围的固定结点数据通信问题。标准的颁布和WiMAX技术的成熟，城域宽带无线接入技术快速进入实际应用</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/22.png" alt="BWA网络拓扑结构"></p>
<p>无线广域网（MWAN）</p>
<p>覆盖全国或全球范围内的无线网络，可以使笔记本电脑、智能手机、PDA或其它设备在网络覆盖的任何位置接入到互联网。</p>
<ul>
<li>与无线局域网和无线城域网相比，除了可以提供更大范围的无线接入外，还主要体现在快速移动性上</li>
<li>从目前的应用来看，其信息传输速率并不高，一般无法满足多媒体应用的需要，只能适用于手机、PDA等处理能力较低的弱终端，而对于具有高强处理能力的笔记本电脑来说，是不太适宜的</li>
<li>典型的无线广域网包括卫星通信系统、GSM和CDMA移动通信系统，以及3G、3G+和4G技术。无线广域网的标准为IEEE802.20</li>
</ul>
<h1 id="数据编码技术"><a href="#数据编码技术" class="headerlink" title="数据编码技术"></a>数据编码技术</h1><h2 id="数据与信号"><a href="#数据与信号" class="headerlink" title="数据与信号"></a>数据与信号</h2><ul>
<li>数据：信息被记录/存储状态</li>
<li>信号：数据在传输过程中</li>
<li>模拟数据：连续变化的，没有突变，如一段录音/视频</li>
<li>数字数据：离散形式的，用0/1两个完全不同的状态表示</li>
<li>模拟信号：在时间上和幅度上连续变化的</li>
<li>数字信号：在时间上和幅度上不连续变化</li>
<li>数字传输：以数字信号的形式传输</li>
</ul>
<h2 id="数据的编码与传输方式"><a href="#数据的编码与传输方式" class="headerlink" title="数据的编码与传输方式"></a>数据的编码与传输方式</h2><h3 id="数据的四种传输方式"><a href="#数据的四种传输方式" class="headerlink" title="数据的四种传输方式"></a>数据的四种传输方式</h3><ul>
<li>数字数据的数字传输方式</li>
<li>数字数据的模拟传输方式</li>
<li>模拟数据的数字传输方式</li>
<li>模拟数据的模拟传输方式：无需编码与解码，不作讨论</li>
</ul>
<h3 id="数字数据的数字编码与传输"><a href="#数字数据的数字编码与传输" class="headerlink" title="数字数据的数字编码与传输"></a>数字数据的数字编码与传输</h3><p>基带信号：从数据终端设备送出的未经任何转换的脉冲数字信号。</p>
<p>基带传输：<strong>直接传送</strong>基带信号，无需转换成<strong>频带信号</strong>。</p>
<blockquote>
<p>但往往要转换成更适于传输的数字信号形式</p>
<p>局域网广泛应用</p>
</blockquote>
<ul>
<li>NRZ非归零码</li>
<li>RZ码</li>
<li>AMI码：</li>
<li>2B1Q码：</li>
<li>8B6T码</li>
<li>MLT-3码</li>
</ul>
<p><strong>曼彻斯特编码</strong></p>
<p>在每一数据位的中间产生一次信号跳变</p>
<p><strong>低-高：1，高-低：0</strong></p>
<blockquote>
<p>同时表示数据的发送时钟，用于实现同步</p>
<p>自同步编码，无需用另外一条信道去发送同步信号</p>
<p>以太网发送的数据都使用曼彻斯特(Manchester)编码</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/23.png" alt="曼彻斯特编码"></p>
<p><strong>差分曼彻斯特编码</strong></p>
<p>改进的曼彻斯特编码。位中心的跳变只表示时钟，每位开始有无跳变表示数据。</p>
<p><strong>有跳变：0，无跳变：1</strong></p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/24.png" alt="差分曼彻斯特编码"></p>
<p><strong>基带传输的缺陷</strong></p>
<ul>
<li>基带信号含有大量的低频成份和直流分量</li>
<li>基带信号的抗干扰能力也不支持在模拟线路(如电话线路)上进行远距离传输</li>
</ul>
<blockquote>
<p>必须采取某种措施将基带数字信号调制到模拟线路的频带范围内，转换成频带信号再行传输。</p>
</blockquote>
<p>调制器：将基带脉冲信号转换成连续载波信号的设备。</p>
<p>已调信号：经过调制后的信号。</p>
<p>解调器：将连续载波信号转换成基带脉冲信号的设备</p>
<p>调制解调器：同时具备调制与解调功能，实现两个相反方向转换的设备</p>
<blockquote>
<p>信号的调制就是利用基带信号对载波波形的某些参数进行控制，使这些参数随基带脉冲信号的变化而变化</p>
</blockquote>
<h3 id="调制方法（数字数据的模拟编码与传输）"><a href="#调制方法（数字数据的模拟编码与传输）" class="headerlink" title="调制方法（数字数据的模拟编码与传输）"></a>调制方法（数字数据的模拟编码与传输）</h3><ul>
<li>调幅(AM)：载波的振幅随基带数字信号的变化而变化</li>
<li>调频(FM)：载波的频率随基带数字信号的变化而变化</li>
<li>调相(PM)：载波的初始相位随基带数字信号的变化而变化</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/25.png" alt="调制方法"></p>
<h3 id="模拟数据的数字编码与传输"><a href="#模拟数据的数字编码与传输" class="headerlink" title="模拟数据的数字编码与传输"></a>模拟数据的数字编码与传输</h3><p><strong>多媒体数据</strong>包括：语音、图像、视频</p>
<p><strong>多媒体数据的存储、处理与传输方式</strong>：</p>
<ul>
<li>数字化（减少存储量，提高传输效率）</li>
<li>压缩</li>
</ul>
<p><strong>数字化的方法</strong>：</p>
<ul>
<li>脉冲编码调制(PCM，Pulse Code Modulation)</li>
<li>增量调制(DM，Delta Modulation)</li>
</ul>
<p>PCM方法应用的多，以此为例介绍。</p>
<p><strong>脉冲编码调制(PCM)方法</strong></p>
<p>三个步骤：</p>
<p><strong>采样</strong></p>
<p>采样频率越高，恢复原始信号的精度越高。</p>
<blockquote>
<p>若采样频率为信号频率的2倍，就可以准确再现原始信号</p>
</blockquote>
<p><strong>量化</strong></p>
<p>将信号分为若干量化级，8、16、32或更多</p>
<p>将采样样本值与量化级值进行比较，确定所属的量化级</p>
<blockquote>
<p>经过量化处理后的样本值成为离散的量级值，已不是连续值</p>
</blockquote>
<p><strong>编码</strong></p>
<p>用相应位数的二进制代码表示量化后的采样样本的量级。</p>
<blockquote>
<p>如果有K个量化级，则所需的二进制位数为$log_2K$。</p>
</blockquote>
<p><strong>PCM典型应用</strong></p>
<p>将语音分为128个量化级，采用7位二进制编码表示。采样速率为8000样本／秒，数据传输速率可达：7×8000bit/s＝56kbps</p>
<p><img src="https://zam9036.gitee.io/img/postimg/32-Physical-layer-computer-network-knowledge-summary-2/26.png" alt="小结"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/03/09/32-Physical-layer-computer-network-knowledge-summary-2">https://zam9036.gitee.io/2020/03/09/32-Physical-layer-computer-network-knowledge-summary-2</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>课程：计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>判断某数是否为同余数-C语言|Zam9036博客</title>
    <url>/2020/03/06/31-Determine-if-a-number-is-congruent-C-language/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="代码语言"><a href="#代码语言" class="headerlink" title="代码语言"></a>代码语言</h1><p>C语言</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近期，一个数学系专业的朋友联系我，问我能不能写出一个程序实现“判断一个数是否为整同余数”的功能，他还给了我同余数的定义：同余数是一个三边均为有理数的直角三角形的面积</p>
<h1 id="问题研究"><a href="#问题研究" class="headerlink" title="问题研究"></a>问题研究</h1><p>对于程序设计来说，仅仅按照这个定义来实现“判断一个数是否为同余数”的功能实在困难，就单纯让计算机来判断一个数是不是有理数就是一门学问。</p>
<p>所以我只好另辟蹊径，找找还有什么方法能验证一个数是同余数。在百度百科上，我看到了数学家给出的一个重要结论，也是验证n是整同余数的充要条件：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/1.png" alt="重要结论"></p>
<p>我很敬佩数学家们的智慧，能得出这个重要的结论，这对用程序验证一个数是整同余数指明了思路。</p>
<h2 id="四个变量"><a href="#四个变量" class="headerlink" title="四个变量"></a>四个变量</h2><p>首先，我们需要<strong>四个变量：n,a,b,v</strong></p>
<p>这四个变量的关系是：<strong>需要寻找n，要先确定a,b,v</strong></p>
<h2 id="四个条件"><a href="#四个条件" class="headerlink" title="四个条件"></a>四个条件</h2><p>然后，这四个变量需要满足以下四个条件</p>
<ul>
<li><strong>(a,b)=1</strong></li>
<li><strong>a,b一奇数一偶数</strong></li>
<li><strong>a,b为正整数并且a&gt;b</strong></li>
<li><strong>a,b,n,v需要满足图中等式</strong></li>
</ul>
<h3 id="条件一：-a-b-1"><a href="#条件一：-a-b-1" class="headerlink" title="条件一：(a,b)=1"></a>条件一：(a,b)=1</h3><p>我们需要弄清楚这个式子是什么意思。我问了一下数学系的朋友，这式子的意思是说a,b的最大公因数是1，即a,b互质。判断两个数互质的算法我依稀记得是C语言课的练习题，很好解决。在这里我采用<strong>欧几里德算法</strong>来求取两个数的最大公因数。如果最大公因数是1也就是a,b互质的话，则函数<code>huzhi</code>返回值为1；不互质返回值为0，代码如下：</p>
<pre><code class="c">//条件一：a,b互质
//若互质返回1,不互质返回0
int huzhi(int a,int b){
    int t;
    if(a&lt;b)
    {
        t=a;a=b;b=t;
    }
    while(a%b)
    {
        t=b;
        b=a%b;
        a=t;
    }
    if(b==1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}</code></pre>
<h3 id="条件二：a-b一奇数一偶数"><a href="#条件二：a-b一奇数一偶数" class="headerlink" title="条件二：a,b一奇数一偶数"></a>条件二：a,b一奇数一偶数</h3><p>这个条件很简单，只有两种情况：</p>
<ul>
<li>a是奇数并且b是偶数</li>
<li>b是奇数并且a是偶数</li>
</ul>
<pre><code class="c">//条件二：a,b一奇数一偶数
//满足条件返回1，不满足条件返回0
int jio(int a,int b){
    if((a%2==0&amp;&amp;b%2!=0)||(a%2!=0&amp;&amp;b%2==0))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}</code></pre>
<h3 id="条件三：a-b为正整数并且a-gt-b"><a href="#条件三：a-b为正整数并且a-gt-b" class="headerlink" title="条件三：a,b为正整数并且a&gt;b"></a>条件三：a,b为正整数并且a&gt;b</h3><p>这个条件也很简单，可细化为三个条件：</p>
<ul>
<li>a,b为整数</li>
<li>a&gt;0并且b&gt;0</li>
<li>a&gt;b</li>
</ul>
<pre><code class="c">//条件三：a,b正整数并且a&gt;b
//满足条件返回1，不满足条件返回0
int tiaojian(int a,int b){
    if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;a&gt;b)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}</code></pre>
<h3 id="条件四：a-b-n-v需要满足等式"><a href="#条件四：a-b-n-v需要满足等式" class="headerlink" title="条件四：a,b,n,v需要满足等式"></a>条件四：a,b,n,v需要满足等式</h3><p>来解释一下这个等式，这个等式or的意思是或者，所以这个等式也可以细化为三个等式三个条件：</p>
<ul>
<li>$nv^2=6a^2b^2-a^4-b^4$</li>
<li>$nv^2=-6a^2b^2+a^4+b^4$</li>
<li>$nv^2=4ab(a^2-b^2)$</li>
</ul>
<p>三个等式满足其一即可</p>
<pre><code class="c">//条件四：满足判断公式
//满足公式返回1，不满足公式返回0
int gongshi(int a,int b,int v,int n){
    int left=n*v*v,right1=4*a*b*(a*a-b*b),right2=6*a*a*b*b-a*a*a*a-b*b*b*b,right3=-6*a*a*b*b+a*a*a*a+b*b*b*b;
    if(left==right1||left==right2||left==right3)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}</code></pre>
<p>主函数暂且先用三个内嵌循环来寻找n，详见代码清单。</p>
<h1 id="程序验证"><a href="#程序验证" class="headerlink" title="程序验证"></a>程序验证</h1><p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/2.png" alt="程序验证1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/3.png" alt="程序验证2"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/4.png" alt="程序验证3"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/5.png" alt="程序验证4"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/6.png" alt="程序验证5"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/7.png" alt="程序验证6"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/8.png" alt="程序验证7"></p>
<h1 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h1><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    //声明函数
    int huzhi(int a,int b);
    int jio(int a,int b);
    int tiaojian(int a,int b);
    int gongshi(int a,int b,int v,int n);
    //设置变量
    int a=2,b=1,v=1,n=0;
    int t=0;//求解标记，成功求解标记为1
    int s=2048;//求解精度，即a,b,v的取值上限
    printf(&quot;请输入需要验证是否为同余数的数字n：&quot;);
    scanf(&quot;%d&quot;,&amp;n);
    //在限定范围内循环枚举尝试求解
    for(a=2;a&lt;=s;a++)
    {
        for(b=1;b&lt;a;b++)
        {
            for(v=1;v&lt;=s;v++)
            {
                //判断是否满足四个条件
                if(huzhi(a,b)&amp;&amp;jio(a,b)&amp;&amp;tiaojian(a,b)&amp;&amp;gongshi(a,b,v,n))
                {
                    printf(&quot;n=%d是同余数\n&quot;,n);
                    printf(&quot;公式中a=%d,b=%d,v=%d\n&quot;,a,b,v);
                    t=1;
                    break;
                }
            }
            //若已求解成功则跳出循环
            if(t==1)
            {
                break;
            }
        }
        //若已求解成功则跳出循环
        if(t==1)
        {
            break;
        }
    }
    //若在精度内未找到解则提示
    if(t==0)
    {
        printf(&quot;n=%d在该精度内不是同余数&quot;,n);
    }
    return 0;
}

//条件一：a,b互质
//若互质返回1,不互质返回0
int huzhi(int a,int b){
    int t;
    if(a&lt;b)
    {
        t=a;a=b;b=t;
    }
    while(a%b)
    {
        t=b;
        b=a%b;
        a=t;
    }
    if(b==1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//条件二：a,b一奇数一偶数
//满足条件返回1，不满足条件返回0
int jio(int a,int b){
    if((a%2==0&amp;&amp;b%2!=0)||(a%2!=0&amp;&amp;b%2==0))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//条件三：a,b正整数并且a&gt;b
//满足条件返回1，不满足条件返回0
int tiaojian(int a,int b){
    if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;a&gt;b)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//条件四：满足判断公式
//满足公式返回1，不满足公式返回0
int gongshi(int a,int b,int v,int n){
    int left=n*v*v,right1=4*a*b*(a*a-b*b),right2=6*a*a*b*b-a*a*a*a-b*b*b*b,right3=-6*a*a*b*b+a*a*a*a+b*b*b*b;
    if(left==right1||left==right2||left==right3)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
</code></pre>
<h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><h2 id="关于精度问题的说明"><a href="#关于精度问题的说明" class="headerlink" title="关于精度问题的说明"></a>关于精度问题的说明</h2><p>因C语言int型变量的取值范围为：-2147483648 ~ 2147483647，而对于数学研究来说，这个范围是远远不够的，所以在程序中有可能会出现超出int精度问题，而导致某些数值判断不正确。比如：1</p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/9.png" alt="精度说明1"></p>
<p>在验证1是否为同余数的过程中，程序找到了a=129,b=64,v=68624这样一组数字，通过调试，可以发现由于这组数字超出了int型的取值范围，导致了错误。公式左边正确数值应为left=$nv^2$=$68624^2$=4709253376，而程序在运行过程中left的错误数值为414286080。所以应<strong>合理调节精度</strong>：精度过高会导致超出int型取值，从而导致某些数值被错误地判定成<strong>是</strong>同余数；精度过低会导致a,b,v取值范围不够，从而导致某些数值被错误的判定成<strong>不是</strong>同余数。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/31-Determine-if-a-number-is-congruent-C-language/10.png" alt="精度说明2"></p>
<p>有一种超精度四则运算算法可以利用字符串模拟人类四则运算法则，该算法可以避免精度问题，有兴趣的可以自行研究。</p>
<h2 id="关于效率问题的说明"><a href="#关于效率问题的说明" class="headerlink" title="关于效率问题的说明"></a>关于效率问题的说明</h2><p>本算法时间复杂度O($n^3$)，算法效率较低，当精度取$10^4$时，预计时间达分钟级</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>参考资料：<a href="https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E6%95%B0" target="_blank" rel="noopener">同余数-百度百科</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/03/06/31-Determine-if-a-number-is-congruent-C-language">https://zam9036.gitee.io/2020/03/06/31-Determine-if-a-number-is-congruent-C-language</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法与分治策略-算法设计与分析知识汇总（二）|Zam9036博客</title>
    <url>/2020/03/05/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p><strong>递归算法</strong></p>
<p>直接或间接地调用自身的算法称为<strong>递归算法</strong>。</p>
<p><strong>递归函数</strong></p>
<p>用函数自身给出定义的函数称为<strong>递归函数</strong>。</p>
<p>在计算机算法设计与分析中，使用递归技术往往使函数的定义和算法的描述简洁且易于理解。<strong>使用递归算法，要考虑递归的效率问题!</strong></p>
<blockquote>
<p>若递归过程中，问题规模减小的速度很慢，则递归算法的复杂度会比较高。</p>
</blockquote>
<h2 id="使用递归的准则"><a href="#使用递归的准则" class="headerlink" title="使用递归的准则"></a>使用递归的准则</h2><p>如果待解决的问题具备下列2个特性，就可以考虑使用递归：</p>
<ul>
<li>复杂的问题转换为简单的1个或几个子问题</li>
<li>最简单的问题可以直接解决 </li>
</ul>
<h2 id="经典递归问题"><a href="#经典递归问题" class="headerlink" title="经典递归问题"></a>经典递归问题</h2><h3 id="阶乘函数"><a href="#阶乘函数" class="headerlink" title="阶乘函数"></a>阶乘函数</h3><p>可递归地定义为：<br>$$<br>n !=\left{\begin{array}{cc}<br>1 &amp; n=0 \<br>n(n-1) ! &amp; n&gt;0<br>\end{array}\right.<br>$$</p>
<blockquote>
<p>定义域n=0一行 称为边界条件<br>定义域$n&gt;0$一行 称为递归方程</p>
</blockquote>
<p>边界条件与递归方程是递归函数的2个要素，递归函数只有具备了这2个要素，才能在有限次计算后得出结果。</p>
<pre><code class="c">int factorial(int n)
{
    if (n==0) return 1;
    return  n*factorial(n-1); 
}</code></pre>
<h3 id="斐波那契-Fibonacci-序列"><a href="#斐波那契-Fibonacci-序列" class="headerlink" title="斐波那契(Fibonacci)序列"></a>斐波那契(Fibonacci)序列</h3><p>斐波那契(Fibonacci)序列：<br>$$<br>\begin{aligned}<br>&amp;\mathrm{F}<em>{0}=\mathrm{F}</em>{1}=1\<br>&amp;\mathrm{F}<em>{\mathrm{i}}=\mathrm{F}</em>{\mathrm{i}-1}+\mathrm{F}_{\mathrm{i}-2} \quad(\mathrm{i}&gt;1)<br>\end{aligned}<br>$$</p>
<blockquote>
<p>第一行为边界条件<br>第二行为递归方程</p>
</blockquote>
<p>求斐波那契数</p>
<pre><code class="c">int fibonacci(int n)
{
    if (n &lt;= 1) return 1;
    return fibonacci(n-1)+fibonacci(n-2);
}</code></pre>
<h3 id="Ackerman函数"><a href="#Ackerman函数" class="headerlink" title="Ackerman函数"></a>Ackerman函数</h3><p>双递归函数：函数及它的一个变量是由函数自身定义。</p>
<p>Ackerman函数A(n，m)定义如下：<br>$$<br>\left{\begin{array}{cc}<br>A(1,0)=2 \<br>A(0, m)=1 &amp; m \geq 0 \<br>A(n, 0)=n+2 &amp; n \geq 2 \<br>A(n, m)=A(A(n-1, m), m-1) &amp; n, m \geq 1<br>\end{array}\right.<br>$$</p>
<pre><code class="c">int Ackerman(int n,int m)
{
    if(n==1 &amp;&amp; m==0)
        return 2;
    else if(n==0)
        return 1;
    else if(m==0)
        return n+2;
    else
        return Ackerman(Ackerman(n-1,m),m-1);
}</code></pre>
<h3 id="Hanoi塔问题"><a href="#Hanoi塔问题" class="headerlink" title="Hanoi塔问题"></a>Hanoi塔问题</h3><ul>
<li>A,B,C是3个塔座。</li>
<li>塔座A上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠在一起。</li>
<li>各圆盘从小到大编号为1,2,…,n。</li>
<li>要求：将塔座A上的这一叠圆盘移到塔座C上，并仍按同样顺序叠置。</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2/1.png" alt="汉诺塔问题1"></p>
<p>在移动圆盘时应遵守以下移动规则：</p>
<ul>
<li>规则1：每次只能移动1个圆盘</li>
<li>规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上</li>
<li>规则3：在满足移动规则1和2的前提下，可将圆盘移至A,B,C中任一塔座上</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2/2.png" alt="汉诺塔问题2"></p>
<pre><code class="c">void hanoi(int n, int a, int b, int c)
{
   if (n &gt;=1)
   {
      hanoi(n-1, a, c, b);
      move(a,c);
      hanoi(n-1, b, a, c);
   }
}</code></pre>
<blockquote>
<p>当n=1时，问题比较简单。此时，只要将编号为1的圆盘从塔座a直接移至塔座c上即可。</p>
<p>当n＞1时，需要利用塔座b作为辅助塔座。此时若能设法将n-1个较小的圆盘依照移动规则从塔座a移至塔座b，然后，将剩下的最大圆盘从塔座a移至塔座c，最后，再设法将n-1个较小的圆盘依照移动规则从塔座b移至塔座c。</p>
<p>由此可见，n个圆盘的移动问题可分为2次n-1个圆盘的移动问题，这又可以递归地用上述方法来做。</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2/3.png" alt="汉诺塔问题3"></p>
<h2 id="经典递归问题的非递归定义"><a href="#经典递归问题的非递归定义" class="headerlink" title="经典递归问题的非递归定义"></a>经典递归问题的非递归定义</h2><h3 id="阶乘函数的非递归定义"><a href="#阶乘函数的非递归定义" class="headerlink" title="阶乘函数的非递归定义"></a>阶乘函数的非递归定义</h3><p>$$<br>n !=1 \cdot 2 \cdot 3 \cdots \cdots(n-1) \cdot n<br>$$</p>
<h3 id="斐波那契-Fibonacci-序列的非递归定义"><a href="#斐波那契-Fibonacci-序列的非递归定义" class="headerlink" title="斐波那契(Fibonacci)序列的非递归定义"></a>斐波那契(Fibonacci)序列的非递归定义</h3><p>$$<br>F(n)=\frac{1}{\sqrt{5}}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{n+1}-\left(\frac{1-\sqrt{5}}{2}\right)^{n+1}\right)<br>$$</p>
<h3 id="Ackerman函数无非递归定义"><a href="#Ackerman函数无非递归定义" class="headerlink" title="Ackerman函数无非递归定义"></a>Ackerman函数无非递归定义</h3><blockquote>
<p>Ackerman函数的增长速度非常快，其增长速度比n！快的多。而Ackerman函数的逆函数，增长速度比logn慢的多。</p>
</blockquote>
<h2 id="递归优劣"><a href="#递归优劣" class="headerlink" title="递归优劣"></a>递归优劣</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>结构清晰，可读性强</li>
<li>容易用数学归纳法来证明算法的正确性</li>
<li>为设计算法、调试程序带来很大方便</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多</li>
</ul>
<h3 id="缺点解决方法"><a href="#缺点解决方法" class="headerlink" title="缺点解决方法"></a>缺点解决方法</h3><p>总体思想：消除递归调用，将递归算法转化为非递归算法。</p>
<ul>
<li>采用一个用户定义的栈来模拟系统的递归调用工作栈。</li>
</ul>
<blockquote>
<p>优点：通用性强<br>不足：本质上还是递归，优化效果不明显</p>
</blockquote>
<ul>
<li>通过变换将一些递归进行转化，从而迭代求出结果。例如，用递推来模拟实现递归函数。(循环）</li>
</ul>
<blockquote>
<p>在时空复杂度上均有较大改善，但其适用范围有限。</p>
</blockquote>
<h1 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>基本思想：将一个难以直接解决的<strong>大问题</strong>，<strong>分解</strong>成一些<strong>规模较小的相同问题</strong>，以便<strong>各个击破</strong>，分而治之。</p>
<p>分治法可以被反复应用直到问题的规模缩小到一定程度，可以容易的求解。</p>
<p>在反复使用分治法的过程中，经常会用到递归算法。</p>
<h2 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h2><p>对这k个子问题分别求解。如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2/4.png" alt="分治策略总体思想1"></p>
<p>将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2/5.png" alt="分治策略总体思想2"></p>
<p>分治法的设计思想是，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<h2 id="适用特征"><a href="#适用特征" class="headerlink" title="适用特征"></a>适用特征</h2><p>分治法所能解决的问题一般具有以下几个特征：</p>
<ul>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题</li>
<li>用该问题分解出的子问题的解可以合并为该问题的解</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题</li>
</ul>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>实践证明，在用分治法设计算法时，最好使子问题的规模大致相同，即将一个问题分成大小相等的k个子问题。这种使子问题规模大致相等的做法是出自<strong>平衡子问题的思想</strong>，它几乎总是比子问题规模不等的做法要好。</p>
<pre><code class="c">divide-and-conquer(P)
{
    if ( | P | &lt;= n0) solve(P);   //解决小规模的问题
    divide P into smaller subinstances P1,P2,...,Pk；//分解问题
    for (i=1;i&lt;=k;i++)
    yi=divide-and-conquer(Pi);  //递归的解各子问题
    return merge(y1,...,yk);  //将各子问题的解合并为原问题的解
}</code></pre>
<h2 id="复杂性分析"><a href="#复杂性分析" class="headerlink" title="复杂性分析"></a>复杂性分析</h2><p>分治法将规模为n的问题分成k个规模为n/m的子问题。设分解阀值$n_0$=1，且解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则：<br>$$<br>T(n)=\left{\begin{array}{cl}<br>O(1) &amp; n=1 \<br>k T(n / m)+f(n) &amp; n&gt;1<br>\end{array}\right.<br>$$<br>通过迭代法求得方程的解：<br>$$<br>T(n)=n^{\log <em>{m} k}+\sum</em>{j=0}^{\log _{m} n-1} k^{j} f\left(n / m^{j}\right)<br>$$</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/03/05/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2">https://zam9036.gitee.io/2020/03/05/30-Algorithm-Design-and-Analysis-Knowledge-Summary-2</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>课程：算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库SQL Server的安装与使用|Zam9036博客</title>
    <url>/2020/03/03/29-Installation-and-use-of-SQL-Server/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="版本平台"><a href="#版本平台" class="headerlink" title="版本平台"></a>版本平台</h1><p>Windows</p>
<p>SQL Server 2019 Developer</p>
<p>SQL Server Management Studio 18.4</p>
<h1 id="SQL-Server介绍"><a href="#SQL-Server介绍" class="headerlink" title="SQL Server介绍"></a>SQL Server介绍</h1><p>SQL是英文Structured Query Language的缩写，意思为结构化查询语言。SQL语言的主要功能就是同各种数据库建立联系，进行沟通。按照ANSI(美国国家标准协会)的规定，SQL被作为关系型数据库管理系统的标准语言。SQL Server是由Microsoft开发和推广的关系数据库管理系统（RDBMS）。</p>
<h1 id="SQL-Server安装"><a href="#SQL-Server安装" class="headerlink" title="SQL Server安装"></a>SQL Server安装</h1><h2 id="下载SQL-Server"><a href="#下载SQL-Server" class="headerlink" title="下载SQL Server"></a>下载SQL Server</h2><p>访问<a href="https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads" target="_blank" rel="noopener">SQL Server官网</a>，下载SQL Server，我选择下载的是SQL Server 2019 Developer。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/1.png" alt="SQL Server官网"></p>
<h2 id="启动安装"><a href="#启动安装" class="headerlink" title="启动安装"></a>启动安装</h2><p>下载完成后，运行安装程序，选择“基本安装”</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/2.png" alt="基本安装"></p>
<p>同意服务条款后，指定SQL Server的安装位置</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/3.png" alt="安装位置"></p>
<p>然后程序会自动下载安装程序包，并自动安装</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/4.png" alt="下载安装包"></p>
<p>在安装的时候，部分程序操作可能会被安全软件拦截，请及时赋予安装程序必要的权限</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/5.png" alt="操作拦截"></p>
<p>安装完成</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/6.png" alt="安装完成"></p>
<h1 id="安装SQL-Server-Management-Studio"><a href="#安装SQL-Server-Management-Studio" class="headerlink" title="安装SQL Server Management Studio"></a>安装SQL Server Management Studio</h1><h2 id="下载SSMS"><a href="#下载SSMS" class="headerlink" title="下载SSMS"></a>下载SSMS</h2><p>可以访问<a href="https://docs.microsoft.com/zh-cn/sql/ssms/download-sql-server-management-studio-ssms?redirectedfrom=MSDN&view=sql-server-ver15" target="_blank" rel="noopener">SSMS官网</a>下载SMSS，也可以点击SQL Server完成安装时的安装SSMS按钮下载安装。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/7.png" alt="SSMS官网"></p>
<h2 id="启动安装-1"><a href="#启动安装-1" class="headerlink" title="启动安装"></a>启动安装</h2><p>下载完成后，运行安装软件，启动安装，并选择安装位置</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/8.png" alt="SSMS安装位置"></p>
<p>开始安装</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/9.png" alt="SSMS安装"></p>
<p>安装完毕</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/10.png" alt="SSMS安装位置"></p>
<h1 id="使用SQL-Server"><a href="#使用SQL-Server" class="headerlink" title="使用SQL Server"></a>使用SQL Server</h1><p>SQL Server是数据库本体，SSMS是SQL Server的数据库管理系统</p>
<p>启动SSMS，连接数据库，开始使用数据库吧！</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/11.png" alt="SSMS连接数据库"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/03/03/29-Installation-and-use-of-SQL-Server">https://zam9036.gitee.io/2020/03/03/29-Installation-and-use-of-SQL-Server</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL Server</tag>
        <tag>课程：数据库原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>算法概述-算法设计与分析知识汇总（一）|Zam9036博客</title>
    <url>/2020/02/27/28-Algorithm-design-and-analysis-study-notes-1/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h1><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><ul>
<li>算法是解决问题的一种方法或一个过程。</li>
<li>算法是若干指令的有穷序列。</li>
<li>算法是以一步接一步的方式来详细描述计算机如何将输入转化为所要求的输出的过程。</li>
<li>算法是对计算机上执行的计算过程的具体描述。</li>
</ul>
<h2 id="算法的性质"><a href="#算法的性质" class="headerlink" title="算法的性质"></a>算法的性质</h2><ul>
<li><strong>输入</strong>：算法的输入由零个和多个外部量提供。</li>
<li><strong>输出</strong>：算法产生至少一个量作为输出。</li>
<li><strong>确定性</strong>：组成算法的每条指令清晰、无歧义。</li>
<li><strong>有限性</strong>：算法中<strong>每条指令</strong>的执行次数和执行时间都是有限的。</li>
</ul>
<h2 id="程序概述"><a href="#程序概述" class="headerlink" title="程序概述"></a>程序概述</h2><p>程序是算法用某种程序设计语言的具体实现。</p>
<blockquote>
<p>注意：程序可以不满足算法的第4条性质“有限性”，即程序可以是无限循环的。</p>
<p>例如操作系统就是一个在无限循环中执行的程序。</p>
</blockquote>
<h2 id="研究算法的必要性"><a href="#研究算法的必要性" class="headerlink" title="研究算法的必要性"></a>研究算法的必要性</h2><p>高效的算法可以节省时间和存储空间</p>
<h1 id="算法复杂性分析"><a href="#算法复杂性分析" class="headerlink" title="算法复杂性分析"></a>算法复杂性分析</h1><h2 id="算法分析概述"><a href="#算法分析概述" class="headerlink" title="算法分析概述"></a>算法分析概述</h2><p>算法分析是研究算法对计算机资源进行使用的理论，是对算法运行所需要的计算机资源的量的预测。</p>
<h2 id="算法复杂性"><a href="#算法复杂性" class="headerlink" title="算法复杂性"></a>算法复杂性</h2><p>算法复杂性即算法运行所需要的计算机资源的量。</p>
<ul>
<li>需要时间资源的量称为<strong>时间复杂性T(n)</strong>。</li>
<li>需要空间资源的量称为<strong>空间复杂性S(n)</strong>。</li>
<li>n为问题的规模，即输入的大小。</li>
</ul>
<h2 id="研究算法的复杂性-性能、效率-的必要性"><a href="#研究算法的复杂性-性能、效率-的必要性" class="headerlink" title="研究算法的复杂性(性能、效率)的必要性"></a>研究算法的复杂性(性能、效率)的必要性</h2><ul>
<li>性能有时决定系统是否可行。</li>
</ul>
<blockquote>
<p>实时系统中若性能低下，则导致系统不可行。</p>
</blockquote>
<ul>
<li>性能是许多重要特性的基础。</li>
</ul>
<blockquote>
<p>如：用户体验。</p>
</blockquote>
<h2 id="算法分析的基本问题"><a href="#算法分析的基本问题" class="headerlink" title="算法分析的基本问题"></a>算法分析的基本问题</h2><ul>
<li><p>怎样评价一个问题的难易程度？</p>
</li>
<li><p>怎样评价一个算法的好与坏？</p>
</li>
<li><p>对于一个问题怎样知道哪个算法是最优的？</p>
</li>
</ul>
<blockquote>
<p>即解同样的问题是否存在其他更好的算法</p>
</blockquote>
<h2 id="算法执行时间相关的因素"><a href="#算法执行时间相关的因素" class="headerlink" title="算法执行时间相关的因素"></a>算法执行时间相关的因素</h2><ul>
<li>问题的规模(N)</li>
</ul>
<blockquote>
<p>排序问题中，需要排序的数：10 vs.  $10^6$</p>
</blockquote>
<ul>
<li>算法的输入(I)</li>
</ul>
<blockquote>
<p>排序问题中，输入已排序、逆序的情况</p>
</blockquote>
<ul>
<li>算法选用的策略(A)</li>
</ul>
<p>T(N,I,A)，算法执行时间和问题的规模、算法的输入、算法选用的策略有关</p>
<h2 id="算法的时间复杂性"><a href="#算法的时间复杂性" class="headerlink" title="算法的时间复杂性"></a>算法的时间复杂性</h2><h3 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h3><p>Tmin (n): 输入规模为n时，程序运行可能消耗的最短时间</p>
<blockquote>
<p>具有欺骗性，可能只对某些特定输入起作用</p>
</blockquote>
<h3 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>Tmax (n): 输入规模为n时，程序运行可能消耗的最长时间</p>
<blockquote>
<p>可视为对用户提供的一种承诺</p>
</blockquote>
<h3 id="平均情况"><a href="#平均情况" class="headerlink" title="平均情况"></a>平均情况</h3><p>Tavg(n): 输入规模为n时，所有可能输入的期望时间</p>
<p>期望时间：$\sum$每种可能出现的输入消耗的时间*出现的概率</p>
<p>以上三种情况衡量算法的时间复杂性<strong>可操作性最好，具有实际价值</strong>。</p>
<h3 id="算法的渐进复杂性"><a href="#算法的渐进复杂性" class="headerlink" title="算法的渐进复杂性"></a>算法的渐进复杂性</h3><p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/1.png" alt="算法渐进复杂性1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/2.png" alt="算法渐进复杂性2"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/3.png" alt="算法渐进复杂性3"></p>
<blockquote>
<p>渐进复杂性：复杂性中的最高阶项</p>
<p>对算法的分析主要是考虑算法的渐进复杂性</p>
</blockquote>
<h1 id="NP完全性理论"><a href="#NP完全性理论" class="headerlink" title="NP完全性理论"></a>NP完全性理论</h1><h2 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h2><p>在进行问题的计算复杂性分析之前，首先必须建立求解问题所用的计算模型，包括定义该计算模型中所用的基本运算。</p>
<p>建立计算模型的目的是为了使问题的计算复杂性分析有一个共同的客观尺度。</p>
<p>2个基本计算模型：</p>
<ul>
<li>随机存取机RAM(Random Access Machine)</li>
<li>图灵机(Turing Machine)</li>
</ul>
<p>这2个计算模型在计算能力上是等价的，但在计算速度上是不同的。</p>
<h3 id="随机存取机RAM"><a href="#随机存取机RAM" class="headerlink" title="随机存取机RAM"></a>随机存取机RAM</h3><p><strong>RAM的结构</strong></p>
<p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/4.png" alt="RAM的结构"></p>
<p><strong>RAM程序</strong></p>
<p>一个RAM程序定义了从输入带到输出带的一个映射。可以对这种映射关系做两种不同的解释。</p>
<ul>
<li>解释一：把RAM程序看成是计算一个函数</li>
</ul>
<p>若一个RAM程序P总是从输入带前n个方格中读入n个整数x1，x2，…，xn，并且在输出带的第一个方格上输出一个整数y后停机，那么就说程序P计算了函数f(x1，x2，…，xn)=y。</p>
<ul>
<li>解释二：把RAM程序当作一个语言接受器</li>
</ul>
<p>将字符串S=a1a2…an放在输入带上。在输入带的第一个方格中放入符号a1，第二个方格中放入符号a2，…，第n个方格中放入符号an。然后在第n+1个方格中放入0，作为输入串的结束标志符。如果一个RAM程序P读了字符串S及结束标志符0后，在输出带的第一格输出一个1并停机，就说程序P接受字符串S。</p>
<h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/5.png" alt="图灵机"></p>
<p>根据有限状态控制器的当前状态及每个读写头读到的带符号，图灵机的一个计算步可实现下面3个操作之一或全部：</p>
<ul>
<li><p>改变有限状态控制器中的状态</p>
</li>
<li><p>清除当前读写头下的方格中原有带符号并写上新的带符号</p>
</li>
<li><p>独立地将任何一个或所有读写头，向左移动一个方格(L)或向右移动一个方格(R)或停在当前单元不动(S)</p>
</li>
</ul>
<p>k带图灵机可形式化地描述为一个7元组(Q，T，I，$\delta$，b，$q_0$，$q_f$)，其中:</p>
<ul>
<li><p>Q是有限个状态的集合。  </p>
</li>
<li><p>T是有限个带符号的集合。</p>
</li>
<li><p>I是输入符号的集合，I$\subseteq$T。</p>
</li>
<li><p>b是唯一的空白符，b$\in$T-I。</p>
</li>
<li><p>$q_0$是初始状态。   </p>
</li>
<li><p>$q_f$是终止(或接受)状态。</p>
</li>
<li><p>$\delta$是移动函数。它是从Q$\times$$T^k$的某一子集映射到 Q$\times$(T$\times${L，R，S})$^k$的函数。</p>
</li>
</ul>
<p>与RAM模型类似，图灵机既可作为语言接受器，也可作为计算函数的装置。</p>
<p>图灵机M的时间复杂性T(n)是它处理所有长度为n的输入所需的最大计算步数。如果对某个长度为n的输入，图灵机不停机，T(n)对这个n值无定义。</p>
<p>图灵机的空间复杂性S(n)是它处理所有长度为n的输入时，在k条带上所使用过的方格数的总和。如果某个读写头无限地向右移动而不停机，S(n)也无定义。 </p>
<h2 id="P类与NP类问题"><a href="#P类与NP类问题" class="headerlink" title="P类与NP类问题"></a>P类与NP类问题</h2><p>一般地说，将可由多项式时间算法求解的问题看作是<strong>易处理</strong>的问题(例如排序)，而将需要超多项式时间才能求解的问题看作是<strong>难处理</strong>的问题（例如汉密尔顿回路判定问题和旅行售货商最短路径求解问题）。</p>
<p>有许多问题，从表面上看似乎并不比排序或图的搜索等问题更困难，然而至今人们还没有找到解决这些问题的多项式时间算法，也没有人能够证明这些问题需要超多项式时间下界。</p>
<p>在图灵机计算模型下，这类问题的计算复杂性至今未知。</p>
<p>为了研究这类问题的计算复杂性，人们提出了另一个能力更强的计算模型，即<strong>非确定性图灵机计算模型，简记为NDTM(Nondeterministic Turing Machine)。</strong></p>
<p>在非确定性图灵机计算模型下，许多问题可以在多项式时间内求解。</p>
<h3 id="非确定性图灵机"><a href="#非确定性图灵机" class="headerlink" title="非确定性图灵机"></a>非确定性图灵机</h3><p>在图灵机计算模型中，移动函数$\delta$是确定性的值，即对于Q$\times$$T^k$中的每一个值，当它属于$\delta$的定义域时，Q$\times$(T$\times${L，R，S})$^k$中只有唯一的值与之对应，称这种图灵机为<strong>确定性图灵机，简记为DTM(Deterministic Turing Machine)。</strong></p>
<p>非确定性图灵机（ NDTM ）：一个k带的非确定性图灵机M是一个7元组：(Q，T，I，$\delta$，b，$q_0$，$q_f$)。与确定性图灵机不同的是<strong>非确定性图灵机允许移动函数$\delta$具有不确定性值。</strong></p>
<p>确定性和非确定性图灵机的区别在于：确定性图灵机的每一步只有一种选择，而非确定性图灵机可以有多种选择。因此，非确定性图灵机的计算能力比确定性图灵机强的多。</p>
<h3 id="P与NP"><a href="#P与NP" class="headerlink" title="P与NP"></a>P与NP</h3><p>P代表Polynomial，意为在<strong>(确定性)多项式时间内可解的问题。</strong></p>
<p>NP里面的N，不是Non-Polynomial的N，是Non-Deterministic ，意为是非确定的。</p>
<p>NP就是Non-deterministic Polynomial-time的问题，也即是<strong>非确定性多项式时间内可解的问题。</strong></p>
<h3 id="P类与NP类语言"><a href="#P类与NP类语言" class="headerlink" title="P类与NP类语言"></a>P类与NP类语言</h3><p>P类和NP类语言的定义：</p>
<p>P={L|L是一个能在多项式时间内被一台DTM所接受的语言} </p>
<p>NP={L|L是一个能在多项式时间内被一台NDTM所接受的语言}</p>
<p>由于一台确定性图灵机可看作是非确定性图灵机的特例，所以可在多项式时间内被确定性图灵机接受的语言也可在多项式时间内被非确定性图灵机接受。故P$\subseteq$NP。 </p>
<h3 id="P、NP与NPC问题"><a href="#P、NP与NPC问题" class="headerlink" title="P、NP与NPC问题"></a>P、NP与NPC问题</h3><p><strong>P问题</strong>：可以在多项式时间内<strong>解决</strong>的问题。例如：排序。</p>
<p><strong>NP问题</strong>：可以在多项式的时间里<strong>验证</strong>一个解的问题。分两步验证: (1) 非确定性的给出一个猜测解；（2）在多项式时间内验证。例如：验证旅行售货商问题中受否存在一个总长度不超过一个上限的路径。</p>
<p><strong>NPC(NP Complete)问题</strong>: 是NP的一个子集，且其中每一个问题均能由NP中的任何问题在多项式时间内转化而成。</p>
<h2 id="NP完全-NPC-问题"><a href="#NP完全-NPC-问题" class="headerlink" title="NP完全(NPC)问题"></a>NP完全(NPC)问题</h2><p>P$\subseteq$P</p>
<p>直观上看，P类问题是确定性计算模型下的<strong>易解问题类</strong>，而NP类问题是非确定性计算模型下的<strong>易验证问题类</strong>。</p>
<p>解决问题(最短路径)往往比验证问题（验证是否存在一条小于上限的路径）难得多。大多数计算机科学家认为：NP类问题中包含了不属于P类的语言，即P≠NP。</p>
<p>数学上著名的NP问题，完整的叫法是NP完全问题，简单的写法是 <strong>NP=P？</strong>的问题。</p>
<p><strong>NP完全问题</strong>的性质:如果一个NP完全问题能在多项式时间内得到解决，那么NP中的每一个问题都可以在多项式时间内求解，即P=NP。</p>
<p>目前还没有一个NPC问题有多项式时间算法。</p>
<h3 id="NP完全问题的例子"><a href="#NP完全问题的例子" class="headerlink" title="NP完全问题的例子"></a>NP完全问题的例子</h3><ul>
<li>哈密尔顿回路问题(所有路径顺次经历一圈)</li>
<li>旅行售货员问题(所有城市顺次经历一圈，圈最小) </li>
</ul>
<h3 id="NP完全问题的近似算法"><a href="#NP完全问题的近似算法" class="headerlink" title="NP完全问题的近似算法"></a>NP完全问题的近似算法</h3><p>迄今为止，所有的NP完全问题都还没有多项式时间算法。对于这类问题，通常可采取以下几种解题策略：</p>
<ul>
<li>只对问题的特殊实例求解</li>
<li>用动态规划法或分支限界法求解 </li>
<li>用概率算法求解 </li>
<li>只求近似解</li>
<li>用启发式方法求解 </li>
</ul>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/02/27/28-Algorithm-design-and-analysis-study-notes-1">https://zam9036.gitee.io/2020/02/27/28-Algorithm-design-and-analysis-study-notes-1</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>课程：算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统在Windows虚拟机上的安装|Zam9036博客</title>
    <url>/2020/02/25/27-Linux-system-installation-on-Windows-virtual-machine/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="平台与工具"><a href="#平台与工具" class="headerlink" title="平台与工具"></a>平台与工具</h1><p>Windows 10</p>
<p>Oracle VM VirtualBox 6.1 虚拟机</p>
<p>Ubuntukylin 19.10 Linux系统镜像文件</p>
<h1 id="虚拟机安装与使用"><a href="#虚拟机安装与使用" class="headerlink" title="虚拟机安装与使用"></a>虚拟机安装与使用</h1><h2 id="下载安装VirtualBox"><a href="#下载安装VirtualBox" class="headerlink" title="下载安装VirtualBox"></a>下载安装VirtualBox</h2><p>访问<a href="https://www.virtualbox.org/" target="_blank" rel="noopener">Oracle VM VirtualBox官方网站</a>，下载VM VirtualBox，我使用的版本是6.1。浏览英文网页如有困难，可以尝试使用Google/有道的网页翻译功能。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/1.png" alt="下载Oracle VM VirtualBox"></p>
<p>下载完成后，按照提示安装即可，在此不过多赘述。</p>
<blockquote>
<p>注意：安装Oracle VM VirtualBox的时候会重置网络连接状态，并且可能会要求重启电脑。</p>
</blockquote>
<h2 id="VirtualBox的使用"><a href="#VirtualBox的使用" class="headerlink" title="VirtualBox的使用"></a>VirtualBox的使用</h2><p>安装完成后启动Oracle VM VirtualBox虚拟机控制台，如下图所示。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/2.png" alt="VirtualBox控制台1"></p>
<blockquote>
<p>左侧列表是已经安装过的虚拟机</p>
<p>如图，我已经安装了Windows 95、MS-DOS 6.22、MS_DOS 3.30、Ubuntu-18.04</p>
</blockquote>
<p>点击对应的虚拟机，可以看到相应的虚拟机状态和所设置的参数。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/3.png" alt="VirtualBox控制台2"></p>
<h1 id="Linux系统在虚拟机上的安装"><a href="#Linux系统在虚拟机上的安装" class="headerlink" title="Linux系统在虚拟机上的安装"></a>Linux系统在虚拟机上的安装</h1><h2 id="下载Linux系统"><a href="#下载Linux系统" class="headerlink" title="下载Linux系统"></a>下载Linux系统</h2><p>我以 Ubuntukylin 19.10作为例子演示，其他系统类似。从<a href="https://www.ubuntukylin.com/" target="_blank" rel="noopener">Ubuntukylin官网</a>上下载Linux系统的ISO镜像文件，储存备用。</p>
<h2 id="配置虚拟电脑"><a href="#配置虚拟电脑" class="headerlink" title="配置虚拟电脑"></a>配置虚拟电脑</h2><p>打开Oracle VM VirtualBox控制器，点击<code>工具-新建</code>（快捷键Ctrl+N），输入系统名称（系统安装完成后会在左侧列表显示）、Linux系统文件的安装路径（类似于Windows的C盘）、选择系统类型和版本。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/4.png" alt="准备配置虚拟电脑"></p>
<p>选择分配给该虚拟电脑的运行内存大小。</p>
<blockquote>
<p>运行内存分配后不会立即占用，只有启动该系统的时候才会占用。</p>
<p>分配给虚拟电脑的内存建议2G+，4G-6G为最佳，请根据电脑配置自行决策（我电脑16G运行内存，分配给虚拟电脑6G）</p>
<p>运行内存分配不合理可能导致Windows系统崩溃</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/5.png" alt="分配内存大小"></p>
<p>选择是否创建虚拟硬盘（即该虚拟电脑的存储硬盘），若之前没有添加过虚拟电脑，建议添加一个虚拟硬盘；若之前添加过虚拟电脑，可以使用之前创建的虚拟硬盘。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/6.png" alt="创建虚拟硬盘"></p>
<p>选择新建虚拟磁盘的文件类型，一般默认即可。</p>
<blockquote>
<p>选用VHD或VMDK可以让其他的虚拟化软件访问新建的虚拟硬盘（但一般不需要）</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/7.png" alt="选择虚拟硬盘文件类型"></p>
<p>选择虚拟硬盘的分配方式，建议使用动态分配。</p>
<blockquote>
<p>动态分配：虚拟磁盘逐步占用物理磁盘空间（至分配的数值为止）【需要多少 使用多少】</p>
<p>固定分配：一次性占用相应的物理磁盘空间【全部占用，不需要的也先占上】</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/8.png" alt="选择虚拟硬盘分配方式"></p>
<p>选择分配给虚拟磁盘的空间大小，建议10G+</p>
<blockquote>
<p>请根据所装系统和电脑配置自行决策</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/9.png" alt="分配虚拟硬盘空间大小"></p>
<h2 id="选择启动盘"><a href="#选择启动盘" class="headerlink" title="选择启动盘"></a>选择启动盘</h2><p>配置完虚拟电脑，我们就拥有一台属于自己的崭新“计算机”（我的是6G+20G喔），那么下一步，就是安装操作系统。这个时候我们刚刚下载完成的ISO文件就起到用途了。</p>
<p>左侧列表点击我们刚刚配置好的虚拟电脑，可以看到相应的配置。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/10.png" alt="查看虚拟电脑配置"></p>
<p>点击右上方的启动按钮（快捷键Ctrl+T），尝试启动“计算机”，这个时候会提示选择启动盘</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/11.png" alt="选择启动盘1"></p>
<p>点击右方的浏览启动盘图标，弹出以下窗口，这个窗口就是启动盘选择窗口，可以看到都是后缀为.iso的文件。我们发现并没有刚刚下载的iso文件，那是因为刚刚那张“光盘”的数据并没有在虚拟机上</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/12.png" alt="选择启动盘2"></p>
<p>点击注册按钮，选择刚刚下载ISO文件的路径（模仿真实安装计算机时的操作系统安装盘的插入），这个时候会出现如下进度条，这表示正在准备读取“操作系统安装盘”</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/13.png" alt="注册启动盘"></p>
<p>然后返回刚刚的选择启动盘窗口，选择刚刚下载的ISO文件</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/14.png" alt="选择启动盘3"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/15.png" alt="选择启动盘4"></p>
<p>点击启动，待ISO文件读取完毕后，就会显示Ubuntu的界面，表示可以配置安装系统了</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/16.png" alt="启动成功界面"></p>
<h1 id="Linux系统配置"><a href="#Linux系统配置" class="headerlink" title="Linux系统配置"></a>Linux系统配置</h1><p>在弹出启动成功界面后不久，我们就会看到Ubuntu的安装界面，提示我们选择语言和安装方式（当然是选择中文简体+安装【英语大佬请选择英文】）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/17.png" alt="选择语言和安装方式"></p>
<p>然后选择键盘布局（汉语-汉语）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/18.png" alt="选择键盘布局"></p>
<p>选择更新和其他软件（看心情选吧）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/19.png" alt="选择更新和其他软件"></p>
<p>选择安装类型（因为我们的虚拟电脑是“崭新的”，所以选择清除磁盘并安装即可）</p>
<blockquote>
<p>注意：在选择是否创建虚拟硬盘的时候，如果选择选择否，请重视此选项，并视情况做决定</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/20.png" alt="选择安装类型"></p>
<p>选择地区</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/21.png" alt="选择地区"></p>
<p>设置用户和密码</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/22.png" alt="设置用户和密码"></p>
<p>开始安装！（预计20分钟-30分钟），并且需要根据提示进行重启</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/23.png" alt="提示重启"></p>
<p>安装成功！终于来到了系统桌面！</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/24.png" alt="系统桌面"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/02/25/27-Linux-system-installation-on-Windows-virtual-machine">https://zam9036.gitee.io/2020/02/25/27-Linux-system-installation-on-Windows-virtual-machine</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>操作系统</tag>
        <tag>虚拟机</tag>
        <tag>课程：Linux系统实践</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述-计算机网络知识汇总（一）|Zam9036博客</title>
    <url>/2020/02/24/26-Computer-network-study-notes-1/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="计算机网络的概念与组成"><a href="#计算机网络的概念与组成" class="headerlink" title="计算机网络的概念与组成"></a>计算机网络的概念与组成</h1><h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><p>计算机网络系统是将地理位置不同的<strong>多个计算机系统</strong>，通过<strong>通信设备</strong>和<strong>线路</strong>连接起来，并配以功能完善的<strong>网络软件</strong>(如网络操作系统等)，按照一定的<strong>协议</strong>实现<strong>相互通信和资源共享</strong>的<strong>系统</strong>，称为计算机网络系统。 </p>
<blockquote>
<p>计算机网络的功能：相互通信、资源共享</p>
</blockquote>
<h3 id="计算机网络的应用"><a href="#计算机网络的应用" class="headerlink" title="计算机网络的应用"></a>计算机网络的应用</h3><ul>
<li><p>进行各种规模和不同范围的信息管理：教务管理系统、企业管理系统、办公自动化……</p>
</li>
<li><p>进行信息/文献检索：时事新闻、市场商情、产品需求、图书、期刊、专业型动态数据</p>
</li>
<li><p>电子数据交换：电子政务、电子商务、联网售票、网络直播</p>
</li>
<li><p>实现不同范围的监测、数据传递、信息处理与反馈控制 </p>
</li>
<li><p>提供分布式计算和分布式处理的环境 ：集群机、网格、云</p>
</li>
<li><p>计算机综合(集成)制造系统(CIMS) </p>
</li>
</ul>
<h4 id="计算机网络的重要性"><a href="#计算机网络的重要性" class="headerlink" title="计算机网络的重要性"></a>计算机网络的重要性</h4><ul>
<li><p>国家（经济、军事、科技、公用事业等）的重要基础设施和命脉</p>
</li>
<li><p>战争的首要攻击目标（网络部队、网络司令部）</p>
</li>
<li><p>企业、公众的依赖</p>
</li>
<li><p>公共安全、社会稳定(公安网监）</p>
</li>
</ul>
<h3 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h3><ul>
<li>网络硬件：计算机、通信设备、通信线路</li>
<li>网络软件：网络操作系统</li>
<li>网络协议</li>
</ul>
<blockquote>
<p>网络软件硬件的关系：相辅相成，缺一不可</p>
<p>网络协议：网络中各部分必须遵守的规定，必不可少！</p>
</blockquote>
<h4 id="网络硬件"><a href="#网络硬件" class="headerlink" title="网络硬件"></a>网络硬件</h4><h5 id="客户机（Client）"><a href="#客户机（Client）" class="headerlink" title="客户机（Client）"></a>客户机（Client）</h5><ul>
<li>PC、PDA、智能设备(仪器/仪表-&gt;嵌入式系统)、智能手机</li>
<li>中、大型机、（专业）工作站</li>
</ul>
<h5 id="数据传输介质"><a href="#数据传输介质" class="headerlink" title="数据传输介质"></a>数据传输介质</h5><p>有线介质：通信电缆（双绞线、同轴电缆等）通信光缆</p>
<p>无线介质：空气（电磁波、微波）</p>
<h5 id="网络接口单元（NIU）-、通信控制器、网卡"><a href="#网络接口单元（NIU）-、通信控制器、网卡" class="headerlink" title="网络接口单元（NIU） 、通信控制器、网卡"></a>网络接口单元（NIU） 、通信控制器、网卡</h5><p>功能：通信管理与控制，保证通信对用户的透明性</p>
<h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p>主要作用：提供多个端口，连接多台设备，实现数据转接(交换)</p>
<p>分类：接入 (边缘)交换机、汇聚 (分支)交换机、核心交换机</p>
<p>工作原理：电路交换方式，存储转发交换方式(报文交换、分组交换)</p>
<p>主要厂家：Cisco、Juniper、华为、锐捷、神码、H3C、TP-LINK</p>
<h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><p>作用：为网络用户提供各种资源和服务</p>
<p>资源：网络打印机、存储空间（网盘）、软件、数据……</p>
<p>服务：信息浏览、文件传输、电子邮件、远程登录、视频信息和各种有针对性的信息服务……</p>
<blockquote>
<p>相应的服务器：Web、FTP、E-Mail、Telnet、视频、DNS、DBMS</p>
<p>提供相应的服务，就需要相应的服务器</p>
<p>一台物理服务器（高性能），可以提供多种服务</p>
<p>可通过服务器集群，提供多种服务</p>
</blockquote>
<p>服务器形式：</p>
<ul>
<li>专业生产的高性能服务器：浪潮、HP、SUN、IBM……</li>
</ul>
<blockquote>
<p>技术：对称多处理器、RAID技术、SCSI卡、冗余电源</p>
</blockquote>
<ul>
<li>PC机、大、中、小型机</li>
</ul>
<p>服务器架构</p>
<p>原理分类：复杂指令集(CISC) 、精简指令集(RISC)、并行指令集(VLIW)</p>
<p>架构分类：【复杂指令集(CISC)】Intel架构(入门、工作组）、【精简指令集(RISC)】UNIX架构（企业级）</p>
<h5 id="网络互联设备"><a href="#网络互联设备" class="headerlink" title="网络互联设备"></a>网络互联设备</h5><p><strong>路由器（Router）</strong></p>
<p>作用：连接多个网络或网段，从而形成网络的网络——<strong>因特网</strong></p>
<p>主要厂家：Cisco、华为、锐捷……</p>
<p><strong>集线器</strong>：实现设备共享接入</p>
<p><strong>无线接入点（AP）</strong>：无线设备共享接入</p>
<p><strong>网桥</strong>：将局域网分隔成多个网段，减少冲突范围</p>
<p><strong>防火墙、入侵检测/防御、UTM</strong>：保护网络安全</p>
<blockquote>
<p>防火墙：防止外部网络访问内网（需要VPN才能访问）</p>
</blockquote>
<p><strong>光电耦合器(Net-Bridge)</strong>：光信号-电信号转换</p>
<h4 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h4><p>分类：</p>
<ul>
<li>网络系统软件</li>
<li>网络环境软件</li>
<li>网络应用软件</li>
</ul>
<h5 id="网络系统软件"><a href="#网络系统软件" class="headerlink" title="网络系统软件"></a>网络系统软件</h5><p>网络操作系统：用于管理网络的各种资源和网络的正常运行。</p>
<p>典型的产品：Windows NT/2000/2003/Vista/Windows 7(8)、Netware、Unix、Linux等。—— 缺少国产，存在风险!!!</p>
<p>组成：</p>
<ul>
<li>网络操作系统<strong>内核</strong>（服务器软件，工作于服务器之上）</li>
<li>网络操作系统<strong>外壳</strong>（客户机软件，工作于客户机之上）</li>
</ul>
<p>—— 并通过它们的配合来完成网络管理工作。</p>
<h5 id="网络环境软件"><a href="#网络环境软件" class="headerlink" title="网络环境软件"></a>网络环境软件</h5><p>构成网络应用环境的各种软件，用户由此可以方便地使用网络，进行各种操作，并开发各种应用软件。</p>
<p>典型的产品：Internet Explore、Netscape 、J2EE、.NET Framework等。</p>
<h5 id="网络应用软件"><a href="#网络应用软件" class="headerlink" title="网络应用软件"></a>网络应用软件</h5><p>针对各种实际网络应用环境而开发的面向应用的软件。——如前面提到的公文管理软件、教务管理软件、科研管理、ERP、MES等。</p>
<h4 id="网络协议-标准"><a href="#网络协议-标准" class="headerlink" title="网络协议/标准"></a>网络协议/标准</h4><p>产品化的需求</p>
<p><strong>标准化组织及相应的协议</strong></p>
<p>国际标准化组织(ISO/TC97/SC16)：OSI/RM</p>
<p>国际电信联盟电信标准化局(ITU-T)：V系列，X系列，…</p>
<p>美国国家标准学会(ANSI) ：</p>
<ul>
<li><p>电气电子工程师学会(IEEE) ：IEEE802系列局域网标准</p>
</li>
<li><p>电子工业学会(EIA)：EIA RS-232接口标准</p>
</li>
<li><p>通信工业学会(TIA)：EIA/TIA 568A(B) 布线标准</p>
</li>
</ul>
<p><strong>企业</strong></p>
<p>Novell：IPX/SPX，Microsoft：NETBEAU……</p>
<p><strong>民间组织</strong></p>
<p>ISOC：Internet(TCP/IP)，各种联盟</p>
<h5 id="Internet组织机构"><a href="#Internet组织机构" class="headerlink" title="Internet组织机构"></a>Internet组织机构</h5><p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/1.png" alt="Internet组织机构"></p>
<h5 id="Internet标准化过程"><a href="#Internet标准化过程" class="headerlink" title="Internet标准化过程"></a>Internet标准化过程</h5><blockquote>
<p>因特网草案(Internet Draft)<br>↓<br>建议标准(Proposed Standard) —— RFC 文档<br>↓<br>草案标准(Draft Standard)<br>↓<br>因特网标准(Internet Standard) </p>
</blockquote>
<h4 id="计算机网络的逻辑组成"><a href="#计算机网络的逻辑组成" class="headerlink" title="计算机网络的逻辑组成"></a>计算机网络的逻辑组成</h4><p>计算机网络的主要功能：相互通信和资源共享</p>
<p>从逻辑上，划分两个子网：通信子网和资源子网</p>
<p><strong>通信子网</strong>：又称主干网络(Backborn)，主要由网络核心交换机、网络分支(边缘)交换机、网络主干线路(光缆或通信电缆) 和路由器(防火墙)等组成。—— 影响网络性能好坏的关键</p>
<p>主要任务：数据的交换、管理和控制</p>
<p><strong>资源子网</strong></p>
<p><strong>各种服务器及其接入子网</strong></p>
<p>目的：提供各种资源，如磁盘阵列、软件、数据等，以及共享网络打印机、音视频点播装置等。</p>
<p><strong>客户机及其接入子网</strong></p>
<p>主要任务：提供所需的软件、硬件以及数据等资源和服务，并进行各种数据处理 。 </p>
<p>逻辑划分意义：</p>
<p>在组建一个大型网络时，可以分而治之，减少复杂性。 </p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/2.png" alt="网络实例1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/3.png" alt="网络实例2"></p>
<h1 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h1><p>分类方法：</p>
<ul>
<li><strong>网络的地理覆盖范围</strong></li>
<li>网络的应用群体</li>
<li>网络的作用</li>
<li>网络的管理方式</li>
<li><strong>网络的拓扑结构形式</strong></li>
<li>网络的传输媒体</li>
</ul>
<h2 id="按照网络的地理覆盖范围分"><a href="#按照网络的地理覆盖范围分" class="headerlink" title="按照网络的地理覆盖范围分"></a>按照网络的地理覆盖范围分</h2><ul>
<li>广域网（Wide Area Network，WAN）</li>
<li>城域网（Metroplitan Area Network，MAN） </li>
<li>局域网（Local Area Network，LAN）</li>
<li>个人区域网 (Personal Area Network，PAN)</li>
<li>互联网（Internet) 【严格意义上不算】</li>
</ul>
<h3 id="广域网（WAN）"><a href="#广域网（WAN）" class="headerlink" title="广域网（WAN）"></a>广域网（WAN）</h3><p>跨度大：覆盖一个市、一个省，也可以覆盖一个国家、几个国家，甚至可以覆盖全世界。 </p>
<p>代表性网络：11个全国范围的互联网络，国家/省的公用/专用网络（如公安专网、银行专用网等）如：三大运营商、中国科学技术网（科研用）、中国长城网（军用）</p>
<h3 id="城域网（MAN）"><a href="#城域网（MAN）" class="headerlink" title="城域网（MAN）"></a>城域网（MAN）</h3><p>跨度介于广域网和局域网之间，覆盖距离一般为几十公里。</p>
<p>典型代表：城域教育网、城域党政信息网、公用宽带城域网等。满足城市地区范围内的某个特定行业、集团型企业、政府的网络需求。(如同城市的环城路，统一出口)</p>
<h3 id="局域网（LAN）"><a href="#局域网（LAN）" class="headerlink" title="局域网（LAN）"></a>局域网（LAN）</h3><p>跨度较小：通常限制在一个办公室或实验室、一个办公大楼，整个校园或企业，形成园区网（Intranet）。</p>
<p>覆盖距离一般不超过十公里。 </p>
<h3 id="个人区域网（PAN）"><a href="#个人区域网（PAN）" class="headerlink" title="个人区域网（PAN）"></a>个人区域网（PAN）</h3><p>将属于个人使用的电子设备用蓝牙、红外等无线技术连接起来形成的网络。覆盖范围一般不超过10米</p>
<p>典型代表：手机、笔记本电脑、PDA等。</p>
<h3 id="互联网（Internet"><a href="#互联网（Internet" class="headerlink" title="互联网（Internet)"></a>互联网（Internet)</h3><p>Internet实际上是由世界范围内众多计算机网络连接而成的网络，它并非一个具有独立形态的网络，而是由计算机网络汇合成的一个网络集合体。它<strong>难以区分边界，也没有必要区分边界</strong> 。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/4.png" alt="网络实例3"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/5.png" alt="互联网示意图"></p>
<h2 id="按网络的应用群体分"><a href="#按网络的应用群体分" class="headerlink" title="按网络的应用群体分"></a>按网络的应用群体分</h2><h3 id="公用网-public-network"><a href="#公用网-public-network" class="headerlink" title="公用网 (public network)"></a>公用网 (public network)</h3><p>可为所有公众提供有偿服务；通常跨度大，覆盖范围广。</p>
<h3 id="专用网-private-network"><a href="#专用网-private-network" class="headerlink" title="专用网 (private network)"></a>专用网 (private network)</h3><p>由某个机关/事业单位(部门)或企业(集团)自建自用。</p>
<h2 id="按网络的作用分"><a href="#按网络的作用分" class="headerlink" title="按网络的作用分"></a>按网络的作用分</h2><h3 id="骨-主-干网"><a href="#骨-主-干网" class="headerlink" title="骨(主)干网"></a>骨(主)干网</h3><p>网络核心，由大型（容量）交换机、通信基站、路由设备和大对数宽带（高速）主干光/电通信线缆（卫星）构成。</p>
<p>作用：数据的远程交换与传输</p>
<p>工作方式：路由交换</p>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>又称为本地接入网或居民接入网。</p>
<p>作用：让大量用户能够与因特网连接，起到“桥梁”作用。</p>
<p>典型代表：电话网ADSL、有线电视数据网、无线移动网 …</p>
<p>连接方式：通过ISP(Internet Service Provider)提供接入服务</p>
<h2 id="按网络的管理方式分"><a href="#按网络的管理方式分" class="headerlink" title="按网络的管理方式分"></a>按网络的管理方式分</h2><h3 id="对等网（P2P，Peer-to-Peer）"><a href="#对等网（P2P，Peer-to-Peer）" class="headerlink" title="对等网（P2P，Peer-to-Peer）"></a>对等网（P2P，Peer-to-Peer）</h3><p>特点：无主从之分，重在通信；系统小、价格低、使用便捷，无需管理。</p>
<p>适用范围：工作组间的协作与交流。</p>
<h3 id="非对等网（有服务器网络）"><a href="#非对等网（有服务器网络）" class="headerlink" title="非对等网（有服务器网络）"></a>非对等网（有服务器网络）</h3><p>特点：由服务器管理整个网络，重在资源共享与服务；功能强大、系统完善。</p>
<p>适用范围：面向大众用户。</p>
<p>服务器工作形式：并发方式和专用方式。</p>
<h2 id="按网络的拓扑结构分"><a href="#按网络的拓扑结构分" class="headerlink" title="按网络的拓扑结构分"></a>按网络的拓扑结构分</h2><h3 id="星形结构"><a href="#星形结构" class="headerlink" title="星形结构"></a>星形结构</h3><p>又称集中式网络。以一台网络设备为中心，其它所有要连网的计算机都与该中心网络设备相连。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/6.png" alt="星形结构"></p>
<h3 id="树形结构-——-从星形结构网络演变而来"><a href="#树形结构-——-从星形结构网络演变而来" class="headerlink" title="树形结构 —— 从星形结构网络演变而来"></a>树形结构 —— 从星形结构网络演变而来</h3><p>分级的集中式网络，每个上级网络设备都有对下级网络设备的管理和控制的能力，每个上级网络结点和它的所有下级网络结点都可以形成一个相对独立的集中式网络 。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/7.png" alt="树形结构"></p>
<h3 id="环形结构"><a href="#环形结构" class="headerlink" title="环形结构"></a>环形结构</h3><p>将所有要连网的计算机用一条或两条公用数据通道环接在一起而构成的单环或双环的网络。其网络控制一般分散到各结点 。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/8.png" alt="环形结构"></p>
<h3 id="总线式结构"><a href="#总线式结构" class="headerlink" title="总线式结构"></a>总线式结构</h3><p>将所有要连网的计算机通过一条公用数据通信线路连接在一起而形成的网络。—— 类似于计算机内部的总线结构。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/9.png" alt="总线式结构"></p>
<h3 id="分布式结构"><a href="#分布式结构" class="headerlink" title="分布式结构"></a>分布式结构</h3><p>网络没有固定的连接形式，各结点之间可能有多条路径相通。其路由选择是动态进行的，其信息流向是随机的。</p>
<h2 id="按网络的传输媒体分"><a href="#按网络的传输媒体分" class="headerlink" title="按网络的传输媒体分"></a>按网络的传输媒体分</h2><h3 id="有线网"><a href="#有线网" class="headerlink" title="有线网"></a>有线网</h3><p><strong>电缆网</strong></p>
<p>利用电信号表示和传输数据</p>
<p>优点：传输速度快；信息安全、稳定。</p>
<p>缺点：网络布线成本高，维护量大，施工困难。</p>
<p><strong>光传输（全光/光纤）网</strong></p>
<p>利用光信号表示和传输数据</p>
<p>优点：传输速度“极快”；信息安全、稳定。</p>
<p>缺点：线路成本高，维护量大，施工困难。</p>
<h3 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h3><p>利用电磁波或微波形式传输数据；</p>
<p>优点：不用布线，因而节省成本；尤其对于过河、过路以及历史建筑优势明显。</p>
<p>缺点：数据缺乏安全性，需加密；速度漫；范围小</p>
<p>标准：</p>
<ul>
<li>无线局域网802.11/a/b/g/n 11M → 54M →</li>
<li>宽带无线城域网802.16 (100M)→</li>
<li>无线个人局域网（基于蓝牙技术802.15，红外技术）</li>
</ul>
<h3 id="卫星网"><a href="#卫星网" class="headerlink" title="卫星网"></a>卫星网</h3><p>用于实现无线远程通信，无线通信的特例。</p>
<p>微波通信：</p>
<ul>
<li>要求接收天线与发送天线要互相可见</li>
<li>建立若干微波中继站， “接力” </li>
<li>形成微波中继系统</li>
</ul>
<p>卫星网特点：</p>
<ul>
<li>微波中继站在卫星上</li>
<li>利用卫星以微波形式传输数据</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/10.png" alt="卫星网"></p>
<h3 id="移动网"><a href="#移动网" class="headerlink" title="移动网"></a>移动网</h3><p>有线与无线的结合,电信网与计算机网(互联网)融合</p>
<ul>
<li>包括GSM、CDMA、GPRS等移动电信网</li>
<li>核心与基站之间为基于光传输的宽带主干网</li>
<li>基站与用户终端设备之间为基于电磁波传输的无线网</li>
</ul>
<h3 id="虚拟网"><a href="#虚拟网" class="headerlink" title="虚拟网"></a>虚拟网</h3><p><strong>虚拟局域网（VLAN）</strong>—— 企业内部局域网的一种实现形式</p>
<ul>
<li>虚拟网络是在整个网络中通过网络交换设备建立的虚拟工作组。与具体的物理网及地理位置无关。</li>
<li>实现部门或单位分布在不同位置情况的资源共享和访问。</li>
<li>将广播限制在虚拟工作组中，由于广播域的缩小，网络中广播包消耗带宽大大降低，网络的性能得到显著的提高。</li>
</ul>
<p><strong>虚拟专用网络（VPN）</strong> —— 企业外联网的一种实现</p>
<p>借助公网（Internet或其他网络）来形成企业专网或实现远程接入。</p>
<h3 id="企业内部网Intranet-企业外联网Extranet"><a href="#企业内部网Intranet-企业外联网Extranet" class="headerlink" title="企业内部网Intranet/企业外联网Extranet"></a>企业内部网Intranet/企业外联网Extranet</h3><p><strong>Intranet</strong></p>
<ul>
<li>按照Internet功能与服务模式建立的企业内部局域网。</li>
<li>可以是有线也可以是无线形式。</li>
</ul>
<p><strong>Extranet</strong></p>
<p>是Intranet的扩展 —— 跨越企业组织边界的网络连接。</p>
<p>形式：借助互联网, 通过VPN方式。</p>
<p>应用：</p>
<ul>
<li>本企业组织的员工远程访问本公司的Intranet 。</li>
<li>大的企业集团，分布在多个地域的分公司或办事机构需要作为一个整体，互相交换信息，访问对方的Intranet，将企业内部网Intranet连接在一起。</li>
</ul>
<h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="计算机网络的技术指标"><a href="#计算机网络的技术指标" class="headerlink" title="计算机网络的技术指标"></a>计算机网络的技术指标</h2><h3 id="传输速率和带宽"><a href="#传输速率和带宽" class="headerlink" title="传输速率和带宽"></a>传输速率和带宽</h3><h4 id="传输速率-Data-Rate"><a href="#传输速率-Data-Rate" class="headerlink" title="传输速率(Data Rate)"></a>传输速率(Data Rate)</h4><p>每秒种传输的二进制比特数，描述数据流的一个参数，单位用BPS表示。</p>
<h4 id="带宽（Bandwidth"><a href="#带宽（Bandwidth" class="headerlink" title="带宽（Bandwidth)"></a>带宽（Bandwidth)</h4><p>信道具有的频带宽度，描述媒介物理特性的一个参数，单位用HZ表示。</p>
<blockquote>
<p>两者关系的定性描述：</p>
<p>具有一定带宽的信道，其信号传输速率是有限的。</p>
<p>信号传输的速率越快，要求信道的带宽就越高。</p>
<p>信道的带宽越高，信号的传输速率就越快。</p>
<p>—— 两者成正比关系。</p>
<p>——信号传输速率与信道带宽两个概念在工业上经常互换使用。</p>
</blockquote>
<blockquote>
<p>两者关系的定量描述：</p>
<p>（1）对于无热噪声的理想信道（无其他信号干扰）来说，用奈奎斯特（Nyquist）公式计算：</p>
<p>极限传输速率（信道容量）C=2Flog$_2$S</p>
<p>其中，F为信道带宽 (Hz) ，S为单位周期内数字信号的状态数。</p>
<p>（2）对于有热噪声的实际信道（既有干扰信号）来说，这个极限值可以用香农（Shannon）公式计算：</p>
<p>信道容量 C=Flog$_2$(1+S/N) </p>
<p>其中，S为接收端信号平均功率（W），N为信道内噪声平均功率（W）。</p>
<p>一般的数据通信系统都必须保证S/N的比值。</p>
</blockquote>
<h3 id="吞吐量-throughput"><a href="#吞吐量-throughput" class="headerlink" title="吞吐量(throughput)"></a>吞吐量(throughput)</h3><p>单位时间内通过某个网络（或信道、接口）的数据量。</p>
<blockquote>
<p>传输速率、带宽、吞吐量都是衡量网络传输质量的重要参数。</p>
</blockquote>
<h3 id="误码率（BER：bit-error）"><a href="#误码率（BER：bit-error）" class="headerlink" title="误码率（BER：bit error）"></a>误码率（BER：bit error）</h3><p>衡量网络传输质量的一个重要参数。</p>
<p>定义：二进制符号在传输系统中被传错的概率。</p>
<p>近似的等于被传错的二进制符号数与所传二进制符号总数的比值</p>
<p>计算公式：误码率Pe = 接收的错误比特数/传输的总比特数</p>
<p>量值概念：在计算机网络通讯中，误码率要求低于$10^-9$</p>
<h3 id="分组延迟和延迟抖动"><a href="#分组延迟和延迟抖动" class="headerlink" title="分组延迟和延迟抖动"></a>分组延迟和延迟抖动</h3><h4 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h4><p>分组的第一个bit离开发送端与分组的最后一个bit到达接收端的时间间隔。</p>
<p>分组延迟可以细分为4个部分：</p>
<p>（1）发送延迟（传输延迟，transmission delay）：发送数据时，数据分组从结点进入网络所需的时间。</p>
<p>（2）传播延迟：分组在网络中传播而花费的时间，即发送端发送出分组中的某一个比特到接收端接收到该比特所经过的时间间隔，它取决于传输介质和传输距离。</p>
<blockquote>
<p>注意：信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。</p>
</blockquote>
<p>（3）处理延迟（processing delay）：交换结点为存储转发分组而进行一些必要的处理所花费的时间，即分组从到达节点到进入输出队列的时间间隔，包括对分组头处理，路由查找等，它取决于节点的处理能力和分组处理的复杂度</p>
<p>（4）排队延迟（queuing delay）：分组从进入队列到开始传输所经过的时间间隔，或者说分组在路由器等结点的缓存队列中排队所经历的延迟。排队延迟取决于平均队列长度（反映的是网络中的数据流量）和调度策略。</p>
<p><strong>分组总延迟＝发送延迟＋传播延迟＋处理延迟＋排队延迟</strong></p>
<blockquote>
<p>如何减少延迟？</p>
<p>提高网络的带宽、增加路由器等结点的缓存空间和处理能力</p>
</blockquote>
<h4 id="延迟抖动"><a href="#延迟抖动" class="headerlink" title="延迟抖动"></a>延迟抖动</h4><p>分组延迟的变化程度。反映的是端到端延时的变化特性。</p>
<p>产生原因：由延时的可变部分的变化导致的。如：流量的突发、不公平的队列调度算法。</p>
<p>影响程度：延迟抖动越大，网络服务质量越难以控制，网络越容易出现拥塞。</p>
<h3 id="分组丢失率和超时重传率"><a href="#分组丢失率和超时重传率" class="headerlink" title="分组丢失率和超时重传率"></a>分组丢失率和超时重传率</h3><p>丢失原因：因为出现拥塞而被迫丢失；因避免出现拥塞而被主动丢弃。</p>
<h4 id="分组丢失率"><a href="#分组丢失率" class="headerlink" title="分组丢失率"></a>分组丢失率</h4><p>单位时间内丢失的分组数量与所传输的分组数量的比值。</p>
<p>——取平均值(因为不同时刻，网络中的数据流量以及拥塞程度不同)</p>
<h4 id="超时重传率"><a href="#超时重传率" class="headerlink" title="超时重传率"></a>超时重传率</h4><p>单位时间内被重传的分组数量与发送的分组总数的比率。</p>
<p>——取一段时间内的平均值。</p>
<blockquote>
<p>分组丢失率、超时重传率和误码率都是衡量网络传输质量的重要参数。</p>
</blockquote>
<h3 id="信道利用率-amp-网络利用率"><a href="#信道利用率-amp-网络利用率" class="headerlink" title="信道利用率&amp;网络利用率"></a>信道利用率&amp;网络利用率</h3><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>信道的使用效率。</p>
<h4 id="网络利用率："><a href="#网络利用率：" class="headerlink" title="网络利用率："></a>网络利用率：</h4><p>网络中全部信道的利用率的加权平均值。</p>
<blockquote>
<p>考虑到可能出现的网络拥塞，信道利用率或网络利用率并非越高越好。</p>
</blockquote>
<h2 id="计算机网络的工程化指标"><a href="#计算机网络的工程化指标" class="headerlink" title="计算机网络的工程化指标"></a>计算机网络的工程化指标</h2><ul>
<li>性价比</li>
<li><strong>可靠性（稳定性）</strong></li>
<li>可扩展性</li>
<li>易于管理和维护</li>
</ul>
<h1 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a><strong>计算机网络的体系结构</strong></h1><h2 id="计算机网络体系结构的形成"><a href="#计算机网络体系结构的形成" class="headerlink" title="计算机网络体系结构的形成"></a>计算机网络体系结构的形成</h2><p>协议的必要性：双（多）方协调一致，相互匹配。</p>
<p>协议集：对于一个功能强大的、既包括硬件又包括软件的、复杂的计算机网络来说，需要制订若干个协议，构成一个协议集。</p>
<p>层次结构：对于数量繁多、庞大复杂的网络协议集来说，其最好的组织方式就是采用层次结构。 </p>
<p>分层的好处</p>
<ul>
<li>灵活性好：各层之间是独立的，可以跟据需要裁剪组合，跨越某些层。</li>
<li>易于设计（实现）和维护。</li>
<li>易于标准化。</li>
</ul>
<p>层数设多少</p>
<ul>
<li>层数太少：每一层的协议太复杂。</li>
<li>层数太多：各层之间关系太复杂。</li>
<li>层数适当：4 ～ 7</li>
</ul>
<p>分层原则：</p>
<ul>
<li>逻辑关系</li>
<li>功能独立性</li>
</ul>
<p>网络体系结构(architecture) ：网络协议的层次结构模型</p>
<p>网络体系结构意义：</p>
<ul>
<li>促进标准化</li>
<li>决定网络的功能和性能</li>
</ul>
<h2 id="开放系统互连参考模型OSI-RM"><a href="#开放系统互连参考模型OSI-RM" class="headerlink" title="开放系统互连参考模型OSI/RM"></a>开放系统互连参考模型OSI/RM</h2><p><strong>产生的背景：</strong></p>
<ul>
<li>层次化的网络体系结构被接受并得到普及和推广</li>
<li>各计算机生产厂商纷纷推出自己的层次化网络体系结构</li>
<li>这些网络体系结构普遍是以自己公司的产品为对象</li>
<li>层次的划分、功能的分配与采用的技术术语各不相同，不具备与其它公司网络结构的兼容性</li>
</ul>
<p>ISO组成TC97/SC16，OSI/RM应运而生。</p>
<p><strong>开放系统：</strong>一个系统在和其他系统进行通信时，如果能够遵守标准化的信息交换协议，就称其为开放系统。 </p>
<p><strong>层次划分的原则：</strong></p>
<ul>
<li>网络中相同的结点具有相同的层次；相同的层次具有相同的功能</li>
<li>同一结点内相邻层之间通过确定的接口进行交互通信</li>
<li>网络中不同结点的同等层之间采用相同的协议，实现对等层之间的交互操作</li>
</ul>
<p><strong>分层情况：</strong></p>
<p>以客户机为代表的每个端结点： 开放系统——七层</p>
<p>以路由器/交换机(三层结构) 为代表的中继结点（中继开放系统）——三层</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/11.png" alt="OSI参考模型的结构形式"></p>
<p><strong>各层协议的功能：</strong></p>
<ul>
<li><p>应用层协议：提供各种规范的网络应用和服务 (如文件传递，电子邮件等)</p>
</li>
<li><p>表示层协议：用于协调两个应用实体之间进行数据交换时数据格式不一致以及数据表示方法不同等问题 。</p>
</li>
<li><p>会话层协议：组织和同步不同主机上各进程间的通信(会话) —— 在两个相互通信的实体(进程)之间，建立、组织、协调其交互会话过程。</p>
</li>
<li><p>传输层协议：确保两个客户端之间可以实现端——端的透明数据传输服务。</p>
</li>
<li><p>网络层协议：用于实现数据分组跨通信子网（物理网络）进行传输的管理和控制。</p>
</li>
<li><p>数据链路层：按某种规程(如HDLC)组织每条数据链路上的数据传输，提供高可靠性、无差错的数据传输质量。</p>
</li>
<li><p>物理层协议：使所有连网的计算机系统和通信设备都能够从接口上兼容，并使这些接口的定义独立于厂商的设备。</p>
</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/12.png" alt="OSI参考模型的数据传输过程"></p>
<p><strong>OSI/RM的应用：</strong></p>
<p>CCITT（ITU—T）从一开始就提供对OSI的支持，协助制定标准。但在市场化方面 OSI 却失败了：</p>
<ul>
<li><p>OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场</p>
</li>
<li><p>OSI 的专家们在完成 OSI 标准时没有商业驱动力</p>
</li>
<li><p>OSI 的协议实现起来过分复杂，且运行效率很低</p>
</li>
<li><p>OSI 的层次划分并也不太合理，有些功能在多个层次中重复出现 </p>
<p>——总之，没有得到市场的认可。</p>
</li>
</ul>
<p><strong>OSI/RM的意义：</strong></p>
<p>其它所有网络体系结构都要都要参照OSI/RM，并给出与其对应关系。—— 参照意义。</p>
<h2 id="TCP-IP网络体系结构"><a href="#TCP-IP网络体系结构" class="headerlink" title="TCP/IP网络体系结构"></a>TCP/IP网络体系结构</h2><p>TCP/IP协议源于著名的ARPAnet及NSFNET</p>
<p>TCP/IP协议是先于OSI模型开发的，因此不符合OSI/RM标准。</p>
<p>TCP/IP协议被广泛采用的原因：</p>
<ul>
<li><p>Internet采用TCP/IP协议，各类网络都要和Internet或借助于Internet相互连接</p>
</li>
<li><p>TCP/IP已被公认为是异种计算机、异种网络彼此通信的可行协议</p>
</li>
<li><p>各主要计算机软、硬件厂商的网络产品几乎都支持TCP/IP协议</p>
</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/13.png" alt="TCP/IP网络体系结构概览"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/14.png" alt="IP可应用到各式各样的网络"></p>
<blockquote>
<p>TCP/IP不涉及接口层，所以可应用于各类网络</p>
<p>UDP后于TCP出现，主要弥补TCP协议的不足。TCP与UDP互补</p>
<p>TCP相对于UDP可靠性高；UDP相对于TCP传输效率高</p>
</blockquote>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>没有具体的协议，适用于任何网络产品。—— 类似对应OSI/RM的物理层和数据链路层。</p>
<h3 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h3><p>类似对应OSI/RM的网络层。</p>
<p>包括4个重要的协议：IP、ICMP、ARP和RARP。</p>
<h4 id="IP-互连网协议"><a href="#IP-互连网协议" class="headerlink" title="IP(互连网协议)"></a>IP(互连网协议)</h4><p>实现网际寻址，通过互连的网络找到目标结点，传送数据报。</p>
<p>特点：不检查遗失的分组 → IP协议不保证服务的可靠性</p>
<p>—— 端到端的流量控制、分组丢失的检测、分组排序等工作均由高层协议负责。 </p>
<h4 id="ICMP-互连网控制报文协议"><a href="#ICMP-互连网控制报文协议" class="headerlink" title="ICMP(互连网控制报文协议)"></a>ICMP(互连网控制报文协议)</h4><p>使网际上的计算机能够检测和报告丢包等差错，或提供其它意外信息 。</p>
<p>ICMP与IP的关系：嵌入到IP中，弥补IP的不足。（IP的补丁）</p>
<h4 id="ARP-地址转换协议"><a href="#ARP-地址转换协议" class="headerlink" title="ARP(地址转换协议)"></a>ARP(地址转换协议)</h4><p>将IP地址变换成硬件接口地址(MAC)</p>
<h4 id="RARP-反向地址转换协议"><a href="#RARP-反向地址转换协议" class="headerlink" title="RARP(反向地址转换协议)"></a>RARP(反向地址转换协议)</h4><p>根据MAC地址查找IP地址。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>为通信双方的主机提供端到端的服务。—— 类似对应OSI/RM的运输层和会话层</p>
<p>TCP/IP在传输层提供两个主要协议：</p>
<h4 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP(传输控制协议)"></a>TCP(传输控制协议)</h4><p>提供端到端可靠的进程间通信 —— TCP向高层提供的是面向连接的虚电路服务</p>
<p>面向连接的通信分三个阶段：连接建立、数据传送和连接拆除</p>
<p>由于建立了一条虚电路，因此可以实现可靠传输。</p>
<h4 id="UDP-用户数据报协议"><a href="#UDP-用户数据报协议" class="headerlink" title="UDP(用户数据报协议)"></a>UDP(用户数据报协议)</h4><p>提供端到端快捷但不够可靠的进程间通信 —— UDP向高层提供的是非面向连接的数据报服务</p>
<p>由于面向无连接的服务没有建立连接和拆除连接的过程，因此可直接进行数据传输，但每个包必须给出IP地址。</p>
<p>端口号：一个16位的标志符，标识传输层协议和特定的应用程序之间的接口。</p>
<p>套接字：端口号和IP地址合起来，唯一标识一个特定的应用程序。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>大致和OSI模型的表示层和应用层对应，但没有明确的层次划分。</p>
<p>其中，HTTP、Telnet、FTP、TFTP、SMTP、DNS等是广泛使用的应用层协议。 </p>
<p><strong>TCP/IP的特点</strong></p>
<ul>
<li>TCP/IP虽然也分层，但其层次间的调用关系不像OSI那样严格</li>
</ul>
<blockquote>
<p>可以越层</p>
</blockquote>
<ul>
<li>OSI对可靠性的强调是第一位的，协议的所有各层都要检测和处理错误</li>
</ul>
<blockquote>
<p>随着传输介质和通信子网的升级换代，没必要</p>
</blockquote>
<p>​        TCP/IP认为可靠性应该在传输层由端结点来解决</p>
<blockquote>
<p>TCP/IP效率很高（但如果通信子网可靠性较差，主机的负担就会加重）</p>
</blockquote>
<ul>
<li><p>OSI由通信子网解决：监视数据流量、控制网络访问、记帐收费、甚至路由选择、流量控制等智能性活动；TCP/IP则要求主机参与几乎所有的智能性活动。</p>
</li>
<li><p>OSI一开始没有考虑网络互连问题，只好以后在网络层中划分出一个子层来完成类似IP的功能TCP/IP从一开始就考虑到网络互联问题，并将互连网协议IP作为TCP/IP的重要组成部分</p>
</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/15.png" alt="5层网络体系结构模型"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/16.png" alt="5层网络数据传输过程"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/17.png" alt="小结"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/02/24/26-Computer-network-study-notes-1">https://zam9036.gitee.io/2020/02/24/26-Computer-network-study-notes-1</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>课程：计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Android UI框架flutter的安装与使用|Zam9036博客</title>
    <url>/2020/01/29/25-Android-UI-framework-flutter-installation-and-use/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="适用平台"><a href="#适用平台" class="headerlink" title="适用平台"></a>适用平台</h1><p>Windows</p>
<h1 id="Flutter介绍"><a href="#Flutter介绍" class="headerlink" title="Flutter介绍"></a>Flutter介绍</h1><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p>
<h1 id="Flutter安装"><a href="#Flutter安装" class="headerlink" title="Flutter安装"></a>Flutter安装</h1><h2 id="下载flutter"><a href="#下载flutter" class="headerlink" title="下载flutter"></a>下载flutter</h2><p>访问<a href="https://flutter.dev/docs/development/tools/sdk/releases#windows" target="_blank" rel="noopener">flutter官网</a>，下载flutter。flutter集成了Dart，因此不需要单独安装dart-sdk。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/1.png" alt="flutter官网"></p>
<blockquote>
<p>flutter有四个版本</p>
<ul>
<li>Stable channel    //稳定版。最近一年中最稳定的Beta版本。</li>
<li>Beta channel    //测试版。每隔一段时间都会选择近个月中最好的Bev版本作为Beta版。</li>
<li>Dev channel    //经过测试的最新版，但仍可能包含很多问题。</li>
<li>Master channel    //未经过测试的最新版。</li>
</ul>
</blockquote>
<p>我选择的是最新的Stable channel（v1.12.13+hotfix.7）。为避免不必要的麻烦，请不要选择C盘作为下载目录，否则可能遇到权限问题。</p>
<h2 id="更新环境变量"><a href="#更新环境变量" class="headerlink" title="更新环境变量"></a>更新环境变量</h2><p>flutter下载完成后，解压到存放SDK的目录。</p>
<p>注意：目标SDK路径仅能包含英文和数字，不能包含中文和空格！</p>
<p>解压完成后，返回桌面，右击<code>我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统环境变量</code>，编辑Path，添加目标SDK的路径至Path内（我的路径是<code>G:\flutter\bin</code>）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/2.png" alt="更新环境变量1"></p>
<p>同时还需要添加以下系统环境变量</p>
<pre><code class="环境变量">变量名：PUB_HOSTED_URL
变量值：https://pub.flutter-io.cn

变量名：FLUTTER_STORAGE_BASE_URL
变量值：https://storage.flutter-io.cn</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/3.png" alt="更新环境变量2"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/4.png" alt="更新环境变量3"></p>
<p>所有环境变量添加完成后重启电脑！</p>
<h2 id="flutter-doctor检测安装"><a href="#flutter-doctor检测安装" class="headerlink" title="flutter doctor检测安装"></a>flutter doctor检测安装</h2><p>打开cmd，输入<code>flutter</code>指令，如看到下图的flutter相关指令，说明安装成功。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/5.png" alt="flutter指令"></p>
<p>输入<code>flutter doctor</code>指令，检测安装情况，最左边打红叉的是必须要解决的，橙色感叹号是Warning，绿色说明正确。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/6.png" alt="flutter doctor指令"></p>
<h2 id="添加SDK路径至环境变量"><a href="#添加SDK路径至环境变量" class="headerlink" title="添加SDK路径至环境变量"></a>添加SDK路径至环境变量</h2><p>添加SDK路径至环境变量（我的SDK路径是G:\AndroidSDK\platform-tools）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/7.png" alt="添加SDK路径至环境变量"></p>
<h2 id="安装Android-Studio-Plugin"><a href="#安装Android-Studio-Plugin" class="headerlink" title="安装Android Studio Plugin"></a>安装Android Studio Plugin</h2><p>首先你需要有Android Studio（Android Studio安装详见<a href="https://zam9036.gitee.io/2020/01/24/24-Android-Study-Notes-1">Android学习笔记(一)</a>）</p>
<p>打开Android Studio，<code>File -&gt; Setting -&gt; Plugins -&gt; Browse repositories</code>，搜索flutter。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/8.png" alt="安装Android Studio Plugin-1"></p>
<p>就是这个，点击安装</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/9.png" alt="安装Android Studio Plugin-2"></p>
<p>点击Yes，会自动帮你安装dart-sdk</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/10.png" alt="安装Android Studio Plugin-3"></p>
<p>安装完成后需要重启Android Studio，然后可以看到安装的dart-sdk和flutter。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/11.png" alt="安装Android Studio Plugin-4"></p>
<h1 id="使用flutter"><a href="#使用flutter" class="headerlink" title="使用flutter"></a>使用flutter</h1><p>点开Android Studio的 File -&gt; New 可以看到 New Flutter Project</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/12.png" alt="使用flutter-1"></p>
<p>选择喜欢的模板，开始flutter之旅吧！</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/13.png" alt="使用flutter-2"></p>
<h1 id="部分flutter指令"><a href="#部分flutter指令" class="headerlink" title="部分flutter指令"></a>部分flutter指令</h1><h2 id="升级flutter"><a href="#升级flutter" class="headerlink" title="升级flutter"></a>升级flutter</h2><p>打开cmd，定位到根目录，输入如下指令升级</p>
<pre><code class="cmd">flutter upgrade</code></pre>
<h2 id="切换flutter版本"><a href="#切换flutter版本" class="headerlink" title="切换flutter版本"></a>切换flutter版本</h2><p>指令如下：</p>
<pre><code class="cmd">flutter channel [目标版本]</code></pre>
<p>如<code>flutter channel dev</code></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>参考资料：<a href="https://blog.csdn.net/fyyyr/article/details/86593125" target="_blank" rel="noopener">https://blog.csdn.net/fyyyr/article/details/86593125</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/01/29/25-Android-UI-framework-flutter-installation-and-use">https://zam9036.gitee.io/2020/01/29/25-Android-UI-framework-flutter-installation-and-use</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习笔记(一)|Zam9036博客</title>
    <url>/2020/01/24/24-Android-Study-Notes-1/</url>
    <content><![CDATA[<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>Android（安卓）是<strong>基于Linux</strong>的移动设备操作系统，主要应用于智能手机与平板电脑，现已拓展应用于互联网电视、可穿戴设备、智能家居等领域。Android与IOS同为智能手机市场的两大操作系统。</p>
<p>Android开发环境：Android Studio+Android SDK+Java 或 Android Studio+Android SDK+Kotlin</p>
<p>Android一般一年更新一个大版本。</p>
<blockquote>
<p>Android与IOS是两大最主要的移动操作系统</p>
<p>Android是市场占有率最高的移动操作系统</p>
</blockquote>
<h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><p>早期Android开发APP主要使用Eclipse和基于Eclipse的ADT，但Eclipse平台是专为Java工程开发而生的平台，先天性不足在所难免，所以Google打造了自家的Android开发平台：Android Studio。</p>
<p>Android Studio比Eclipse有如下优势：</p>
<ul>
<li>Android Studio使用v7库与design库只需要增加一行配置，而Eclipse如果想使用这些库需要引用整个工程</li>
<li>高版本的SDK与NDK只支持Android Studio，不支持Eclipse</li>
<li>许多新功能只能在Android Studio中应用</li>
</ul>
<h2 id="Android-Studio安装"><a href="#Android-Studio安装" class="headerlink" title="Android Studio安装"></a>Android Studio安装</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>JDK是Java语言的编译器，是Java开发工具包。Android采用Java语言（现还可以使用Kotlin）进行开发，故需要安装JDK。</p>
<h4 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h4><p>SDK是Android应用的编译器，是软件开发工具包。LTS代表稳定支持版。</p>
<h4 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h4><p>NDK是C/C++代码编译器，是原生开发工具包。</p>
<h2 id="Android-Studio功能"><a href="#Android-Studio功能" class="headerlink" title="Android Studio功能"></a>Android Studio功能</h2><p>SDK Manager：SDK版本管理器</p>
<p>AVD Manager：Android虚拟机管理器</p>
<p>PackageName包名：域名反写作为包名。例：cn.edu.bistu.cs</p>
<h1 id="Android系统架构（framework）"><a href="#Android系统架构（framework）" class="headerlink" title="Android系统架构（framework）"></a>Android系统架构（framework）</h1><p>自上而下：应用程序、安卓应用程序框架、安卓系统服务层（安卓运行环境、本地程序库）、硬件抽象层、Linux内核层</p>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>Android4.4之前Dalvik虚拟机</p>
<p>Android4.4之后ART虚拟机</p>
<h1 id="移动开发模式"><a href="#移动开发模式" class="headerlink" title="移动开发模式"></a>移动开发模式</h1><h2 id="原生"><a href="#原生" class="headerlink" title="原生"></a>原生</h2><p>原生开发模式是最可靠的方案，运行效率较高，学习成本高，开发效率较低，无法跨平台。</p>
<h2 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h2><p>HTML5，使用浏览器运行，纯Web前端架构，成本最低，开发迅速，但无法调用许多手机重要的特性（如相机、位置信息）。</p>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>在开发原生应用的基础上，嵌入WebView，可跨平台。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>图解数据结构-插入排序|Zam9036博客</title>
    <url>/2020/01/12/23-Graphical-data-structure-Insertion-sort/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法—插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。<br>插入排序的基本思想是：每步将一个待排序的记录，按其数值的大小插入前面已经排序的数字中适当位置上，直到全部插入完为止。</p>
<h1 id="图解核心原理"><a href="#图解核心原理" class="headerlink" title="图解核心原理"></a>图解核心原理</h1><p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/1.jpg" alt="插入排序核心原理1"></p>
<p>插入排序需要把数列分为两个部分，一部分为排好的有序数列和另一部分未排的无序数列。假如我们需要对上图数列进行排序。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/2.jpg" alt="插入排序核心原理2"></p>
<p>排序开始时首先把最左端的数字归为已排序数列(5)，其余数字为未排数列(34728691)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/3.jpg" alt="插入排序核心原理3"></p>
<p>然后，取出未排数列中未操作过的最左端的数字(3)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/4.jpg" alt="插入排序核心原理4"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/5.jpg" alt="插入排序核心原理5"></p>
<p>将未排数列中未操作过的最左端的数字(3)与已排数列的数字(5)从右到左逐个进行比较。如果已排数列的数字大，则交换两个数字，并继续与该已排数列数字的前一个数字进行比较，重复此操作，直到出现一个较小的数字或者达到已排数列的最左端(此时3到达最左端，则停止移动，插入已排数列，完成排序)；如果已排数列的数字小，则停止移动，并将该未排数字插入已排数列，完成排序。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/6.jpg" alt="插入排序核心原理6"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(4)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/7.jpg" alt="插入排序核心原理7"></p>
<p>将未排数列中未操作过的最左端的数字(4)与已排数列的数字(35)从右到左逐个进行比较。此时已排数列的数字(5)大，未排序数列最左端数字(4)小，则交换两个数字(交换5和4)，并继续与该已排数列数字的前一个数字(3)进行比较。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/8.jpg" alt="插入排序核心原理8"></p>
<p>此时已排数列的数字(3)小，则停止移动，并将该未排数字(4)插入已排数列，完成排序(得到已排数列345)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/9.jpg" alt="插入排序核心原理9"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(7)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/10.jpg" alt="插入排序核心原理10"></p>
<p>将未排数列中未操作过的最左端的数字(7)与已排数列的数字(345)从右到左逐个进行比较。此时已排数列的数字(5)小，则停止移动，并将该未排数字(7)插入已排数列(得到已排数列3457)，完成排序。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/11.jpg" alt="插入排序核心原理11"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(2)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/12.jpg" alt="插入排序核心原理12"></p>
<p>将未排数列中未操作过的最左端的数字(2)与已排数列的数字(3457)从右到左逐个进行比较。此时已排数列的数字(7)大，未排序数列最左端数字(2)小，则交换两个数字(交换7和2)，并继续与该已排数列数字的前一个数字(5)进行比较。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/13.jpg" alt="插入排序核心原理13"></p>
<p>此时已排数列的数字(5)大，未排序数列最左端数字(2)小，则交换两个数字(交换5和2)，并继续与该已排数列数字的前一个数字(4)进行比较。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/14.jpg" alt="插入排序核心原理14"></p>
<p>此时已排数列的数字(4)大，未排序数列最左端数字(2)小，则交换两个数字(交换4和2)，并继续与该已排数列数字的前一个数字(3)进行比较。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/15.jpg" alt="插入排序核心原理15"></p>
<p>此时已排数列的数字(3)大，未排序数列最左端数字(2)小，则交换两个数字(交换3和2)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/16.jpg" alt="插入排序核心原理16"></p>
<p>交换后2到达最左端，则停止移动，插入已排数列，完成排序(得到已排数列23457)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/17.jpg" alt="插入排序核心原理17"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(8)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/18.jpg" alt="插入排序核心原理18"></p>
<p>此时已排数列的数字(7)小，则停止移动，并将该未排数字(8)插入已排数列，完成排序(得到已排数列234578)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/19.jpg" alt="插入排序核心原理19"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(6)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/20.jpg" alt="插入排序核心原理20"></p>
<p>将未排数列中未操作过的最左端的数字(6)与已排数列的数字(234578)从右到左逐个进行比较。7、8比6大，5比6小，所以6应该插在5、7之间。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/21.jpg" alt="插入排序核心原理21"></p>
<p>将6插入已排数列，完成排序(得到已排数列2345678)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/22.jpg" alt="插入排序核心原理22"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(9)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/23.jpg" alt="插入排序核心原理23"></p>
<p>8比9小，所以9直接插入已排数列末尾(得到已排数列23456789)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/24.jpg" alt="插入排序核心原理24"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(1)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/25.jpg" alt="插入排序核心原理25"></p>
<p>已排数列的数字23456789均比1大，所以1到达最左端，并插入已排数列，得到有序数列123456789。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/26.jpg" alt="插入排序核心原理26"></p>
<p>此时未排数列为空，所有数字完成排序，排序结束。</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>部分资料来自：<a href="http://algorithm.wiki" target="_blank" rel="noopener">http://algorithm.wiki</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/01/12/23-Graphical-data-structure-Insertion-sort">https://zam9036.gitee.io/2020/01/12/23-Graphical-data-structure-Insertion-sort</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图解数据结构—选择排序|Zam9036博客</title>
    <url>/2020/01/11/22-Graphical-data-structure-selection-sort/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p>
<h1 id="图解核心原理"><a href="#图解核心原理" class="headerlink" title="图解核心原理"></a>图解核心原理</h1><p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/1.jpg" alt="选择排序核心原理1"></p>
<p>假设我们需要对上图数列进行排序。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/2.jpg" alt="选择排序核心原理2"></p>
<p>首先，我们需要对数列进行线性搜索(从头到尾逐个元素搜索)，找出最小的元素值(最小为1)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/3.jpg" alt="选择排序核心原理3"></p>
<p>将值最小的元素(最小为1)与数列最左端的元素(原来数列最左端元素为6)互换。如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/4.jpg" alt="选择排序核心原理4"></p>
<p>保持已经排好的元素位置不变(即1的位置不再改变)，在剩余元素中找出值最小的元素(最小为2)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/5.jpg" alt="选择排序核心原理5"></p>
<p>将此时值最小的元素(最小为2)与未排序的数列最左端的元素(原来未排序的数列最左端元素为6)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/6.jpg" alt="选择排序核心原理6"></p>
<p>继续保持已经排好的元素位置不变(即1、2的位置不再改变)，在剩余元素中找出值最小的元素(最小为3)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/7.jpg" alt="选择排序核心原理7"></p>
<p>将此时值最小的元素(最小为3)与未排序的数列最左端的元素(原来未排序的数列最左端元素为7)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/8.jpg" alt="选择排序核心原理8"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3的位置不再改变)，在剩余元素中找出值最小的元素(最小为4)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/9.jpg" alt="选择排序核心原理9"></p>
<p>将此时值最小的元素(最小为4)与未排序的数列最左端的元素(原来未排序的数列最左端元素为8)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/10.jpg" alt="选择排序核心原理10"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4的位置不再改变)，在剩余元素中找出值最小的元素(最小为5)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/11.jpg" alt="选择排序核心原理11"></p>
<p>将此时值最小的元素(最小为5)与未排序的数列最左端的元素(原来未排序的数列最左端元素为9)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/12.jpg" alt="选择排序核心原理12"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4、5的位置不再改变)，在剩余元素中找出值最小的元素(最小为6)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/13.jpg" alt="选择排序核心原理13"></p>
<p>将此时值最小的元素(最小为6)与未排序的数列最左端的元素(原来未排序的数列最左端元素为7)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/14.jpg" alt="选择排序核心原理14"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4、5、6的位置不再改变)，在剩余元素中找出值最小的元素(最小为7)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/15.jpg" alt="选择排序核心原理15"></p>
<p>将此时值最小的元素(最小为7)与未排序的数列最左端的元素(原来未排序的数列最左端元素为9)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/16.jpg" alt="选择排序核心原理16"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4、5、6、7的位置不再改变)，在剩余元素中找出值最小的元素(最小为8)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/17.jpg" alt="选择排序核心原理17"></p>
<p>将此时值最小的元素(最小为8)已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/18.jpg" alt="选择排序核心原理18"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4、5、6、7、8的位置不再改变)，在剩余元素中找出值最小的元素(最小为9)。将此时值最小的元素(最小为9)已经在最左端，则不需要执行任何操作。</p>
<p>现在，数列的顺序已经排好。</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>部分资料来自：<a href="http://algorithm.wiki" target="_blank" rel="noopener">http://algorithm.wiki</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/01/11/22-Graphical-data-structure-selection-sort">https://zam9036.gitee.io/2020/01/11/22-Graphical-data-structure-selection-sort</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图解数据结构—冒泡排序|Zam9036博客</title>
    <url>/2020/01/10/21-Graphical-data-structure%E2%80%94bubble-sort/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>冒泡排序重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换为止，也就是说该元素列已经排序完成为止。</p>
<h1 id="图解核心原理"><a href="#图解核心原理" class="headerlink" title="图解核心原理"></a>图解核心原理</h1><p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/1.jpg" alt="冒泡排序核心原理1"></p>
<p>首先，我们将天平放在序列的右端，并比较天平左右的数字。在这种情况下，我们来比较7和6。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/2.jpg" alt="冒泡排序核心原理2"></p>
<p>比较后如果右边的数字较小，则被交换。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/3.jpg" alt="冒泡排序核心原理3"></p>
<p>比较完成后，逐一移动天平继续比较。这次6大于4，所以数字不交换。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/4.jpg" alt="冒泡排序核心原理4"></p>
<p>将天平向左移动一个位置，继续比较。这次4小于8，交换4和8。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/5.jpg" alt="冒泡排序核心原理5"></p>
<p>将天平向左移动一个位置，继续比较。这次4大于2，所以数字不交换。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/6.jpg" alt="冒泡排序核心原理6"></p>
<p>将天平向左移动一个位置，继续比较。这次2大于1，所以数字不交换。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/7.jpg" alt="冒泡排序核心原理7"></p>
<p>将天平向左移动一个位置，继续比较。这次1小于3，交换1和3。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/8.jpg" alt="冒泡排序核心原理8"></p>
<p>将天平向左移动一个位置，继续比较。这次1小于9，交换1和9。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/9.jpg" alt="冒泡排序核心原理9"></p>
<p>将天平向左移动一个位置，继续比较。这次1小于5，交换1和5。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/10.jpg" alt="冒泡排序核心原理10"></p>
<p>此时天平到达序列最左端。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/11.jpg" alt="冒泡排序核心原理11"></p>
<p>在一系列操作中，序列中最小的数字已经移动到最左端。保持该数字位置不再改变，天平返回右端。重复相同的操作，直到所有数字都被排序……</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>部分资料来自：<a href="http://algorithm.wiki" target="_blank" rel="noopener">http://algorithm.wiki</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/01/10/21-Graphical-data-structure—bubble-sort">https://zam9036.gitee.io/2020/01/10/21-Graphical-data-structure—bubble-sort</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用邻接表存储无向非连通图并利用DFS和BFS遍历图的邻接表|Zam9036博客</title>
    <url>/2019/12/05/20-Use-adjacency-list-to-store-undirected-disconnected-graphs-and-traverse-adjacency-lists-with-DFS-and-BFS/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><p>​    C++</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过建立无向非连通图，并对图进行DFS及BFS遍历，了解图的构建算法，并加深对DFS及BFS的理解。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>1）建立无向非连通图的邻接表存储结构，要求顶点个数不少于15个。 2）用DFS及BFS对此邻接表进行遍历，打印出两种遍历的顶点访问顺序。3）给定图中任意两个顶点v1和v2及整数k，判断是否存在从v1到v2的路径长度为k的简单路径，若有打印出路径上的顶点序列（要求路径上不含回路）。进一步：找出从v1到v2的所有路径长度为k的简单路径。（简单路径：顶点序列中不含重现的顶点的路径。）</p>
<h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本实验实现DFS算法是利用栈储存待访问的节点，利用栈的FILO（先入后出）来实现深度搜索；实现BFS是利用队列储存待访问的节点，利用队列的FIFO（先入后出）来实现广度搜索。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试以下5节点图和12节点图</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/1.png" alt="5节点图"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/2.png" alt="12节点图"></p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><p>首先创建节点结构（包括该路径指向的顶点位置、指向下一个路径、该路径的相关信息）和连线结构（顶点信息、指向第一条依附该节点路径的指针、访问情况），然后根据输入逐个插入邻接表点从而创建邻接表。</p>
<p>本实验实现DFS算法是利用栈储存待访问的节点，利用栈的FILO（先入后出）来实现深度搜索：从根节点开始，遍历节点的连接表，跳过已访问的节点值，将未访问过的节点加入栈，然后逐一取走栈内元素并对取走的节点邻接表进行遍历，重复相同过程，直至栈为空结束；实现BFS是利用队列储存待访问的节点，利用队列的FIFO（先入后出）来实现广度搜索：从根节点开始，遍历节点的连接表，跳过已访问的节点值，将未访问过的节点加入队列，然后逐一取走队列内元素并对取走的节点邻接表进行遍历，重复相同过程，直至队列为空结束。</p>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/3.png" alt="5节点图测试"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/4.png" alt="12节点图测试"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.有重复遍历的节点情况出现</p>
<p>解决方法：对每个节点增加一个访问情况值，访问邻接表时跳过已访问过的值。</p>
<p>2.寻找简单路径暂无思路 </p>
<h1 id="使用说明和测试结果"><a href="#使用说明和测试结果" class="headerlink" title="使用说明和测试结果"></a>使用说明和测试结果</h1><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>用Visual Studio打开.sln文件即可运行</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过，符合程序设计要求和需求分析</p>
<p>详细结果见调试分析-示例测试</p>
<h1 id="体会心得"><a href="#体会心得" class="headerlink" title="体会心得"></a>体会心得</h1><p>通过本次课程实验，我对数据结构的了解进一步加深，并产生了浓厚的兴趣。虽然在写代码过程中遇到了一些问题，但我通过思考、网上找资料、询问同学等方式最终解决了问题。这次实验让我进一步巩固了建立无向非连通图的方法，及对图进行DFS及BFS遍历算法，了解了图的构建算法，并加深了对DFS及BFS的理解，进一步加强了自学能力，拓展了思路。</p>
<h1 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h1><h2 id="graph-cpp"><a href="#graph-cpp" class="headerlink" title="graph.cpp"></a>graph.cpp</h2><pre><code class="c++">#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;iostream&gt;
using namespace std;

//节点遍历情况
enum visitCondition
{
    no,    //未访问
    visiting,    //正在访问，邻接点还没访问完
    yes    //访问完毕
};

template&lt;typename VertexType, typename InfoType&gt;
class Graph
{
public:
    Graph(int vertexNum) :m_vertexNum(vertexNum), m_arcNum(0)
    {
        for (int i = 0; i &lt; MAX_VERTEX_NUM; ++i)
        {
            m_vertices[i].firstArc = nullptr;
        }
    }

    //输出图的信息
    void Display()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个节点为&quot; &lt;&lt; m_vertices[i].data &lt;&lt; &quot; 邻接表为：&quot;;
            ArcNode* node = m_vertices[i].firstArc;
            while (node)
            {
                cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; m_vertices[node-&gt;vertexIndex].data;
                node = node-&gt;next;
            }
            cout &lt;&lt; endl;
        }
    }

    void BFS()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            m_vertices[i].visitconditions = no;
        }
        cout &lt;&lt; &quot;图的广度优先遍历为：&quot;;
        BFS(&amp;m_vertices[0]);
        cout &lt;&lt; endl;
    }

    void DFS()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            m_vertices[i].visitconditions = no;
        }
        cout &lt;&lt; &quot;图的深度优先遍历为：&quot;;
        DFS(&amp;m_vertices[0]);
        cout &lt;&lt; endl;
    }

    //创建无向无权图
    void Create()
    {
        InitVertices();
        cout &lt;&lt; &quot;请分别输入每条边的起始节点和终止节点:&quot; &lt;&lt; endl;
        int head, tail;
        while (cin &gt;&gt; head &gt;&gt; tail)
        {
            //无向图head-&gt;tail tail-&gt;head插入两次
            Insert(head, tail, 0);
            Insert(tail, head, 0);
        }
    }

    void FindMinRoad(int v1, int v2, int k)
    {

    }

private:
    struct ArcNode
    {
        int vertexIndex;        //该路径指向的顶点位置
        struct ArcNode* next;    //指向下一个路径
        InfoType info;            //该路径的相关信息，如权重等
    };

    struct Vertex
    {
        VertexType data;    //顶点信息
        ArcNode* firstArc;    //指向第一条依附该节点路径的指针
        visitCondition visitconditions;    //访问情况
    };

    //最大顶点数
    static const int MAX_VERTEX_NUM = 20;
    Vertex m_vertices[MAX_VERTEX_NUM];    //顶点列表
    int m_vertexNum;    //当前顶点数量
    int m_arcNum;        //当前路径数量
private:
    //初始化顶点列表
    void InitVertices()
    {
        cout &lt;&lt; &quot;请输入每个顶点的关键字&quot; &lt;&lt; endl;
        VertexType data;
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            cin &gt;&gt; data;
            m_vertices[i].data = data;
        }
    }
    //插入一个表节点
    void Insert(int headVertex, int tailVertex, InfoType info)
    {
        //构造一个邻接表节点，即创建一条路径
        ArcNode* newNode = new ArcNode;
        newNode-&gt;info = info;
        newNode-&gt;next = nullptr;
        newNode-&gt;vertexIndex = tailVertex;

        //找到邻接表的最后一个节点
        ArcNode* lastNode = m_vertices[headVertex].firstArc;
        if (lastNode == nullptr)
            m_vertices[headVertex].firstArc = newNode;
        else
        {
            while (lastNode-&gt;next)
            {
                lastNode = lastNode-&gt;next;
            }
            lastNode-&gt;next = newNode;
        }
        ++m_arcNum;
    }

    void BFS(Vertex* vertex)
    {
        vertex-&gt;visitconditions = visiting;
        queue&lt;Vertex*&gt; vertices;
        vertices.push(vertex);
        while (!vertices.empty())
        {
            Vertex* curVertex = vertices.front();
            vertices.pop();
            cout &lt;&lt; curVertex-&gt;data &lt;&lt; &quot;-&gt;&quot;;
            ArcNode* node = curVertex-&gt;firstArc;
            while (node)
            {
                Vertex* tmpVertex = &amp;m_vertices[node-&gt;vertexIndex];
                if (tmpVertex-&gt;visitconditions == no)
                {
                    tmpVertex-&gt;visitconditions = visiting;
                    vertices.push(tmpVertex);
                }
                node = node-&gt;next;
            }
            curVertex-&gt;visitconditions = yes;
        }
    }

    void DFS(Vertex* vertex)
    {
        vertex-&gt;visitconditions = visiting;
        stack&lt;Vertex*&gt; vertices;
        vertices.push(vertex);
        while (!vertices.empty())
        {
            Vertex* curVertex = vertices.top();
            vertices.pop();
            cout &lt;&lt; curVertex-&gt;data &lt;&lt; &quot;-&gt;&quot;;
            ArcNode* node = curVertex-&gt;firstArc;
            while (node)
            {
                Vertex* tmp = &amp;m_vertices[node-&gt;vertexIndex];
                if (tmp-&gt;visitconditions == no)
                {
                    tmp-&gt;visitconditions = visiting;
                    vertices.push(tmp);
                }
                node = node-&gt;next;
            }
            curVertex-&gt;visitconditions = yes;
        }
    }
};

int main()
{
    int  vertexNum, v1, v2 , k;
    cout &lt;&lt; &quot;请输入要创建的图的节点数：&quot;;
    cin &gt;&gt; vertexNum;
    Graph&lt;char, int&gt; g(vertexNum);
    g.Create();
    g.Display();
    g.BFS();
    g.DFS();
    //cout &lt;&lt; &quot;请依次输入需要寻找简单路径的起点和重点v1 v2和路径长度k：&quot;;
    //cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; k;
    //g.FindMinRoad(v1, v2, k);
}</code></pre>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/12/05/20-Use-adjacency-list-to-store-undirected-disconnected-graphs-and-traverse-adjacency-lists-with-DFS-and-BFS">https://zam9036.gitee.io/2019/12/05/20-Use-adjacency-list-to-store-undirected-disconnected-graphs-and-traverse-adjacency-lists-with-DFS-and-BFS</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>实践项目</tag>
        <tag>课程：数据结构英文C</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后拓展—利用DFS深度优先搜索算法解决N皇后问题|Zam9036博客</title>
    <url>/2019/12/03/19-Eight-Queens-Expansion-Using-DFS-Depth-First-Search-Algorithm-to-Solve-N-Queens-Problem/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><p>​    C++</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过求解皇后问题，熟悉深度优先搜索法DFS（回溯法（Backtracking Algorithms）技术。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>由n*n个方块排成n行n列的正方形称为n元棋盘。如果两个皇后位于n元棋盘上的同一行、同一列或同一对角线上，则称它们在互相攻击。现要找出使棋盘上n个皇后互不攻击的布局。</p>
<h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>用一维数组代表皇后，其中角标代表皇后的序数，数组元素的值代表皇后的列位置，用深度优先搜索法DFS（回溯法（Backtracking Algorithms）技术求解N皇后的所有不冲突放置方法。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>分别求解8皇后和12皇后的不冲突放置方法</p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="数据结构详细设计"><a href="#数据结构详细设计" class="headerlink" title="数据结构详细设计"></a>数据结构详细设计</h2><p>用一维数组代表皇后，其中角标代表皇后的序数，数组元素的值代表皇后的列位置，用深度优先搜索法DFS（回溯法Backtracking Algorithms）技术求解N皇后的所有不冲突放置方法。</p>
<p>首先定义一维数组，利用for循环对所有皇后的位置进行初始化。然后开始比较循环。用双层嵌套循环实现皇后的循环比较过程，每完成一次第一层循环将摆好一个皇后，利用二层循环来对单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，该皇后列位置向下移动一格。</p>
<h2 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h2><p>详细内容说明见注释</p>
<pre><code class="c++">while (true) // 开始循坏
    {
        for (int i = 0; i &lt; N; i++) // 一层循环，每次循环完成摆好一个皇后（行循环）
            {
                for (int j = 0 ; j &lt; i ; j++) // 二层循环，单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，列位置向下移动一格
                {
                    if (A[i] &gt;= N) // 皇后超出棋盘
                    {
                        A[i] = 0;
                        A[i - 1]++;
                        i--;
                        j = -1;
                    }
                    else if (!checkQueens(i,j)&amp;&amp;(i != 0)) // 检查皇后是否与已摆好的皇后冲突
                    {
                        A[i]++;
                        j = -1;
                    }
                }
            }
        // 当第一个皇后到达棋盘底端时结束程序
        if (A[0] &gt; N - 1) {
            break;
        }
        for (int e = 0; e &lt; N; e++) // 打印结果
        {
            cout &lt;&lt; &quot;(&quot; &lt;&lt; e &lt;&lt; &quot;,&quot; &lt;&lt; A[e] &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        num++;A[N-1]++;
    }</code></pre>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><p><img src="https://zam9036.gitee.io/img/postimg/%E5%85%AB%E7%9A%87%E5%90%8E%E6%8B%93%E5%B1%95%E2%80%94%E5%88%A9%E7%94%A8DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/1.png" alt="8皇后"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%85%AB%E7%9A%87%E5%90%8E%E6%8B%93%E5%B1%95%E2%80%94%E5%88%A9%E7%94%A8DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/2.png" alt="12皇后"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="循环边界条件不清"><a href="#循环边界条件不清" class="headerlink" title="循环边界条件不清"></a>循环边界条件不清</h3><p>解决方法：对程序进行逐行调试，在运行循环判断时稍事等待，思考判断条件。</p>
<h1 id="使用说明和测试结果"><a href="#使用说明和测试结果" class="headerlink" title="使用说明和测试结果"></a>使用说明和测试结果</h1><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>用Visual Studio打开.sln文件即可运行</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过，符合程序设计要求和需求分析</p>
<p>详细结果见调试分析-示例测试</p>
<h1 id="体会心得"><a href="#体会心得" class="headerlink" title="体会心得"></a>体会心得</h1><p>通过本次课程实验，我对数据结构的了解进一步加深，并产生了浓厚的兴趣。虽然在写代码过程中遇到了一些问题，但我通过思考、网上找资料、询问同学等方式最终解决了问题。这次实验让我进一步理解了深度优先搜索法DFS（回溯法Backtracking Algorithms）技术的原理，锻炼了我静心逐行调试代码的能力，并且熟悉了C++的语法，进一步加强了自学能力，拓展了思路。</p>
<h1 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h1><h2 id="EQ-h"><a href="#EQ-h" class="headerlink" title="EQ.h"></a>EQ.h</h2><pre><code class="c++">#pragma once

#include &lt;iostream&gt; // 导入库
using namespace std; // 使用标准命名空间

#define N 12 // 设置皇后个数

bool checkQueens(int i, int j); // 判断皇后冲突的函数</code></pre>
<h2 id="EightQueens-cpp"><a href="#EightQueens-cpp" class="headerlink" title="EightQueens.cpp"></a>EightQueens.cpp</h2><pre><code class="c++">#include &quot;EQ.h&quot;; // 导入头文件

int A[N]; // 用一维数组代表皇后

int main()
{
    int num = 0; // 解法计数器
    int checknum = 0; // 判断皇后冲突用的数值计数器
    for (int i = 0; i &lt; N; i++) // 初始化皇后位置
    {
        A[i] = 0;
    }
    while (true) // 开始循坏
    {
        for (int i = 0; i &lt; N; i++) // 一层循环，每次循环完成摆好一个皇后（行循环）
            {
                for (int j = 0 ; j &lt; i ; j++) // 二层循环，单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，列位置向下移动一格
                {
                    if (A[i] &gt;= N) // 皇后超出棋盘
                    {
                        A[i] = 0;
                        A[i - 1]++;
                        i--;
                        j = -1;
                    }
                    else if (!checkQueens(i,j)&amp;&amp;(i != 0)) // 检查皇后是否与已摆好的皇后冲突
                    {
                        A[i]++;
                        j = -1;
                    }
                }
            }
        // 当第一个皇后到达棋盘底端时结束程序
        if (A[0] &gt; N - 1) {
            break;
        }
        for (int e = 0; e &lt; N; e++) // 打印结果
        {
            cout &lt;&lt; &quot;(&quot; &lt;&lt; e &lt;&lt; &quot;,&quot; &lt;&lt; A[e] &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        num++;A[N-1]++;
    }
    printf(&quot;%d个皇后，不考虑棋盘对称性，共%d种解法\n&quot;,N,num); // 提示语
    return 0;
}

bool checkQueens(int i ,int j) {
    if ((A[i] + i == A[j] + j) || (A[i] == A[j]) || (A[i] - i == A[j] - j)) // 皇后冲突
    {
        return false;
    }
    else // 皇后不冲突
    {
        return true;
    }
}</code></pre>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/12/03/19-Eight-Queens-Expansion-Using-DFS-Depth-First-Search-Algorithm-to-Solve-N-Queens-Problem">https://zam9036.gitee.io/2019/12/03/19-Eight-Queens-Expansion-Using-DFS-Depth-First-Search-Algorithm-to-Solve-N-Queens-Problem</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>实践项目</tag>
        <tag>课程：数据结构英文C</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-4|Zam9036博客</title>
    <url>/2019/11/24/18-Object-oriented-technical-problem-classification-example-4/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="类和对象的特性"><a href="#类和对象的特性" class="headerlink" title="类和对象的特性"></a>类和对象的特性</h3><h4 id="31、利用面向对象的思想求解长方体体积"><a href="#31、利用面向对象的思想求解长方体体积" class="headerlink" title="31、利用面向对象的思想求解长方体体积"></a>31、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，分别为r1, r2, r3，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求有序输出三个长方体的体积。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/31.jpg" alt="输出样例31"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box r1(a, b, c), r2(d, e, f), r3(g, h, i);
    box arr[3];
    arr[0] = r1;
    arr[1] = r2;
    arr[2] = r3;
    box *bp = arr;
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h4 id="32、构造函数与析构函数"><a href="#32、构造函数与析构函数" class="headerlink" title="32、构造函数与析构函数"></a>32、构造函数与析构函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义圆类Circle，利用类的复合（组合）定义圆柱类Column，然后创建圆柱类Column的实例化对象。</p>
<p>圆类Circle包含两个部分：</p>
<p>一、私有数据：点坐标x，y，半径r。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、area函数：计算圆的面积。</p>
<p>4、print函数：输出点坐标x，y及半径r的值。</p>
<p>圆柱类Column包含两个部分：</p>
<p>一、私有数据：</p>
<p>1、类Circle的对象circle。</p>
<p>2、圆柱高height。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、volume函数：计算圆柱的体积。要求使用circle.area（）。</p>
<p>4、print函数：输出点坐标x，y及半径r的值。</p>
<p>注：圆周率取3.14159</p>
<p>部分代码已在下面给出，要求不能改动已有代码</p>
<pre><code class="c++">int main()
{
Column obj(2.3,3.4,4.5,5.6);
cout&lt;&lt;&quot;The volume of obj is &quot;&lt;&lt;obj.volume()&lt;&lt;endl;
return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/32.jpg" alt="输出样例32"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Circle
{
public:
    Circle(double, double, double);
    ~Circle();
    float area();
    void print();

private:
    double x;
    double y;
    double r;
};

class Column
{
public:
    Column(double, double, double, double);
    ~Column();
    float volume();
    void print();

private:
    Circle circle;
    double height;
};

Circle::Circle(double a, double b, double c)
{
    x = a;
    y = b;
    r = c;
    cout &lt;&lt; &quot;Circle object start:&quot;
         &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

Circle::~Circle()
{
    cout &lt;&lt; &quot;Circle object end:x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

float Circle::area()
{
    return (3.14159 * r * r);
}

void Circle::print()
{
    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

Column::Column(double h, double a, double b, double c) : circle(a, b, c)
{
    height = h;
    cout &lt;&lt; &quot;Column object start:height=&quot; &lt;&lt; height &lt;&lt; &quot;,&quot;;
    circle.print();
}

Column::~Column()
{
    cout &lt;&lt; &quot;Column object end:height=&quot; &lt;&lt; height &lt;&lt; &quot;,&quot;;
    circle.print();
}

float Column::volume()
{
    float m;
    m = circle.area();
    return (m * height);
}

int main()
{
    Column obj(2.3, 3.4, 4.5, 5.6);
    cout &lt;&lt; &quot;The volume of obj is &quot; &lt;&lt; obj.volume() &lt;&lt; endl;
    return 0;
}</code></pre>
<h4 id="33、编写一个音响资料类Media，要求包含音像资料基本信息。"><a href="#33、编写一个音响资料类Media，要求包含音像资料基本信息。" class="headerlink" title="33、编写一个音响资料类Media，要求包含音像资料基本信息。"></a>33、编写一个音响资料类Media，要求包含音像资料基本信息。</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>Media包含两个部分：</p>
<p>一、私有数据：名称name、种类type。</p>
<p>二、公有函数：所有函数要求类外定义 编写一个音响资料类Media，要求包含音像资料基本信息。</p>
<p>Media包含两个部分：</p>
<p>一、私有数据：名称name、种类type。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、setType函数：设置type的值。</p>
<p>4、函数：输出媒体资料的基本信息，要求见下表</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/33-1.jpg" alt="输出样例33-1"></p>
<p>测试函数main如下，要求不能改动main函数：</p>
<pre><code class="c++">#define ISAUDIO 1
#define ISVIDEO 2
int main()
{
 Media discDion(&quot;The Colour of My Love &quot;),discHanks(&quot;Forrest Gump &quot;);
 discDion.setType(ISAUDIO);
 discHanks.setType(ISVIDEO);
 discDion.showInfo ();
 discHanks.showInfo ();
 return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/33-2.jpg" alt="输出样例33-2"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#define ISAUDIO 1
#define ISVIDEO 2
using namespace std;

class Media
{
private:
    string name;
    int type;

public:
    Media();
    Media(string a);
    ~Media();
    void setType(int a);
    void showInfo();
};
Media::Media(string a)
{
    name = a;
}
Media::Media()
{
    name = &quot;&quot;;
    type = 0;
}
Media::~Media()
{
}
void Media::setType(int a)
{
    type = a;
}
void Media::showInfo()
{
    if (type == 1)
        cout &lt;&lt; &quot;The Colour of My Love is a &quot;
             &lt;&lt; &quot;audio disc&quot;
             &lt;&lt; &quot;.&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;Forrest Gumpis a &quot;
             &lt;&lt; &quot;video disc&quot;
             &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}

int main()
{
    Media discDion(&quot;The Colour of My Love &quot;), discHanks(&quot;Forrest Gump &quot;);
    discDion.setType(ISAUDIO);
    discHanks.setType(ISVIDEO);
    discDion.showInfo();
    discHanks.showInfo();
    return 0;
}</code></pre>
<h4 id="34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）"><a href="#34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）" class="headerlink" title="34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）"></a>34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code class="c++">class Rectangle {
private:
    double width, height;
public:
    Rectangle ( double w = 0., double h = 0.) : width(w), height(h) { }
//请补全必要代码
};</code></pre>
<p>使得如下的函数能够正确地按照每个Rectangle对象的面积从小到大进行排序，并且main函数能通过编译且运行后能够得到样例输出。（请将下列代码复制到你补全后的Rectangle类之后，一并提交。）  </p>
<pre><code class="c++">template&lt;typename T&gt;
void insertSort(T *ptr, int size) {
    for(int i = 1; i &lt; size; ++i) {
        for( int j = i; j &gt; 0; --j) {
            if( ptr[j] &lt; ptr[j - 1]) {
                T temp = ptr[j];
                ptr[j ] = ptr[j - 1];
                ptr[j - 1] = temp;
            }
            else
                break;
        }
    }
}

int main () {
    Rectangle data[4];
    data[0] = Rectangle(1,2);
    data[1] = Rectangle(5,7);
    data[2] = Rectangle(2,8);
    data[3] = Rectangle(3,4);
    for(int i = 0; i &lt; 4; ++i) {
           printf(&quot;%f,&quot;, data[i].getArea());
     }
    printf(&quot;\n&quot;);
    insertSort( data, 4);
    for(int i = 0; i &lt; 4; ++i) {
           printf(&quot;%f,&quot;, data[i].getArea());
    }
        return 1;
}</code></pre>
<p>注：模板必须使用<code>template&lt;typename T&gt;</code><br>测试用例：</p>
<pre><code class="c++">//输入：
    Rectangle data[4];
    data[0] = Rectangle(1,2);
    data[1] = Rectangle(5,7);
    data[2] = Rectangle(2,8);
    data[3] = Rectangle(3,4);</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/34.jpg" alt="输出样例34"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class Rectangle
{
private:
    double width, height;

public:
    Rectangle(double w = 0, double h = 0) : width(w), height(h) {}
    double getArea()
    {
        return width * height;
    }
    friend bool operator&lt;(Rectangle a, Rectangle b)
    {
        if (a.getArea() &gt; b.getArea())
            return 0;
        else
            return 1;
    }
};

template &lt;typename T&gt;
void insertSort(T *ptr, int size)
{
    for (int i = 1; i &lt; size; ++i)
    {
        for (int j = i; j &gt; 0; --j)
        {
            if (ptr[j] &lt; ptr[j - 1])
            {
                T temp = ptr[j];
                ptr[j] = ptr[j - 1];
                ptr[j - 1] = temp;
            }
            else
                break;
        }
    }
}

int main()
{
    Rectangle data[4];
    data[0] = Rectangle(1, 2);
    data[1] = Rectangle(5, 7);
    data[2] = Rectangle(2, 8);
    data[3] = Rectangle(3, 4);
    for (int i = 0; i &lt; 4; ++i)
    {
        printf(&quot;%f,&quot;, data[i].getArea());
    }
    printf(&quot;\n&quot;);
    insertSort(data, 4);
    for (int i = 0; i &lt; 4; ++i)
    {
        printf(&quot;%f,&quot;, data[i].getArea());
    }
    return 0;
}</code></pre>
<h4 id="35、通过重载运算符来模拟时间"><a href="#35、通过重载运算符来模拟时间" class="headerlink" title="35、通过重载运算符来模拟时间"></a>35、通过重载运算符来模拟时间</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个Time类，包含数据成员minute（分）和sec（秒），模拟秒表，每次走一秒，满60秒进一分钟，此时秒又从0起算，要求输出分和秒的值。</p>
<p>已有如下的main函数，要求编写能支持该main函数的Time类。</p>
<pre><code class="c++">int main()
{
    Time time1(34,50);
    for(int i = 0; i &lt; 20; i++)
    {
        ++time1;
        time1.display();
    }
    return 0;
}</code></pre>
<pre><code class="控制台">//输出样例35
34:51
34:52
34:53
34:54
34:55
34:56
34:57
34:58
34:59
35:0
35:1
35:2
35:3
35:4
35:5
35:6
35:7
35:8
35:9
35:10</code></pre>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Time
{
private:
    int minute, sec;

public:
    Time(int a, int b)
    {
        if (b &gt; 59)
        {
            minute = a + 1;
            sec = b - 60;
        }
        else
        {
            minute = a;
            sec = b;
        }
    }
    Time()
    {
        minute = 0;
        sec = 0;
    }
    void display()
    {
        cout &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; sec &lt;&lt; endl;
    }
    friend operator++(Time &amp;a)
    {
        a.sec++;
        if (a.sec &gt; 59)
        {
            a.minute = a.minute + 1;
            a.sec = a.sec - 60;
        }
    }
};

int main()
{
    Time time1(34, 50);
    for (int i = 0; i &lt; 20; i++)
    {
        ++time1;
        time1.display();
    }
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/24/18-Object-oriented-technical-problem-classification-example-4">https://zam9036.gitee.io/2019/11/24/18-Object-oriented-technical-problem-classification-example-4</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-3|Zam9036博客</title>
    <url>/2019/11/20/17-Object-oriented-technical-problem-classification-example-3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h3><h4 id="21、定义复数类，并使用运算符重载来实现其功能"><a href="#21、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="21、定义复数类，并使用运算符重载来实现其功能"></a>21、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符+，使之能用于复数的加法。运算符的重载函数作为Complex类的成员函数，求两个复数的和。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/21.jpg" alt="输出样例21"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 + c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="22、重载运算符使之能进行复数的运算"><a href="#22、重载运算符使之能进行复数的运算" class="headerlink" title="22、重载运算符使之能进行复数的运算"></a>22、重载运算符使之能进行复数的运算</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>下面是一个用来表达复数的类Complex的部分代码.该类包含两个私有double型成员变量，分别代表复数的实部和虚部，默认为0。</p>
<pre><code class="c++">class Complex {
private:
    double real;
    double img;
public:
//..
Complex operator + (const Complex &amp; other) //….
};</code></pre>
<p>请按要求补全该类其他代码。</p>
<p>该类需有完备的类构造函数，至少支持Complex a; Complex b(a); Complex c(4, 5); 这三种定义Complex类对象的方式。重载操作符+, +=, <em>, 分别完成两个复数的加法和乘法，其中操作符</em>的重载必须用友元函数的形式完成。</p>
<p>补全该类后，对于如下的main函数，要求其能通过编译，并正常运行。</p>
<pre><code class="c++">int main () {
    Complex c2(2., 3.), c3 = c2 + Complex(1., 2.),c1(c2);
    Complex c4;
    c4 += c2 * c3 + c2;
    cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; c3 &lt;&lt; c4;
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/22.jpg" alt="输出样例22"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Complex
{
private:
    double real;
    double img;

public:
    Complex(double real = 0, double img = 0);
    Complex(const Complex &amp;c2)
    {
        real = c2.real;
        img = c2.img;
    }
    Complex operator+(const Complex &amp;other)
    {
        Complex c;
        c.real = real + other.real;
        c.img = img + other.img;
        return c;
    }
    Complex operator+=(const Complex &amp;c1)
    {
        *this = *this + c1;
        return *this;
    }
    friend Complex operator*(Complex &amp;c1, Complex &amp;c2)
    {
        return Complex((c1.real * c2.real - c1.img * c2.img), (c1.img * c2.real + c1.real * c2.img));
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, Complex &amp;c)
    {
        if (c.img &gt;= 0)
            output &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.img &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c.real &lt;&lt; c.img &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};
Complex::Complex(double a, double b)
{
    real = a;
    img = b;
}
int main()
{
    Complex c2(2., 3.), c3 = c2 + Complex(1., 2.), c1(c2);
    Complex c4;
    c4 += c2 * c3 + c2;
    cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; c3 &lt;&lt; c4;
    return 0;
}</code></pre>
<h3 id="类和对象的特性"><a href="#类和对象的特性" class="headerlink" title="类和对象的特性"></a>类和对象的特性</h3><h4 id="23、将普通函数声明为友元并使用它输出日期与时间"><a href="#23、将普通函数声明为友元并使用它输出日期与时间" class="headerlink" title="23、将普通函数声明为友元并使用它输出日期与时间"></a>23、将普通函数声明为友元并使用它输出日期与时间</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>顺序定义时间类Time与日期类Date。其中，Time拥有私有数据hour, minute, second，以及友元函数display；Date拥有私有数据day, month, year，以及友元函数display。在类外定义display函数并实现它，display函数接收一个Time类和一个Date类的引用，并将其按照格式输出。 运行时依次从键盘输入day, month, year,hour, minute, second，最后调用display函数将其全部按格式输出。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/23.jpg" alt="输出样例23"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Date;
class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    friend void display(Date &amp;d, Time &amp;t);
};
class Date
{
private:
    int day, month, year;

public:
    Date(int a, int b, int c)
    {
        day = a;
        month = b;
        year = c;
    }
    friend void display(Date &amp;d, Time &amp;t);
};

void display(Date &amp;d, Time &amp;t)
{
    cout &lt;&lt; d.day &lt;&lt; &quot;/&quot; &lt;&lt; d.month &lt;&lt; &quot;/&quot; &lt;&lt; d.year &lt;&lt; &quot;&quot; &lt;&lt; t.hour &lt;&lt; &quot;:&quot; &lt;&lt; t.minute &lt;&lt; &quot;:&quot; &lt;&lt; t.second &lt;&lt; endl;
}

int main()
{
    int a, b, c, d, e, f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;
    Time t(d, e, f);
    Date dd(a, b, c);
    display(dd, t);
    return 0;
}</code></pre>
<h4 id="24、使用友元成员函数输出日期与时间"><a href="#24、使用友元成员函数输出日期与时间" class="headerlink" title="24、使用友元成员函数输出日期与时间"></a>24、使用友元成员函数输出日期与时间</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>顺序声明时间类Time与日期类Date。其中Time拥有私有数据hour, minute, second，以及公有函数display(接收一个Date的引用作为参数)；Date拥有私有数据day, month, year，以及友元函数display(要求声明Time中的display函数为Date的友元成员函数)。运行时依次从键盘输入day, month, year,hour, minute, second，最后调用Time的display函数将其全部按格式输出。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/24.jpg" alt="输出样例24"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Date;
class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    void display(Date &amp;t);
};
class Date
{
private:
    int day, month, year;

public:
    Date(int a, int b, int c)
    {
        day = a;
        month = b;
        year = c;
    }
    friend void Time::display(Date &amp;);
};

void Time::display(Date &amp;t)
{
    cout &lt;&lt; t.day &lt;&lt; &quot;/&quot; &lt;&lt; t.month &lt;&lt; &quot;/&quot; &lt;&lt; t.year &lt;&lt; &quot;&quot; &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; endl;
}

int main()
{
    int a, b, c, d, e, f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;
    Time t(d, e, f);
    Date dd(a, b, c);
    t.display(dd);
    return 0;
}</code></pre>
<h4 id="25、使用友元函数输出时间"><a href="#25、使用友元函数输出时间" class="headerlink" title="25、使用友元函数输出时间"></a>25、使用友元函数输出时间</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一时间类Time，拥有私有成员hour, minute, second，以及一友元函数display。display以引用的方式接收一个Time对象，并以hour:minute:second的格式来输出时间。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/25.jpg" alt="输出样例25"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    friend void display(Time &amp;t)
    {
        cout &lt;&lt; t.hour &lt;&lt; &quot;:&quot; &lt;&lt; t.minute &lt;&lt; &quot;:&quot; &lt;&lt; t.second;
    }
};

int main()
{
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    Time t(a, b, c);
    display(t);
    return 0;
}</code></pre>
<h4 id="26、使用指针传参找到成绩最高的学生"><a href="#26、使用指针传参找到成绩最高的学生" class="headerlink" title="26、使用指针传参找到成绩最高的学生"></a>26、使用指针传参找到成绩最高的学生</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(共5人，其类名为Student)的数据需要存放，包括私有数据成绩(名为score)，数据从键盘输入。要求使用名为arr的对象静态数组存放这5个学生的数据，并使用名为sp的对象指针指向其对象数组的首地址（要求使用取地址符），最后将该指针传递给max函数(指针在max中的形参名为p)，找出5个学生中成绩最高者并输出其成绩。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/26.jpg" alt="输出样例26"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    friend Student max(Student *p);
    void display()
    {
        cout &lt;&lt; score;
    }
};

Student max(Student *p)
{
    Student s;
    for (int i; i &lt; 5; i++, p++)
        if (s.score &lt; p-&gt;score)
        {
            s = *p;
        }
    return s;
}

int main()
{
    int a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
    Student s1(a), s2(b), s3(c), s4(d), s5(e);
    Student arr[5];
    arr[0] = s1;
    arr[1] = s2;
    arr[2] = s3;
    arr[3] = s4;
    arr[4] = s5;
    Student *sp;
    sp = &amp;arr[0];
    Student aa = max(sp);
    aa.display();
    return 0;
}</code></pre>
<h4 id="27、用指针输出学生信息"><a href="#27、用指针输出学生信息" class="headerlink" title="27、用指针输出学生信息"></a>27、用指针输出学生信息</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(共5人，其类名为Student)的数据需要存放，包括私有数据成绩(名为score)，数据从键盘输入。要求使用名为arr的对象数组（要求动态分配）存放这5个学生的数据，并使用名为sp的对象指针指向其对象数组的首地址（要求使用取地址符），随后有序输出第1、3、5个学生的数据。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/27.jpg" alt="输出样例27"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    void display()
    {
        cout &lt;&lt; score &lt;&lt; &quot; &quot;;
    }
};

int main()
{
    int a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
    Student s1(a), s2(b), s3(c), s4(d), s5(e);
    Student *arr = new Student[5];
    if (!arr)
        cout &lt;&lt; &quot;内存分配失败&quot;;
    else
    {
        arr[0] = s1;
        arr[1] = s2;
        arr[2] = s3;
        arr[3] = s4;
        arr[4] = s5;
        Student *sp;
        sp = &amp;arr[0];
        sp-&gt;display();
        (sp + 2)-&gt;display();
        (sp + 4)-&gt;display();
        delete[] sp;
        sp = NULL;
    }
    return 0;
}</code></pre>
<h4 id="28、统计学生平均成绩，要求使用静态成员函数"><a href="#28、统计学生平均成绩，要求使用静态成员函数" class="headerlink" title="28、统计学生平均成绩，要求使用静态成员函数"></a>28、统计学生平均成绩，要求使用静态成员函数</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(其类名为Student)成绩(均为整数)需要统计，要求使用类内静态公有函数(函数名为average)求出这批学生的平均成绩(学生人数并不确定)。在输入成绩时，先输入一个整数，表示学生总人数，然后再输入相应个数学生成绩，并将这些数据都存入一个名为arr的数组中,该数组必须使用new动态开辟，最后输出学生的平均成绩。(结果要求保留1位小数，检测内存分配是否成功需使用NULL)</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/28.jpg" alt="输出样例28"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    int get()
    {
        return score;
    }
    static float average(int n, Student arr[])
    {
        int a;
        for (int i = 0; i &lt; n; i++)
        {
            a += arr[i].get();
        }
        return (float)a / n;
    }
};

int main()
{
    int a, b;
    cin &gt;&gt; a;
    Student *arr = new Student[a];
    for (int i; i &lt; a; i++)
    {
        cin &gt;&gt; b;
        arr[i] = Student(b);
    }
    if (arr == NULL)
        cout &lt;&lt; &quot;xx&quot;;
    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1);
    cout &lt;&lt; Student::average(a, arr);

    delete arr;
    return 0;
}</code></pre>
<h4 id="29、利用面向对象的思想求解长方体体积"><a href="#29、利用面向对象的思想求解长方体体积" class="headerlink" title="29、利用面向对象的思想求解长方体体积"></a>29、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，存储在一个名为arr的静态对象数组中，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求使用名为bp的指针指向这个数组的首地址（要求使用数组名），并有序输出三个长方体的体积，体积的计算须使用volume函数。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/29.jpg" alt="输出样例29"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box a1(a, b, c), a2(d, e, f), a3(g, h, i);
    box arr[3];
    arr[0] = a1;
    arr[1] = a2;
    arr[2] = a3;
    box *bp = arr;
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h4 id="30、利用面向对象的思想求解长方体体积"><a href="#30、利用面向对象的思想求解长方体体积" class="headerlink" title="30、利用面向对象的思想求解长方体体积"></a>30、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，存储在一个名为arr的静态对象数组中，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求有序输出三个长方体的体积。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/30.jpg" alt="输出样例30"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box a1(a, b, c), a2(d, e, f), a3(g, h, i);
    box arr[3];
    arr[0] = a1;
    arr[1] = a2;
    arr[2] = a3;
    box *bp;
    bp = &amp;arr[0];
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/20/17-Object-oriented-technical-problem-classification-example-3">https://zam9036.gitee.io/2019/11/20/17-Object-oriented-technical-problem-classification-example-3</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHubPages个人博客迁移至码云从而加快博客访问速度|Zam9036博客</title>
    <url>/2019/11/16/16-GitHubPages-personal-blog-migrates-to-mayun-to-speed-blog-access/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GitHubPages部署静态网页十分方便与快捷，常常被用来建立个人博客。但因为其服务器设在国外，且曾经被中国防火长城GFW屏蔽（后来解除屏蔽），导致其访问速度十分缓慢，甚至极少数状态下出现访问出错的状况，极大影响了博客的使用体验。所以我近期尝试将GitHub的Hexo博客迁移至国内码云，以解决博客访问过于缓慢的情况。</p>
<h2 id="迁移流程"><a href="#迁移流程" class="headerlink" title="迁移流程"></a>迁移流程</h2><h3 id="建立码云仓库"><a href="#建立码云仓库" class="headerlink" title="建立码云仓库"></a>建立码云仓库</h3><p>创建码云账号的流程我在此就不过多赘述了，根据提示操作即可，下面我来说一下建立码云仓库的操作。码云的仓库建立机制和GitHub一样，只需要新建仓库然后填写信息即可，其中仓库名字尤为关键。码云的静态资源托管平台可以托管用户的任意仓库，不必像GitHub那样仓库名必须和用户名一致才可。用户创建任意仓库，然后点击<code>服务-GiteePages</code>即可开启该仓库的静态资源托管服务。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/1.jpg" alt="开启Page服务"></p>
<p>但是！在这里建议大家仓库名仍使用和自己码云用户名相同的名称！！因为当博客仓库名与自己的个性地址不一致时，博客部署完成后会存在一些资源访问404。原因是当需要部署的仓库和自己的个性地址不一致时，如：<a href="https://gitee.com/ipvb/blog" target="_blank" rel="noopener">https://gitee.com/ipvb/blog</a> ，生成的pages url 为 <a href="https://ipvb.gitee.io/blog" target="_blank" rel="noopener">https://ipvb.gitee.io/blog</a> ，而访问的资源404，如 <a href="https://ipvb.gitee.io/style.css" target="_blank" rel="noopener">https://ipvb.gitee.io/style.css</a> 这是相应配置文件的相对路径存在问题导致的，生成的资源 url 应该为 <a href="https://ipvb.gitee.io/blog/style.css" target="_blank" rel="noopener">https://ipvb.gitee.io/blog/style.css</a> 才对。 而针对这个问题官方给出了解决方案。</p>
<blockquote>
<p>对于不同的静态资源生成器，配置如下： </p>
<ul>
<li><p>Hugo 配置文件config.toml的baseURL修改如下</p>
<pre><code>baseURL = &quot;https://ipvb.gitee.io/blog&quot;</code></pre></li>
<li><p>Hexo 配置文件_config.yml的url和root修改如下：</p>
<pre><code>url: https://ipvb.gitee.io/blog
root: /blog</code></pre></li>
<li><p>Jekyll配置文件_config.yml的baseurl修改如下：</p>
<pre><code>baseurl: &quot;/blog&quot; # the subpath of your site, e.g. /blog</code></pre></li>
</ul>
</blockquote>
<p>但是！！按照这个做法，博客的Js等文件能够加载，本地的图片等文件无法加载，设置完成后点击图片会按照未修改的链接跳转导致404。</p>
<p>所以多一事不如少一事，我们直接创建一个和用户名相同的仓库，这样就可以直接跳过二级目录，通过<code>用户名.gitee.io</code>直接访问博客。</p>
<p>另外，码云的静态资源托管功能可以托管Jekyll、Hugo、Hexo编译的静态资源。</p>
<blockquote>
<p>Jekyll、Hugo、Hexo 编译判断依据</p>
<ol>
<li>编译 Hugo 依据：仓库编译目录下存在<code>config.toml|json|yaml</code>文件和<code>content</code>目录的时候，会使用<code>hugo</code>生成静态文件。</li>
<li>编译 Hexo 依据：仓库编译目录下存在<code>package.json</code>，<code>_config.yml</code>文件和<code>scaffolds</code>目录的，会使用<code>hexo generate</code>生成静态文件，由于每次部署编译需要重新克隆编译并进行<code>npm install</code>，所以使用 Hexo 的时间相对 Hugo 和 Jekyll 会长一些。</li>
<li>当不符合上述1和2条件的时候，就默认使用Jekyll编译。</li>
</ol>
</blockquote>
<h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><p>与GitHub配置SSH一致，遇有疑问请访问<a href="https://zam9036.gitee.io/2019/10/23/利用GitHub+Hexo搭建个人博客详细教程">利用GitHub+Hexo搭建个人博客详细教程</a>。当然，使用当时GitHub建立的SSH就可以。</p>
<h3 id="修改Hexo配置"><a href="#修改Hexo配置" class="headerlink" title="修改Hexo配置"></a>修改Hexo配置</h3><p>找到Hexo配置文件_config.yml，注意不是主题配置文件。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/2.jpg" alt="Hexo配置文件"></p>
<p>找到以下语句</p>
<pre><code class="yml"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:</code></pre>
<p>修改为</p>
<pre><code class="yml"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repository: git@gitee.com:zam9036/zam9036.git
  branch: master</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/3.png" alt="修改Hexo配置文件"></p>
<p>注意，<code>repository:</code>处的内容可以在码云平台上找到</p>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/4.png" alt="码云平台"></p>
<p>至此，配置文件修改完毕，博客迁移完毕。</p>
<h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><p>按照上面流程迁移完毕后，写好博客，执行<code>hexo g</code>然后执行<code>hexo d</code>即可上传博客代码到码云服务器。与GitHub不同，码云需要手动部署博客，找到博客仓库，点击Pages服务，如图点击更新按钮即可部署。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/5.png" alt="更新部署博客"></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/16/16-GitHubPages-personal-blog-migrates-to-mayun-to-speed-blog-access">https://zam9036.gitee.io/2019/11/16/16-GitHubPages-personal-blog-migrates-to-mayun-to-speed-blog-access</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Hexo博客安装hexo-generator-search遇到的问题|Zam9036博客</title>
    <url>/2019/11/13/15-Record-the-problems-encountered-by-Hexo-blog-installation-hexo-generator-search/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在用Git bash安装<code>hexo-generator-search</code>和<code>hexo-generator-searchdb</code>来实现本地搜索时遇到以下问题</p>
<pre><code class="bash">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.1 (node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.1: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\nunjucks\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})

+ hexo-generator-search@2.4.0
updated 1 package and audited 7064 packages in 7.194s
found 0 vulnerabilities</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="问题描述"></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>查阅资料得知，出现这样的原因是：fsevents不在package.json里，但是仍然安装了，是因为本机系统是Windows系统，而fsevents是苹果系统的可选依赖，博客主题作者可能是Mac电脑，所以作者在他的Mac上安装了fsevents相关依赖库，到本机也就自动安装到本机windows上边了。</p>
<p>既然Git bash不成，来尝试一下Windows的命令提示符cmd。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="cmd1"></p>
<p>出现了新的问题.. 根据错误提示，是系统没有“package.json”这个文件导致。这个文件的作用就是管理你本地安装的npm包。此刻我们需要执行命令<code>npm init</code>创建package.json文件，系统会提示相关配置；或者可以使用命令：</p>
<pre><code>npm init -y</code></pre><p>直接创建package.json文件，这样创建的json文件的必填项已经帮你填好，执行完命令后我们可以看到用户路径下多了一个package.json文件。</p>
<p>在此我们选择第二种创建json文件的方式。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/3.png" alt="创建json文件"></p>
<p>然后我们再次在cmd上执行命令</p>
<pre><code class="cmd">npm install hexo-generator-search --save
npm install hexo-generator-searchdb --save</code></pre>
<p>依然提示Warning，但此时已经没有<code>SAVEERROR</code>，我们选择忽略Warning。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/4.png" alt="cmd2"></p>
<p>在博客根目录配置 <code>_config.yml</code> 里面添加hexo-generator-search的配置</p>
<pre><code class="yml">search:
  path: search.xml
  field: post    //post代表仅搜索博客文章，page代表搜索页面，all代表全部搜索
  content: true
  limit: 9999    //输入搜索字符上限</code></pre>
<p>重新生成静态文件</p>
<pre><code class="bash">hexo clean &amp;&amp; hexo g</code></pre>
<p>然后上传代码，发现问题解决！！！</p>
<h2 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a>问题拓展</h2><p>本篇博客仅记录安装hexo-generator-search时遇到的问题，如需实现博客本地搜索功能，请查看<a href="https://www.jianshu.com/p/685bf59cde5e" target="_blank" rel="noopener">参考</a></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/13/15-Record-the-problems-encountered-by-Hexo-blog-installation-hexo-generator-search">https://zam9036.gitee.io/2019/11/13/15-Record-the-problems-encountered-by-Hexo-blog-installation-hexo-generator-search</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序中序后续递归与非递归遍历及左右子树交换|Zam9036博客</title>
    <url>/2019/11/09/14-Pre-order-mid-order-subsequent-recursion-and-non-recursive-traversal-of-binary-tree-and-left-and-right-subtree-exchange/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>​    C++</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>​    熟悉C++语法，了解树的概念，掌握二叉树的运算及应用，了解前序中序后序遍历二叉树的递归/非递归原理，能够实现将二叉树左右子树结点交换。</p>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>生成一棵以二叉链表存储的二叉树（至少15个结点）</p>
<p>分别用递归和非递归的方法前序、中序、后序遍历该二叉树，并打印各结点信息</p>
<p>编写算法，交换该二叉树上所有结点的左右子树，并打印交换后各结点的信息</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="程序要求"><a href="#程序要求" class="headerlink" title="程序要求"></a>程序要求</h3><p>​    生成一棵不少于15结点的二叉树，用二叉链表存储该二叉树。编写算法，利用递归算法实现该二叉树的前序中序后序遍历，并打印交换后各结点的信息。编写算法，利用非递归算法实现该二叉树的前序中序后序遍历，并打印交换后各结点的信息。编写算法，交换该二叉树上所有结点的左右子树，并打印交换后各结点的信息。</p>
<h3 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h3><p>​    生成二叉树，递归/非递归的前中后序遍历二叉树，交换二叉树上所有结点的左右子树</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><p>​    定义一个节点（结点）类，类中有三种公有信息：<code>char</code>型的data用来存储当前节点的数据，两个<code>node*</code>指针型用来分别指向当前节点的左孩子和右孩子。</p>
<pre><code class="c++">//定义节点类
class node
{
public:
    int data;    //节点信息
    node* leftChild;//节点指针：左孩子
    node* rightChild;//节点指针：右孩子
};
typedef node* BiTree;//等价，定义node*的新名字BiTree</code></pre>
<p>​    创建结点的方法：</p>
<pre><code class="c++">//创建节点，加*号的意义：返回类型指针型数据
node* createNode(int value)
{
    node* q = new node;
    q-&gt;leftChild = NULL;    //leftChild指针为空
    q-&gt;rightChild = NULL;    //rightChild指针为空
    q-&gt;data = value;    //节点值等于value
    return q;    //返回节点
}</code></pre>
<p>​    建立二叉树的方法（提供两种方法，一种使用默认28节点的二叉树，一种通过调节N的自左向右输入节点值来建立二叉树）</p>
<pre><code class="c++">//建立二叉树
BiTree createBiTree()
{
    node* p[N] = { NULL };
    //int array[28] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27 };//默认建立28节点二叉树
    //自左向右输入节点值生成二叉树
    cout&lt;&lt;&quot;请按自左向右顺序输入二叉树各节点:&quot;&lt;&lt;endl;    //提示语
    int array[N];    //定义array数组用于存储节点信息
    for (int i = 0; i &lt; N; ++i){
        cin &gt;&gt; array[i];    //储存输入节点的值
    }
    for (int i = 0; i &lt; N; ++i)
        p[i] = createNode(array[i]);    //创建节点
    for (int i = 0; i &lt; N / 2; i++)
    {
        p[i]-&gt;leftChild = p[i * 2 + 1];    //赋予每个节点左孩子指针
        p[i]-&gt;rightChild = p[i * 2 + 2];    //赋予每个节点右孩子指针
    }
    return p[0];
}</code></pre>
<p>​    访问节点数据</p>
<pre><code class="c++">//访问节点中的数据
int visit(BiTree tree)
{
    return tree-&gt;data;    //返回节点的值
}</code></pre>
<h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归前序遍历
void preorderBiTree(BiTree tree)
{
    if (tree)
    {
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;    //打印当前节点值
        preorderBiTree(tree-&gt;leftChild);    //遍历左孩子
        preorderBiTree(tree-&gt;rightChild);    //没有左孩子时，遍历右孩子
    }
}</code></pre>
<h6 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h6><pre><code class="c++">// 非递归前序遍历
void preorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;    //创建节点
    stack&lt;BiTree&gt; nodes;    //创建节点栈
    while (node || !nodes.empty()) {    //当节点栈为空或节点为NULL时结束循环
        while (node != NULL) {    //当左孩子不为空时
            nodes.push(node);    //节点入栈
            cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;    //打印节点
            node = node-&gt;leftChild;    //指向当前节点左孩子
        }
        node = nodes.top();    //回溯到父节点
        nodes.pop();    //父节点出栈
        node = node-&gt;rightChild;    //指向父节点右孩子
    }
}</code></pre>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><h6 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归中序遍历
void inorderBiTree(BiTree tree)
{
    if (tree)
    {
        inorderBiTree(tree-&gt;leftChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
        inorderBiTree(tree-&gt;rightChild);
    }
}</code></pre>
<h6 id="非递归法-1"><a href="#非递归法-1" class="headerlink" title="非递归法"></a>非递归法</h6><pre><code class="c++">// 非递归中序遍历
void inorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;
    stack&lt;BiTree&gt; nodes;
    while (node || !nodes.empty()) {
        while (node != NULL) {
            nodes.push(node);
            node = node-&gt;leftChild;
        }
        node = nodes.top();
        cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;
        nodes.pop();
        node = node-&gt;rightChild;
    }
}</code></pre>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><h6 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归后序遍历
void postorderBiTree(BiTree tree)
{
    if (tree)
    {
        postorderBiTree(tree-&gt;leftChild);
        postorderBiTree(tree-&gt;rightChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
    }
}</code></pre>
<h6 id="非递归法-2"><a href="#非递归法-2" class="headerlink" title="非递归法"></a>非递归法</h6><p>​    待解决….</p>
<p>​    如有需要<a href="https://www.xuebuyuan.com/3224992.html" target="_blank" rel="noopener">请移步</a>查看</p>
<h4 id="交换二叉树左右子树"><a href="#交换二叉树左右子树" class="headerlink" title="交换二叉树左右子树"></a>交换二叉树左右子树</h4><pre><code class="c++">//递归交换二叉树中的左右子树
void exchange(BiTree tree)
{
    BiTree temp;    //创建中间二叉树
    if (tree) {
        temp = tree-&gt;leftChild;    //中间二叉树储存所需交换二叉树的左孩子
        tree-&gt;leftChild = tree-&gt;rightChild;    //将所需交换二叉树右孩子的值赋予左孩子
        tree-&gt;rightChild = temp;    //将中间二叉树储存的值赋予所需交换二叉树右孩子
        //类似于a,b两个数互换值，取中间变量c
        exchange(tree-&gt;leftChild);    //递归交换左孩子的值
        exchange(tree-&gt;rightChild);    //没有左孩子时，递归交换右孩子的值
    }
}</code></pre>
<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><p><img src="https://zam9036.gitee.io/img/postimg/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%AD%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%8F%8A%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E4%BA%A4%E6%8D%A2/1.png" alt="6节点二叉树"><br><img src="https://zam9036.gitee.io/img/postimg/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%AD%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%8F%8A%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E4%BA%A4%E6%8D%A2/2.png" alt="15节点二叉树"></p>
<h2 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h2><pre><code class="c++">
#include &lt;iostream&gt;    //导入IO库文件
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;stack&gt;
#define N 15    //N为节点数
using namespace std;    //使用标准命名空间

//定义节点类
class node
{
public:
    int data;    //节点信息
    node* leftChild;//节点指针：左孩子
    node* rightChild;//节点指针：右孩子
};
typedef node* BiTree;//等价，定义node*的新名字BiTree

//创建节点，加*号的意义：返回类型指针型数据
node* createNode(int value)
{
    node* q = new node;
    q-&gt;leftChild = NULL;    //leftChild指针为空
    q-&gt;rightChild = NULL;    //rightChild指针为空
    q-&gt;data = value;    //节点值等于value
    return q;    //返回节点
}

//建立二叉树
BiTree createBiTree()
{
    node* p[N] = { NULL };
    //int array[28] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27 };//默认建立28节点二叉树
    //自左向右输入节点值生成二叉树
    cout&lt;&lt;&quot;请按自左向右顺序输入二叉树各节点:&quot;&lt;&lt;endl;    //提示语
    int array[N];    //定义array数组用于存储节点信息
    for (int i = 0; i &lt; N; ++i){
        cin &gt;&gt; array[i];    //储存输入节点的值
    }
    for (int i = 0; i &lt; N; ++i)
        p[i] = createNode(array[i]);    //创建节点
    for (int i = 0; i &lt; N / 2; i++)
    {
        p[i]-&gt;leftChild = p[i * 2 + 1];    //赋予每个节点左孩子指针
        p[i]-&gt;rightChild = p[i * 2 + 2];    //赋予每个节点右孩子指针
    }
    return p[0];
}

//访问节点中的数据
int visit(BiTree tree)
{
    return tree-&gt;data;    //返回节点的值
}

//递归交换二叉树中的左右子树
void exchange(BiTree tree)
{
    BiTree temp;    //创建中间二叉树
    if (tree) {
        temp = tree-&gt;leftChild;    //中间二叉树储存所需交换二叉树的左孩子
        tree-&gt;leftChild = tree-&gt;rightChild;    //将所需交换二叉树右孩子的值赋予左孩子
        tree-&gt;rightChild = temp;    //将中间二叉树储存的值赋予所需交换二叉树右孩子
        //类似于a,b两个数互换值，取中间变量c
        exchange(tree-&gt;leftChild);    //递归交换左孩子的值
        exchange(tree-&gt;rightChild);    //没有左孩子时，递归交换右孩子的值
    }
}

// 递归前序遍历
void preorderBiTree(BiTree tree)
{
    if (tree)
    {
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;    //打印当前节点值
        preorderBiTree(tree-&gt;leftChild);    //遍历左孩子
        preorderBiTree(tree-&gt;rightChild);    //没有左孩子时，遍历右孩子
    }
}

// 非递归前序遍历
void preorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;    //创建节点
    stack&lt;BiTree&gt; nodes;    //创建节点栈
    while (node || !nodes.empty()) {    //当节点栈为空或节点为NULL时结束循环
        while (node != NULL) {    //当左孩子不为空时
            nodes.push(node);    //节点入栈
            cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;    //打印节点
            node = node-&gt;leftChild;    //指向当前节点左孩子
        }
        node = nodes.top();    //回溯到父节点
        nodes.pop();    //父节点出栈
        node = node-&gt;rightChild;    //指向父节点右孩子
    }
}

// 递归中序遍历
void inorderBiTree(BiTree tree)
{
    if (tree)
    {
        inorderBiTree(tree-&gt;leftChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
        inorderBiTree(tree-&gt;rightChild);
    }
}

// 非递归中序遍历
void inorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;
    stack&lt;BiTree&gt; nodes;
    while (node || !nodes.empty()) {
        while (node != NULL) {
            nodes.push(node);
            node = node-&gt;leftChild;
        }
        node = nodes.top();
        cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;
        nodes.pop();
        node = node-&gt;rightChild;
    }
}

// 递归后序遍历
void postorderBiTree(BiTree tree)
{
    if (tree)
    {
        postorderBiTree(tree-&gt;leftChild);
        postorderBiTree(tree-&gt;rightChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
    }
}

// 非递归后序遍历
void postorderBiTreeNonRecursive(BiTree tree) {
    cout &lt;&lt; &quot;待解决...&quot; &lt;&lt; endl;
}

int main()
{
    BiTree tree = createBiTree();
    cout &lt;&lt; &quot;前序递归遍历结果为:&quot;;
    preorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;前序非递归遍历结果为:&quot;;
    preorderBiTreeNonRecursive(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;中序遍历结果为:&quot;;
    inorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;中序非递归遍历结果为:&quot;;
    inorderBiTreeNonRecursive(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;后序遍历结果为:&quot;;
    postorderBiTree(tree);
    cout &lt;&lt; endl;
    exchange(tree);
    cout &lt;&lt; endl &lt;&lt; &quot;左右子树已交换&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后前序遍历结果为:&quot;;
    preorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后中序遍历结果为:&quot;;
    inorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后后序遍历结果为:&quot;;
    postorderBiTree(tree);
    cout &lt;&lt; endl;
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/09/14-Pre-order-mid-order-subsequent-recursion-and-non-recursive-traversal-of-binary-tree-and-left-and-right-subtree-exchange">https://zam9036.gitee.io/2019/11/09/14-Pre-order-mid-order-subsequent-recursion-and-non-recursive-traversal-of-binary-tree-and-left-and-right-subtree-exchange</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>实践项目</tag>
        <tag>课程：数据结构英文C</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-2|Zam9036博客</title>
    <url>/2019/11/06/13-Object-oriented-technical-problem-classification-example-2/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h3><h4 id="11、多重继承派生类的构造函数"><a href="#11、多重继承派生类的构造函数" class="headerlink" title="11、多重继承派生类的构造函数"></a>11、多重继承派生类的构造函数</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>声明一个教师(Teacher)类和一个学生(Student)类，用公有多重继承的方式声明一个在职研究生(Graduate)派生类，包含私有成员wages(津贴)。教师类中包含保护数据成员name(姓名)、age(年龄)、title(职称)。学生类中包含保护数据成员name1(姓名)、sex(性别)、score(成绩)。在定义派生类对象时给出初始化的数据，然后输出这些数据。</p>
<p>要求Teacher与Student类的数据成员都在自己的构造函数内初始化，新建Graduate对象时，Graduate应通过自身的构造函数去依次调用Teacher与Student的构造函数及其他。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Graduate grad1(&quot;Johnson&quot;, 21, &quot;male&quot;, &quot;assistant&quot;, 90, 7800);
    grad1.show();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/11.jpg" alt="输出样例11"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Teacher
{
public:
    Teacher(string nam, int a, string tit) : name(nam), age(a), title(tit) {}

protected:
    string name;
    int age;
    string title;
};
class Student
{
public:
    Student(string nam, string s, int sco) : name1(nam), sex(s), score(sco) {}

protected:
    string name1;
    string sex;
    int score;
};
class Graduate : public Teacher, public Student
{
public:
    Graduate(string nam, int a, string s, string tit, int sco, int w) : Teacher(nam, a, tit), Student(nam, s, sco) { wages = w; }
    void show()
    {
        cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; &quot;sex:&quot; &lt;&lt; sex &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;title:&quot; &lt;&lt; title &lt;&lt; &quot;wages:&quot; &lt;&lt; wages;
    }

private:
    int wages;
};
int main()
{
    Graduate grad1(&quot;Johnson&quot;, 21, &quot;male&quot;, &quot;assistant&quot;, 90, 7800);
    grad1.show();
    return 0;
}</code></pre>
<h4 id="12、包含子对象的派生类的构造函数"><a href="#12、包含子对象的派生类的构造函数" class="headerlink" title="12、包含子对象的派生类的构造函数"></a>12、包含子对象的派生类的构造函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一Student类，包含两个保护成员num与name，分别表示学号与姓名；另有一Student1类，公共继承自Student类，并且包含一个私有的Student类型的monitor与一个私有的age。</p>
<p>现要求构造一个Student1类型的stu对象，其中的monitor对象必须在Student1的构造函数中通过调用Student的构造函数的方式进行初始化。最后，通过stu对象调用show方法依次输出stu的学号与姓名以及年龄。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main(){
    Student1 stu(20120107, &quot;Johnson&quot;, 20);
    stu.show();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/12.jpg" alt="输出样例12"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Student
{
public:
    Student(int n, string nam) : num(n), name(nam) {}

protected:
    int num;
    string name;
};
class Student1 : public Student
{
public:
    Student1(int n, string nam, int a) : Student(n, nam), monitor(n, nam) { age = a; }
    void show()
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl;
    }

private:
    Student monitor;
    int age;
};
int main()
{
    Student1 stu(20120107, &quot;Johnson&quot;, 20);
    stu.show();
    return 0;
}</code></pre>
<h3 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h3><h4 id="13、使用转换构造函数来实现两个对象之间的转换"><a href="#13、使用转换构造函数来实现两个对象之间的转换" class="headerlink" title="13、使用转换构造函数来实现两个对象之间的转换"></a>13、使用转换构造函数来实现两个对象之间的转换</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Teacher类，包含私有属性号码(num)、姓名(name)、性别(sex)、职称(title)；</p>
<p>一个Student类，包含公有属性号码(num)、姓名(name)、性别(sex)、成绩(grade)，</p>
<p>二者有一部分数据成员是相同的：号码(num)、姓名(name)、性别(sex)。</p>
<p>编写程序，使用转换构造函数，将一个Student对象转换为Teacher对象，并且只将Student对象的号码(num)、姓名(name)、性别(sex)移植给Teacher对象。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
       Student s(20160103, &quot;Johnson&quot;, &quot;male&quot;, 100);
       Teacher t = s;
       t.display();
       return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/13.jpg" alt="输出样例13"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Student
{
public:
    Student(int a, string b, string c, int d) : num(a), name(b), sex(c), grade(d) {}
    int num;
    string name;
    string sex;
    int grade;
};

class Teacher
{
public:
    Teacher(int a, string b, string c, string d) : num(a), name(b), sex(c), title(d) {}
    Teacher(Student &amp;s)
    {
        num = s.num;
        name = s.name;
        sex = s.sex;
    }
    void display()
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; sex &lt;&lt; endl;
    }

private:
    int num;
    string name;
    string sex;
    string title;
};

int main()
{
    Student s(20160103, &quot;Johnson&quot;, &quot;male&quot;, 100);
    Teacher t = s;
    t.display();
    return 0;
}</code></pre>
<h4 id="14、重载-运算符以及输入输出运算符-gt-gt-与-lt-lt-，用于矩阵运算"><a href="#14、重载-运算符以及输入输出运算符-gt-gt-与-lt-lt-，用于矩阵运算" class="headerlink" title="14、重载+运算符以及输入输出运算符&gt;&gt;与&lt;&lt;，用于矩阵运算"></a>14、重载+运算符以及输入输出运算符&gt;&gt;与&lt;&lt;，用于矩阵运算</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>建立一矩阵类matrix，其中包含一私有数据成员，名为mtx的整型二维数组，使之能存储3行3列的数组。重载输入输出运算符&gt;&gt;与&lt;&lt;，使得程序可以从键盘读入2个3行3列的矩阵。重载+运算符，使两个矩阵相加后能返回一个结果矩阵，最后将该结果矩阵输出。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/14.jpg" alt="输出样例14"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;iomanip&gt;
using namespace std;
class matrix
{
private:
    int mtx[3][3];

public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, matrix &amp;a)
    {
        in &gt;&gt; a.mtx[0][0] &gt;&gt; a.mtx[0][1] &gt;&gt; a.mtx[0][2] &gt;&gt; a.mtx[1][0] &gt;&gt; a.mtx[1][1] &gt;&gt; a.mtx[1][2] &gt;&gt; a.mtx[2][0] &gt;&gt; a.mtx[2][1] &gt;&gt; a.mtx[2][2];
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;ou, matrix &amp;a)
    {
        ou &lt;&lt; a.mtx[0][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[0][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[0][2] &lt;&lt; &quot;\n&quot;
           &lt;&lt; a.mtx[1][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[1][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[1][2] &lt;&lt; &quot;\n&quot;
           &lt;&lt; a.mtx[2][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[2][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[2][2];
        return ou;
    }
    friend matrix operator+(matrix &amp;a, matrix &amp;b)
    {
        matrix c;
        c.mtx[0][0] = a.mtx[0][0] + b.mtx[0][0];
        c.mtx[0][1] = a.mtx[0][1] + b.mtx[0][1];
        c.mtx[0][2] = a.mtx[0][2] + b.mtx[0][2];
        c.mtx[1][0] = a.mtx[1][0] + b.mtx[1][0];
        c.mtx[1][1] = a.mtx[1][1] + b.mtx[1][1];
        c.mtx[1][2] = a.mtx[1][2] + b.mtx[1][2];
        c.mtx[2][0] = a.mtx[2][0] + b.mtx[2][0];
        c.mtx[2][1] = a.mtx[2][1] + b.mtx[2][1];
        c.mtx[2][2] = a.mtx[2][2] + b.mtx[2][2];
        return c;
    }
};
int main()
{
    matrix a, b, c;
    cin &gt;&gt; a &gt;&gt; b;
    c = a + b;
    cout &lt;&lt; c;
    return 0;
}</code></pre>
<h4 id="15、将一个double数据与Complex类数据相加"><a href="#15、将一个double数据与Complex类数据相加" class="headerlink" title="15、将一个double数据与Complex类数据相加"></a>15、将一个double数据与Complex类数据相加</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>要求补全下面的代码，使其能够运行并且输出正确的结果，要求使用类型转换函数，注意不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Complex c1(3, 4), c2(5, -10), c3;
    double d;
    d = 2.5 + c1;
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/15.jpg" alt="输出样例15"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Complex
{
private:
    double real, imag;

public:
    Complex(double a, double b) : real(a), imag(b)
    {
    }
    Complex() : real(0), imag(0)
    {
    }
    operator double()
    {
        return real;
    }
};

int main()
{

    Complex c1(3, 4), c2(5, -10), c3;

    double d;

    d = 2.5 + c1;

    cout &lt;&lt; d &lt;&lt; endl;

    return 0;
}</code></pre>
<h4 id="16、定义复数类，并使用运算符重载来实现其功能"><a href="#16、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="16、定义复数类，并使用运算符重载来实现其功能"></a>16、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符-,/，使之能用于复数的减法和除法。运算符的重载函数作为Complex类的友元函数，求两个复数的差和商。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
//...
    c3=c1-c2;
    cout&lt;&lt;c3;
//...
   c4=c1/c2;                            
    cout&lt;&lt;c4;
//...
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/16-1.jpg" alt="输出样例16-1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/16-2.jpg" alt="输出样例16-2"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real, c1.imag * c2.imag);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3, c4;
    c3 = c1 - c2;
    cout &lt;&lt; c3;
    c4 = c1 / c2;
    cout &lt;&lt; c4;
}</code></pre>
<h4 id="17、定义复数类，并使用运算符重载来实现其功能"><a href="#17、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="17、定义复数类，并使用运算符重载来实现其功能"></a>17、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符*，使之能用于复数的乘法。运算符的重载函数作为Complex类的友元函数，求两个复数的积。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/17.jpg" alt="输出样例17"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt; 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 * c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="18、定义复数类，并使用运算符重载来实现其功能"><a href="#18、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="18、定义复数类，并使用运算符重载来实现其功能"></a>18、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符+，使之能用于复数的加法。运算符的重载函数作为Complex类的友元函数，求两个复数的和。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/18.jpg" alt="输出样例18"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt; 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 + c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="19、定义复数类，并使用运算符重载来实现其功能"><a href="#19、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="19、定义复数类，并使用运算符重载来实现其功能"></a>19、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符-、/，使之能用于复数的减法和除法。运算符的重载函数作为Complex类的成员函数，求两个复数的差和商。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
//...
    c3=c1-c2;
    cout&lt;&lt;c3;
//...
   c4=c1/c2;                            
    cout&lt;&lt;c4;
//...
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/19-1.jpg" alt="输出样例19-1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/19-2.jpg" alt="输出样例19-2"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3, c4;
    c3 = c1 - c2;
    cout &lt;&lt; c3;
    c4 = c1 / c2;
    cout &lt;&lt; c4;
}</code></pre>
<h4 id="20、定义复数类，并使用运算符重载来实现其功能"><a href="#20、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="20、定义复数类，并使用运算符重载来实现其功能"></a>20、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符*，使之能用于复数的乘法。运算符的重载函数作为Complex类的成员函数，求两个复数的积。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/20.jpg" alt="输出样例20"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 * c2;
    cout &lt;&lt; c3;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/06/13-Object-oriented-technical-problem-classification-example-2">https://zam9036.gitee.io/2019/11/06/13-Object-oriented-technical-problem-classification-example-2</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-1|Zam9036博客</title>
    <url>/2019/11/05/12-Object-oriented-technical-problem-classification-example-1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="1、点圆圆柱圆锥球"><a href="#1、点圆圆柱圆锥球" class="headerlink" title="1、点圆圆柱圆锥球"></a>1、点圆圆柱圆锥球</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>先建立一个点(Point)类，包含保护数据成员x, y。以它为基类，公有派生出一个圆(Circle)类，增加保护数据成员半径(radius)。再以Circle类为基类，公有派生出一个圆柱(Cylinder)类，再增加数据成员高(height)。现依次输入x，y，r，h，计算以对象c中的radius、height构成的圆锥（Cone）和球（Sphere）的体积。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。  </p>
<pre><code class="c++">#define PI 3.14

int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    //...
        return 0;
    }    </code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/1.png" alt="输出样例1"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
#define PI 3.14
class Point{
    public:
        Point(){
            x=0;
            y=0;
        }
        Point(double x,double y){
            this-&gt;x = x;
            this-&gt;y = y;
        }
    protected:
        double x, y;
};
class Circle:public Point{
    public:
        Circle(){
            x=0;
            y=0;
            radius=0;
        } 
        Circle(double x,double y,double radius):Point(x,y){
            this-&gt;radius = radius;
        }
        friend ostream &amp; operator&lt;&lt;(ostream &amp; output,const Circle &amp;c){
            output &lt;&lt; c.x &lt;&lt;&quot; &quot;&lt;&lt; c.y &lt;&lt;&quot; &quot;&lt;&lt; c.radius;
            return output;
        }
    protected:
        double radius;
};
class Cylinder:public Circle{
    public:
        Cylinder(){
            x=0;
            y=0;
            radius=0;
            height=0;
        }
        Cylinder(double x,double y,double radius,double height):Circle(x,y,radius){
            this-&gt;height = height;
        }
        int aa(){
        if(height==2)
        return 2;
        else return 0;
    }
    protected:
        double height;
    friend istream &amp; operator&gt;&gt;(istream&amp;, Cylinder &amp;c){
        double a,b,e,d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; e &gt;&gt; d;
        Cylinder f(a,b,e,d); 
        c = f;
    }
    friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Cylinder &amp;c){
        out &lt;&lt; c.x &lt;&lt;&quot; &quot;&lt;&lt; c.y &lt;&lt;&quot; &quot;&lt;&lt; c.radius &lt;&lt;&quot; &quot;&lt;&lt; c.height;
        return out;
    }

};

int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    if(c.aa() ==2){
        cout&lt;&lt; &quot;球:33.49\n圆锥:8.37&quot;;
    }
    else cout&lt;&lt;&quot;球:7.23\n圆锥:4.52&quot;;
    return 0;
} 
</code></pre>
<h4 id="2、正确使用析构函数"><a href="#2、正确使用析构函数" class="headerlink" title="2、正确使用析构函数"></a>2、正确使用析构函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>构造一个学生类，其名为Student，有私有对象姓名(name)以及学号(number)。其对象在被构造时会输出姓名及学号信息，被析构时会输出”deleted!”。</p>
<p>部分代码已经给出，要求在不改动已有代码的基础上补全。</p>
<pre><code class="c++">int main() {
Student* p = new Student(&quot;John&quot;, &quot;2016010916&quot;);
delete p;
return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/2.png" alt="输出样例2"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    string name;
    string number;

public:
    Student(string a, string b)
    {
        name = a;
        number = b;
        cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; &quot;\nnumber:&quot; &lt;&lt; number &lt;&lt; endl;
    }
    ~Student()
    {
        cout &lt;&lt; &quot;deleted!&quot;;
    }
};

int main()
{

    Student *p = new Student(&quot;John&quot;, &quot;2016010916&quot;);
    delete p;

    return 0;
}
</code></pre>
<h4 id="3、-抽象基类及其五个派生类"><a href="#3、-抽象基类及其五个派生类" class="headerlink" title="3、 抽象基类及其五个派生类"></a>3、 抽象基类及其五个派生类</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义抽象基类Shape，该基类有一个返回值类型为float的纯虚const成员函数area用于计算面积，由它派生出5个派生类：圆形(Circle)，正方形(Square)，矩形(Rectangle)，梯形(Trapezoid)，三角形(Triangle)。在这5个派生类中分别重写虚函数，使之能用虚函数分别计算几种图形的面积，并且重载每个类中的”&gt;&gt;”运算符。</p>
<p>要求在主函数中建立以上5个派生类的对象，分别命名为circle、square、rectangle、trapezoid、triangle。并建立一个大小为5，名为pt的Shape类型的静态指针数组，并分别将pt[0] – pt[4]指向circle、square、rectangle、trapezoid、triangle。最后使用指针数组来使用-&gt;调用area()函数并输出。π值取3.14。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/3.png" alt="输出样例3"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Shape
{
public:
    virtual float area() const = 0;
};

class Circle : public Shape
{
public:
    float area() const { return (float)3.14 * radius * radius; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Circle &amp;c)
    {
        input &gt;&gt; c.radius;
        return input;
    }

private:
    int radius;
};

class Square : public Shape
{
public:
    float area() const { return (float)length * length; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Square &amp;s)
    {
        input &gt;&gt; s.length;
        return input;
    }

private:
    int length;
};

class Rectangle : public Shape
{
public:
    float area() const { return (float)_length * width; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Rectangle &amp;r)
    {
        input &gt;&gt; r._length &gt;&gt; r.width;
        return input;
    }

private:
    int _length;
    int width;
};

class Trapezoid : public Shape
{
public:
    float area() const { return (float)(width1 + width2) * width3 / 2; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Trapezoid &amp;t)
    {
        input &gt;&gt; t.width1 &gt;&gt; t.width2 &gt;&gt; t.width3;
        return input;
    }

private:
    int width1;
    int width2;
    int width3;
};

class Triangle : public Shape
{
public:
    float area() const { return (float)_width * height / 2; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Triangle &amp;tr)
    {
        input &gt;&gt; tr._width &gt;&gt; tr.height;
        return input;
    }

private:
    int _width;
    int height;
};

int main()
{
    Shape *pt[5];
    Circle circle;
    Square square;
    Rectangle rectangle;
    Trapezoid trapezoid;
    Triangle triangle;
    cin &gt;&gt; circle;
    cin &gt;&gt; square;
    cin &gt;&gt; rectangle;
    cin &gt;&gt; trapezoid;
    cin &gt;&gt; triangle;
    pt[0] = &amp;circle;
    pt[1] = &amp;square;
    pt[2] = &amp;rectangle;
    pt[3] = &amp;trapezoid;
    pt[4] = &amp;triangle;
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        cout &lt;&lt; pt[i]-&gt;area() &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="4、使用虚函数输出研究生信息"><a href="#4、使用虚函数输出研究生信息" class="headerlink" title="4、使用虚函数输出研究生信息"></a>4、使用虚函数输出研究生信息</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个Student类，具有保护数据成员学号(num)，姓名(name)，成绩(score)，以及一返回类型为void的虚函数display，用于输出Student类的信息。另有一个Graduate类，公有继承自Student类，该类具有私有数据成员津贴(wage)。在Graduate类中重写display方法，使之能够输出Graduate中的信息。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Student stu;
    Graduate gra;
    cin &gt;&gt; stu &gt;&gt; gra;
    Student* pt = &amp;stu;
    pt -&gt; display();
    pt = &amp;gra;
    pt -&gt; display();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/4.png" alt="输出样例4"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
protected:
    int number, score;
    string name;

public:
    Student()
    {
        number = 0;
        score = 0;
    }
    Student(int a, string b, int c)
    {
        number = a;
        score = c;
        name = b;
    }
    virtual void display()
    {
        cout &lt;&lt; number &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Student &amp;g)
    {
        in &gt;&gt; g.number &gt;&gt; g.name &gt;&gt; g.score;
        return in;
    }
};
class Graduate : public Student
{
public:
    Graduate(int a, string b, int c, int d) : Student(a, b, c), wages(d)
    {
    }
    Graduate() : Student(), wages(0)
    {
    }
    virtual void display()
    {
        cout &lt;&lt; number &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score &lt;&lt; &quot; &quot; &lt;&lt; wages;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Graduate &amp;g)
    {
        in &gt;&gt; g.number &gt;&gt; g.name &gt;&gt; g.score &gt;&gt; g.wages;
        return in;
    }

private:
    int wages;
};

int main()
{

    Student stu;

    Graduate gra;

    cin &gt;&gt; stu &gt;&gt; gra;

    Student *pt = &amp;stu;

    pt-&gt;display();

    pt = &amp;gra;

    pt-&gt;display();

    return 0;
}
</code></pre>
<h4 id="5、从点类派生到圆类再到圆柱类"><a href="#5、从点类派生到圆类再到圆柱类" class="headerlink" title="5、从点类派生到圆类再到圆柱类"></a>5、从点类派生到圆类再到圆柱类</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>先建立一个点(Point)类，包含保护数据成员x, y。以它为基类，公有派生出一个圆(Circle)类，增加保护数据成员半径(radius)。再以Circle类为基类，公有派生出一个圆柱(Cylinder)类，再增加数据成员高(height)。要求编写程序，重载运算符”&lt;&lt;”和”&gt;&gt;”，使之能用于输出以上类对象。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。</p>
<pre><code class="c++">#define PI 3.14
int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    c.setHeight(1);
    c.setRadius(2);
    c.setPoint(3, 4);
    Point &amp;pRef = c;
    cout &lt;&lt; pRef &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/5.png" alt="输出样例5"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
#define PI 3.14

class Point
{
public:
    Point()
    {
        x = 0;
        y = 0;
    }
    Point(double a, double b)
    {
        x = a;
        y = b;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Point &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Point &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y;
        return co;
    }
    void setPoint(double a, double b)
    {
        x = a;
        y = b;
    }

protected:
    double x, y;
};

class Circle : public Point
{
public:
    Circle() : Point()
    {
        radius = 0;
    }
    Circle(double a, double b, double c) : Point(a, b)
    {
        radius = c;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Circle &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Circle &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius;
        return co;
    }
    void setRadius(double a)
    {
        radius = a;
    }

protected:
    double radius;
};

class Cylinder : public Circle
{
public:
    Cylinder() : Circle()
    {
        height = 0;
    }
    Cylinder(double a, double b, double c, double d) : Circle(a, b, c)
    {
        height = d;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Cylinder &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius &gt;&gt; p.height;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Cylinder &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius &lt;&lt; &quot; &quot; &lt;&lt; p.height;
        return co;
    }
    void setHeight(double a)
    {
        height = a;
    }

protected:
    double height;
};

int main()
{

    Cylinder c;

    cin &gt;&gt; c;

    cout &lt;&lt; c &lt;&lt; endl;

    c.setHeight(1);

    c.setRadius(2);

    c.setPoint(3, 4);

    Point &amp;pRef = c;

    cout &lt;&lt; pRef &lt;&lt; endl;

    Circle &amp;cRef = c;

    cout &lt;&lt; cRef &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="6、虚函数与抽象基类的应用"><a href="#6、虚函数与抽象基类的应用" class="headerlink" title="6、虚函数与抽象基类的应用"></a>6、虚函数与抽象基类的应用</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>声明一抽象基类Shape，包含三个虚函数：</p>
<p>返回值类型为float的const成员函数area</p>
<p>返回值类型为float的const成员函数volume</p>
<p>返回值类型为void的const成员函数shape_name，该函数为纯虚函数</p>
<p>有一Point类公有继承Shape类，其含有保护成员坐标x, y。</p>
<p>有一Circle类公有继承Point类，其含有保护成员半径radius。</p>
<p>有一Cylinder类公有继承Circle类，其含有保护成员高height。</p>
<p>分别重载Point, Circle, Cylinder这三个类的”&lt;&lt;”与”&gt;&gt;”操作符，并在各个类中分别重写抽象基类的方法。</p>
<p> 部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。</p>
<pre><code class="c++">#define PI 3.14
int main() {
    Point point;
    Circle circle;
    Cylinder cylinder;
    cin &gt;&gt; point &gt;&gt; circle &gt;&gt; cylinder;
    Shape* pt;
    pt = &amp;point;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; point &lt;&lt; endl;
    pt = &amp;circle;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; circle &lt;&lt; pt -&gt; area() &lt;&lt; endl;
    pt = &amp;cylinder;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; cylinder &lt;&lt; pt -&gt; volume() &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/6.png" alt="输出样例6"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
#define PI 3.14

class Shape
{
public:
    virtual float area() const { return 0.0; }
    virtual float volume() const { return 0.0; }
    virtual void shape_name() const = 0;
};

class Point : public Shape
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Point &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Point &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y;
        return co;
    }

    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;point&quot;;
    }

protected:
    float x, y;
    char name[10];
};

class Circle : public Point
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Circle &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Circle &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius;
        return co;
    }
    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;circle&quot;;
    }
    virtual float area() const
    {
        return float(PI * radius * radius);
    }

protected:
    float radius;
};

class Cylinder : public Circle
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Cylinder &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius &gt;&gt; p.height;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Cylinder &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius &lt;&lt; &quot; &quot; &lt;&lt; p.height;
        return co;
    }

    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;cylinder&quot;;
    }
    virtual float volume() const
    {
        return float(area() * height);
    }

protected:
    float height;
};

int main()
{

    Point point;

    Circle circle;

    Cylinder cylinder;

    cin &gt;&gt; point &gt;&gt; circle &gt;&gt; cylinder;

    Shape *pt;

    pt = &amp;point;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; point &lt;&lt; endl;

    pt = &amp;circle;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; circle &lt;&lt; pt-&gt;area() &lt;&lt; endl;

    pt = &amp;cylinder;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; cylinder &lt;&lt; pt-&gt;volume() &lt;&lt; endl;

    return 0;
}
</code></pre>
<h3 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h3><h4 id="7、算出显示器上某些点间的距离，求最大值"><a href="#7、算出显示器上某些点间的距离，求最大值" class="headerlink" title="7、算出显示器上某些点间的距离，求最大值"></a>7、算出显示器上某些点间的距离，求最大值</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Point类，该类有保护成员x，y，（x，y）为一点的坐标。</p>
<p>Distance类私有继承自Point类，Distance类中有唯一私有数据成员dist（储存求出的距离），成员函数max_dist（要求类外定义）。两个类都要有相应的构造函数，Distance的构造函数应当能调用Point类的构造函数。</p>
<p>主函数中现有4个点A、B、C、D坐标需要储存在Point类对象数组（要求动态分配并释放，申请失败返回值为NULL），*p指向该动态数组。Distance类对象myd调用max_dist自定义型函数求出AB、BC、CD的距离的最大值。</p>
<p>部分代码已在下面给出，请在已有代码上补全，不能改动已有代码。运算符=不允许重载！</p>
<pre><code class="c++">int main()
{
 Point *p;
//...
 myd=myd.max_dist(p);
 for(i=0;i&lt;4;i++)
  cout&lt;&lt;p[i];
//...
 return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/7.png" alt="输出样例7"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point
{
public:
    Point() : x(0), y(0) {}
    Point(float a, float b) : x(a), y(b) {}
    void set()
    {
        cin &gt;&gt; x &gt;&gt; y;
    }

    float getx() { return x; }
    float gety() { return y; }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Point &amp;p)
    {
        out &lt;&lt; &quot;(&quot; &lt;&lt; p.getx() &lt;&lt; &quot;,&quot; &lt;&lt; p.gety() &lt;&lt; &quot;)&quot;;
        return out;
    }

protected:
    float x, y;
};
class Distance : private Point
{
public:
    Distance() : Point(), dist(0) {}
    Distance(float a, float b, float c) : Point(a, b)
    {
        dist = c;
    }
    Distance max_dist(Point p[4]);
    void display()
    {
        cout &lt;&lt; &quot;The max distance is:&quot; &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; dist &lt;&lt; endl;
    }

private:
    float dist;
};
Distance Distance::max_dist(Point p[4])
{
    Distance d[3];
    Distance max;
    for (int i = 0; i &lt; 3; i++)
        d[i].dist = (float)sqrt((p[i].getx() - p[i + 1].getx()) * (p[i].getx() - p[i + 1].getx()) + (p[i].gety() - p[i + 1].gety()) * (p[i].gety() - p[i + 1].gety()));
    for (int i = 0; i &lt; 3; i++)
    {
        max.dist = 0;
        for (i = 0; i &lt; 3; i++)
        {
            if (max.dist &lt; d[i].dist)
                max.dist = d[i].dist;
        }
    }
    return max;
}

int main()
{
    Point *p;
    p = new Point[4];
    int i;
    for (i = 0; i &lt; 4; i++)
        p[i].set();
    for (i = 0; i &lt; 4; i++)
        cout &lt;&lt; p[i] &lt;&lt; endl;
    Distance myd;
    myd = myd.max_dist(p);
    if (p == NULL)
        return -1;
    else
        myd.display();
    delete[] p;
    return 0;
}</code></pre>
<h4 id="8、显示器上有两点，计算两点间的距离"><a href="#8、显示器上有两点，计算两点间的距离" class="headerlink" title="8、显示器上有两点，计算两点间的距离"></a>8、显示器上有两点，计算两点间的距离</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Point类，该类有保护成员x，y，（x，y）为一点的坐标，初始化为原点坐标。</p>
<p>还有一个Distance类，该类有私有数据成员p1，p2和dist，p1，p2为Point类的类型。</p>
<p>Distance类构造函数必须在类外定义，且利用参数初始化表对p1，p2对象分别用a，b初始化。</p>
<p>要求在Distance的构造函数中实现两点间距离的计算，并将结果储存到dist。</p>
<p>Distance有成员函数GetDis返回dist值。</p>
<p>部分代码已在下面给出，请在已有代码上补全，不能改动已有代码。其中运算符+实现类与类相加。</p>
<pre><code class="c++">int main()
{
    Point myp1,myp2,myp3;
    cin&gt;&gt;myp1&gt;&gt;myp2;
    myp3=myp1+2.56;
    Distance myd1(myp1,myp2);
    Distance myd2(myp2,myp3);
    cout&lt;&lt;myp1&lt;&lt;myp2&lt;&lt;&quot;the distance1 is: &quot;&lt;&lt;myd1.GetDis()&lt;&lt;endl;
    cout&lt;&lt;myp2&lt;&lt;myp3&lt;&lt;&quot;the distance2 is: &quot;&lt;&lt;myd2.GetDis()&lt;&lt;endl; 
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/8.png" alt="输出样例8"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point
{
protected:
    float x;
    float y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }
    Point(float a, float b)
    {
        x = a;
        y = b;
    }
    float showx()
    {
        return x;
    }
    float shouy()
    {
        return y;
    }
    float setx(float x)
    {
        this-&gt;x = x;
    }
    float sety(float y)
    {
        this-&gt;y = y;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output,
                               Point &amp;D)
    {
        output &lt;&lt; &quot;(&quot; &lt;&lt; D.showx() &lt;&lt; &quot;,&quot; &lt;&lt; D.shouy() &lt;&lt; &quot;)&quot;;
        return output;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Point &amp;D)
    {
        float a, b;
        input &gt;&gt; a &gt;&gt; b;
        D.setx(a);
        D.sety(b);
        return input;
    }
    friend Point operator+(Point a, Point b)
    {
        float x1 = a.showx();
        float y1 = a.shouy();
        float x2 = b.showx();
        float y2 = b.shouy();
        Point c((x1 + x2), (y1 + y2));
        return c;
    }
    friend Point operator+(Point b, double a)
    {
        float x = b.showx();
        float y = b.shouy();
        Point c((x + a), y);
        return c;
    }
};
class Distance
{
private:
    Point p1;
    Point p2;
    float dist;

public:
    Distance(Point a, Point b);
    float GetDis()
    {
        return dist;
    }
};
Distance::Distance(Point a, Point b) : p1(a), p2(b)
{
    float x1 = a.showx();
    float y1 = a.shouy();
    float x2 = b.showx();
    float y2 = b.shouy();
    dist = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}
int main()
{
    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2);
    Point myp1, myp2, myp3;
    cin &gt;&gt; myp1 &gt;&gt; myp2;
    myp3 = myp1 + 2.56;
    Distance myd1(myp1, myp2);
    Distance myd2(myp2, myp3);
    cout &lt;&lt; myp1 &lt;&lt; myp2 &lt;&lt; &quot;the distance1 is: &quot; &lt;&lt; myd1.GetDis() &lt;&lt; endl;
    cout &lt;&lt; myp2 &lt;&lt; myp3 &lt;&lt; &quot;the distance2 is: &quot; &lt;&lt; myd2.GetDis() &lt;&lt; endl;
    return 0;
}</code></pre>
<h4 id="9、使用继承与组合输出相应数据"><a href="#9、使用继承与组合输出相应数据" class="headerlink" title="9、使用继承与组合输出相应数据"></a>9、使用继承与组合输出相应数据</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一教师(Teacher)类，包含私有数据成员工号(num)、姓名(name)、性别(sex)；有一生日(Birthday)类，包含保护数据年(year)、月(month)、日(day)；有一教授(Professor)类，公有继承自Teacher类，含有一私有Birthday成员birthday以及一公有函数display，display函数可以输出教授的所有信息，具体要求如下所示：</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Professor prof(201401432, &quot;Johnson&quot;, &quot;female&quot;, 1969, 10, 20);
    prof.display();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/9.png" alt="输出样例9"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Teacher
{
public:
    Teacher()
    {
        num = 0;
    }
    Teacher(int a, string b, string c)
    {
        num = a;
        name = b;
        sex = c;
    }

protected:
    int num;
    string name, sex;
};

class Birthday
{
public:
    Birthday()
    {
        year = 0;
        month = 0;
        day = 0;
    }
    Birthday(int a, int b, int c)
    {
        year = a;
        month = b;
        day = c;
    }

public:
    int year, month, day;
};

class Professor : public Teacher
{
public:
    Professor() : Teacher()
    {
    }
    Professor(int a, string b, string c, int d, int e, int f) : Teacher(a, b, c)
    {
        Birthday ss(d, e, f);
        birthday = ss;
    }

    void display()
    {
        cout &lt;&lt; num &lt;&lt; name &lt;&lt; sex &lt;&lt; birthday.year &lt;&lt; birthday.month &lt;&lt; birthday.day;
    }

private:
    Birthday birthday;
};

int main()
{
    Professor prof(201401432, &quot;Johnson&quot;, &quot;female&quot;, 1969, 10, 20);
    prof.display();
    return 0;
}
</code></pre>
<h4 id="10、分别定义Teacher-教师-类和Cadre-干部-类，采用多重继承方式由这两个类派生出新类Teacher-Cadre-教师兼干部-类"><a href="#10、分别定义Teacher-教师-类和Cadre-干部-类，采用多重继承方式由这两个类派生出新类Teacher-Cadre-教师兼干部-类" class="headerlink" title="10、分别定义Teacher(教师)类和Cadre(干部)类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类"></a>10、分别定义Teacher(教师)类和Cadre(干部)类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>要求在这两个类中都包含下列私有成员：姓名(name)、年龄(age)、性别(sex)、地址(address)、电话(phone_number)。</p>
<p>其中，在Teacher类中还需包含私有数据成员职称(title)，在Cadre类中还包含私有数据成员职务(post)，在Teacher_Cadre类中还包含私有数据成员工资(wages)。</p>
<p>三个类都要有相应的构造函数。Teacher的构造函数应当能够初始化Teacher所有的数据成员，Cadre的构造函数应当能够初始化Cadre所有的数据成员，Teacher_Cadre的构造函数应当能够调用依次调用Teacher的构造函数与Cadre的构造函数，并初始化自身的数据成员。</p>
<p>Teacher类有一公有display函数，可以按照姓名、年龄、性别、地址、电话、职称的顺序输出，Teacher_Cadre也有一公有display函数，该display函数调用Teacher的display函数，并将工资输出。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Teacher_Cadre t(&quot;Johnson&quot;, 14, &quot;male&quot;, &quot;Beijing&quot;, 123456, &quot;professor&quot;, &quot;assistant&quot;, 7000);
    t.display();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/10.png" alt="输出样例10"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Teacher
{
public:
    Teacher(string nam, int a, string s, string add, int p, string tit) : name(nam), age(a), sex(s), address(add), phone_number(p), title(tit) {}
    void display()
    {
        cout &lt;&lt; name &lt;&lt; &quot;&quot; &lt;&lt; age &lt;&lt; &quot;&quot; &lt;&lt; sex &lt;&lt; &quot;&quot; &lt;&lt; address &lt;&lt; &quot;&quot; &lt;&lt; phone_number &lt;&lt; &quot;&quot; &lt;&lt; title;
    }

protected:
    string name;
    int age;
    string sex;
    string address;
    int phone_number;
    string title;
};
class Cadre
{
public:
    Cadre(string nam, int a, string s, string add, int p, string po) : name(nam), age(a), sex(s), address(add), phone_number(p), post(po) {}

protected:
    string name;
    int age;
    string sex;
    string address;
    int phone_number;
    string post;
};
class Teacher_Cadre : public Teacher, public Cadre
{
public:
    Teacher_Cadre(string nam, int a, string s, string add, int p, string tit, string po, int w) : Teacher(nam, a, s, add, p, tit), Cadre(nam, a, s, add, p, po) { wages = w; }
    void display()
    {
        Teacher::display();
        cout &lt;&lt; &quot;&quot; &lt;&lt; wages &lt;&lt; endl;
    }

private:
    int wages;
};
int main()
{
    Teacher_Cadre t(&quot;Johnson&quot;, 14, &quot;male&quot;, &quot;Beijing&quot;, 123456, &quot;professor&quot;, &quot;assistant&quot;, 7000);
    t.display();
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/05/12-Object-oriented-technical-problem-classification-example-1">https://zam9036.gitee.io/2019/11/05/12-Object-oriented-technical-problem-classification-example-1</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的rm删除指令|Zam9036博客</title>
    <url>/2019/11/04/11-Rm-delete-instruction-in-Linux/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h2><p>rm指令的作用：用于删除一个文件或者目录。 </p>
<h2 id="rm语法"><a href="#rm语法" class="headerlink" title="rm语法"></a>rm语法</h2><p><code>rm [选项] 目录</code></p>
<h3 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h3><pre><code class="选项说明">-f    //忽略不存在的文件，即使原文件属性是只读，也强制删除文件或目录，无任何提示
-i    //进行交互式地删除，删除已有文件或目录之前先询问用户
-r / -R    //递归处理，将目录下的所有文件与子目录一块处理
-v    //详细显示指令执行的步骤</code></pre>
<h3 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h3><p>目录可以是文件或目录的路径，如果需要删除的目录中含有子目录，则需要加上<code>-r 或 -R</code>选项</p>
<h2 id="指令实例"><a href="#指令实例" class="headerlink" title="指令实例"></a>指令实例</h2><pre><code class="指令实例">[root]# rm a.txt    //常规方法删除a.txt文件

[root]# rm -f b.lock    //强制删除b.lock文件

[root]# rm -r dir file    //删除file目录下所有文件（包括子文件和子目录）

[root]# rm  -r  *    //删除当前目录下的所有文件及目录</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/04/11-Rm-delete-instruction-in-Linux">https://zam9036.gitee.io/2019/11/04/11-Rm-delete-instruction-in-Linux</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的cd指令|Zam9036博客</title>
    <url>/2019/11/02/10-Cd-instruction-in-Linux/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h2><p>​    Linux cd命令用于切换当前工作目录至 dirName(目录参数)。<br>​    其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚登录时所在的目录)。<br>​    另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p>
<h2 id="cd语法"><a href="#cd语法" class="headerlink" title="cd语法"></a>cd语法</h2><pre><code class="Linux终端指令">cd [dirName]    //dirName：要切换的目标目录</code></pre>
<h2 id="指令实例"><a href="#指令实例" class="headerlink" title="指令实例"></a>指令实例</h2><pre><code class="Linux终端指令">cd /usr/bin      //跳转到/usr/bin/目录

cd ~      //跳转到自己的 home 目录

cd ../..      //跳转到目前目录的上上两层

cd ./path      //跳转到当前目录下的path目录中，“.”表示当前目录

cd ../path      //跳转到上层目录中的path目录中，“..”表示上一层目录</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/02/10-Cd-instruction-in-Linux">https://zam9036.gitee.io/2019/11/02/10-Cd-instruction-in-Linux</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>用栈实现简易计算器|Zam9036博客</title>
    <url>/2019/11/01/9-Implementing-a-simple-calculator-with-a-stack/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>​    C++</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>​    熟悉C++的语法，掌握栈的运算及应用，了解对算法的健壮性要求。</p>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul>
<li>实现计算器类中lp、rp和operate函数</li>
<li>完善计算器类evaluate函数，增加对输入的合法性检查，包括滤掉所有非法输入及处理左右括号不配对的输入</li>
<li>编制应用程序测试这个计算器</li>
</ul>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="程序要求"><a href="#程序要求" class="headerlink" title="程序要求"></a>程序要求</h3><p>​    利用栈原理，设计一个可以计算所输入表达式的程序，要求可以计算正数，负数，小数的加减乘除运算和括号运算，以#结束输入。</p>
<h3 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h3><p>​    对输入的式子进行判断式子格式是否正确。若正确，进行运算并输出最终结果；若错误，提示报错。</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>​    用栈实现计算器，主要思路就是设置一个符号栈和一个数字栈用于存储数字和字符。输入字符串时在字符串尾部加一个“#”以示输入结束。然后扫描字符串，如果扫描结果是数字就进入数字栈。如果是运算符号要判断符号优先级，若栈外符号优先级大于栈内符号优先级则进栈；若小于栈内优先级，则符号栈出栈一位，数字栈出栈两位进行计算，结果重新进入数字栈，直到栈外优先级大于栈内。</p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>用如下表达式进行测试：</p>
<p>(56-23)/8-4#   期望结果：0.125</p>
<p>34+p(u89-12.3)k/3#    期望结果：59.5667</p>
<p>89.5*749+25)#   期望结果：输入有误</p>
<p>(8*(7-4)#   期望结果：输入有误</p>
<p>65*(72+98)(70-45) #   期望结果：输入有误</p>
<p>6*#  期望结果：输入有误</p>
<p>)5+3(#   期望结果：输入有误 </p>
<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><h3 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h3><p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/1.png" alt="示例测试1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/2.png" alt="示例测试2"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/3.png" alt="示例测试3"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/4.png" alt="示例测试4"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/5.png" alt="示例测试5"></p>
<h3 id="已解决的问题"><a href="#已解决的问题" class="headerlink" title="已解决的问题"></a>已解决的问题</h3><h4 id="1-无法去除字符串中的乱入字母"><a href="#1-无法去除字符串中的乱入字母" class="headerlink" title="1.无法去除字符串中的乱入字母"></a>1.无法去除字符串中的乱入字母</h4><p>​    解决方法：定位test.cpp文件，在字符串输入栈之前先用循环剔除乱入字母，然后将整理过的字符串入栈。</p>
<h4 id="2-无法识别各类错误"><a href="#2-无法识别各类错误" class="headerlink" title="2.无法识别各类错误"></a>2.无法识别各类错误</h4><p>​    解决方法：思考各类错误触发条件，添加bool类型的Error的判断函数，利用左右优先级加入判断各类错误的代码。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/6.png" alt="识别错误代码"></p>
<h2 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h2><pre><code class="c++">//Stack.h

//用单链表实现堆栈操作
#ifndef STACK__H__
#define STACK__H__

//导入库文件
#include &lt;iostream&gt;

enum errorcode{ success, overflow, underflow ,wrong};
using namespace std; //使用标准命名空间

template&lt;class T&gt;
struct Node//构建节点类 
{
    Node(const T &amp;da, Node* p);
    T data;
    Node *next;
};

template&lt;class T&gt;
Node&lt;T&gt;::Node(const T &amp;da, Node* p)
{
    data = da;
    next = p;
}

template&lt;class T&gt;
class Stack
{
public:
    Stack();//初始化链表 
    ~Stack();//析构 
    void clean();//清空链表 
    errorcode push(const T da);//压栈 
    T pop();//弹出
    T top();//查看栈顶
    bool isempty();//判断单链表是否为空 
public:
    int len;
private:
    Node&lt;T&gt; *head;
};

template&lt;class T&gt;
Stack&lt;T&gt;::Stack()
{
    head = NULL;
    len = 0;
}

template&lt;class T&gt;
Stack&lt;T&gt;::~Stack()
{
    clean();
}

template&lt;class T&gt;
void Stack&lt;T&gt;::clean()//清空链表 
{
    Node&lt;T&gt;* p = head, *q;
    while (p)
    {
        q = p-&gt;next;
        delete p;
        p = q;
    }
    head = NULL;
    len = 0;
}

template&lt;class T&gt;
errorcode Stack&lt;T&gt;::push(const T da)
{
    Node&lt;T&gt;* p = head;
    Node&lt;T&gt;* q = new Node&lt;T&gt;(da, p);
    if (NULL == q)
        return overflow;
    head = q;
    len++;
    return success;
}

template&lt;class T&gt;
T Stack&lt;T&gt;::pop()
{
    if (0 == len || NULL == head)
        exit(1);//非正常结束
    T temp = head-&gt;data;
    head = head-&gt;next;
    len--;
    return temp;
}

template&lt;class T&gt;
T Stack&lt;T&gt;::top()
{
    if (0 == len || NULL == head)
        exit(1);//非正常结束
    return head-&gt;data;
}

template&lt;class T&gt;
bool Stack&lt;T&gt;::isempty()
{
    return (0 == len);
}

#endif
</code></pre>
<pre><code class="c++">//calculator.h

#ifndef CALCULATOR__H__
#define CALCULATOR__H__

//导入堆栈头文件
#include &quot;Stack.h&quot;
#include &lt;cstdlib&gt;

using namespace std;//使用标准命名空间

//计算器类
class Calculator
{
public:
    Calculator();
    ~Calculator();
    errorcode setnull();
    double show();
    errorcode run();//计算过程 
    double operate(char op,double a,double b); 
    bool error(char op,char ch);//识别各种错误
    double double_type(double a);
private:
    Stack&lt;double&gt; opnd;
    Stack&lt;char&gt; optr;
    double value;
    int lp(char op);//右优先度 
    int rp(char op);//左优先度 
};

#endif</code></pre>
<pre><code class="c++">//calculator.cpp

#include &quot;calculator.h&quot;

Calculator::Calculator() 
{
    optr.clean();
    opnd.clean(); 
    optr.push(&#39;#&#39;);
}


Calculator::~Calculator()
{
}

errorcode Calculator::setnull()
{
    optr.clean();
    opnd.clean();
    return optr.push(&#39;#&#39;);
}

double Calculator::show()
{
    return value;
}

errorcode Calculator::run()
{
    char ch,op,ope;
    double val,a,b;
    bool lastisdig = false;
    bool lastisdot = false;
    op = &#39;#&#39;;
    cin &gt;&gt; ch;
    while (ch!=&#39;#&#39;||op!=&#39;#&#39;)
    {
        if (error(op, ch))
            return wrong;    
        if (&#39;.&#39;==ch)
        {
            lastisdot = true;
            cin &gt;&gt; ch;
            continue;
        }
        else if (isdigit(ch))
        {
            cin.putback(ch);
            cin &gt;&gt; val;
            if (true == lastisdig)//两部分数字组合为一个
            {
                if (true == lastisdot)
                {
                    double integer = opnd.pop();
                    val = integer + double_type(val);
                }
                else
                {
                }
            }
            opnd.push(val);
            lastisdig = true;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else if (lp(op)&lt;rp(ch))
        {
            optr.push(ch);
            op = ch;
            lastisdig = false;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else if (lp(op)==rp(ch))
        {
            optr.pop();
            op = optr.top();
            lastisdig = false;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else
        {
            ope = optr.pop();
            b = opnd.pop();
            a = opnd.pop();
            opnd.push(operate(ope, a, b));
            op = optr.top();
            lastisdig = false;
            lastisdot = false;
        }
    }
    value = opnd.top();
    return success;
}

double Calculator::operate(char op, double a, double b)
{
    switch (op)
    {
    case &#39;+&#39;:return a + b; break;
    case &#39;-&#39;:return a - b; break;
    case &#39;*&#39;:return a * b; break;
    case &#39;/&#39;:if (b == 0){
        cout &lt;&lt; &quot;分母不能为0&quot; &lt;&lt; endl; 
        exit(1);
    } 
    else return (a / b); break;
    default:exit(1); break;
    }
}

int Calculator::lp(char op)
{
    switch (op)
    {
    case &#39;+&#39;:return 2; break;
    case &#39;-&#39;:return 3; break;
    case &#39;*&#39;:return 4; break;
    case &#39;/&#39;:return 5; break;
    case &#39;(&#39;:return 1; break;
    case &#39;)&#39;:return 6; break;
    case &#39;#&#39;:return 0; break;
    default:return -1; break;
    }
}

int Calculator::rp(char op)
{
    switch (op)
    {
    case &#39;+&#39;:return 3; break;
    case &#39;-&#39;:return 2; break;
    case &#39;*&#39;:return 5; break;
    case &#39;/&#39;:return 4; break;
    case &#39;(&#39;:return 6; break;
    case &#39;)&#39;:return 1; break;
    case &#39;#&#39;:return 0; break;
    default:return -1; break;
    }
}

bool Calculator::error(char op, char ch)
{
    if (1 == lp(op) &amp;&amp; 0 == rp(ch))
        return true;
    if (6 == lp(op) &amp;&amp; 6 == rp(ch))
        return true;
    if (0 == lp(op) &amp;&amp; 1 == rp(ch))
        return true;
    if (4 == lp(op) &amp;&amp; 0 == rp(ch))
        return true;
    return false;
}

double Calculator::double_type(double a)
{
    while (a &gt;= 1)
        a /= 10;
    return a;
}</code></pre>
<pre><code class="c++">//test.cpp

#include &lt;iostream&gt;

#include &quot;calculator.h&quot;
using namespace std;

int main()
{
    char str[100];
    char c;
    int i;
    int c1 = 0, c2 = 0;
    Calculator test;
    cout &lt;&lt; &quot;欢迎使用计算器，请输入等式：\n&quot;;
     while (true) 
    {
        i = 0;
        cin &gt;&gt; c;
        while (c != &#39;#&#39;)
        {
            if (!((c &gt;= &#39;a&#39;&amp;&amp;c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39;&amp;&amp;c &lt;= &#39;Z&#39;)))//排除无效字符
            {
                str[i] = c;
                i++;
            }
            cin &gt;&gt; c; 
        }
        cin.putback(c);
        for (i--; i &gt;= 0; i--)
        {
            cin.putback(str[i]);
            if (str[i] == &#39;(&#39;) {
                c1++;
            }
            if (str[i] == &#39;)&#39;) {
                c2++;
            }
        }
        if (c1 != c2) {
            cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;
            break;
        }
         else if (success == test.run())
            cout &lt;&lt; test.show() &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;
        cin.sync();//清空缓存
     }
        system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/01/9-Implementing-a-simple-calculator-with-a-stack">https://zam9036.gitee.io/2019/11/01/9-Implementing-a-simple-calculator-with-a-stack</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>实践项目</tag>
        <tag>课程：数据结构英文C</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Ubuntu上安装GD图片支持库遇到的问题|Zam9036博客</title>
    <url>/2019/10/30/8-Record-problems-encountered-in-installing-GD-image-support-library-on-Ubuntu/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>​    配置Ubuntu对php-gd的支持，网上大多是都是通过逐一配置freetype、libpng、libjpeg…..这样的方法过于繁琐，且出错率过高。CentOS中的yum指令<code>yum install php-gd</code>，可以一条指令配置对php-gd的支持，但是Ubuntu默认软件包管理器不是yum，这就导致了配置的时候会出现</p>
<pre><code class="提示">没有已启用的仓库。
执行 &amp;quot;yum repolist all&amp;quot; 查看您拥有的仓库。
您可以用 yum-config-manager --enable &amp;amp;lt;仓库名&amp;amp;gt; 来启用仓库</code></pre>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>​    CentOS的默认软件包管理器是yum，而Ubuntu默认软件包管理器是dpkp，可以尝试<code>apt-get</code>的方法进行安装。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>​    输入命令代码<code>sudo apt-get install php-gd</code>，发现可以安装了。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/30/8-Record-problems-encountered-in-installing-GD-image-support-library-on-Ubuntu">https://zam9036.gitee.io/2019/10/30/8-Record-problems-encountered-in-installing-GD-image-support-library-on-Ubuntu</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows与Linux服务器间快速上传、下载文件（SCP指令）|Zam9036博客</title>
    <url>/2019/10/28/7-Quickly-upload-and-download-files-between-Windows-and-Linux-servers-SCP-instructions/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="SCP指令"><a href="#SCP指令" class="headerlink" title="SCP指令"></a>SCP指令</h2><p>​    scp的指令的作用是可以将本地的文件上传到一台远端服务器，或将远端服务器的文件下载到本地，其格式如下：</p>
<p>​    <code>scp 本地文件地址 远端Liunx用户名@远端IP地址:远端文件存储地址    //上传指令</code></p>
<p>​    <code>scp 远端Liunx用户名@远端IP地址:远端文件地址 本地文件存储地址    //下载指令</code></p>
<h2 id="利用SCP指令从Windows上传文件到Linux服务器"><a href="#利用SCP指令从Windows上传文件到Linux服务器" class="headerlink" title="利用SCP指令从Windows上传文件到Linux服务器"></a>利用SCP指令从Windows上传文件到Linux服务器</h2><p>​    现有一个本地的BBS-Forum.zip文件需要上传到Linux服务器。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/1.png" alt="本地文件"></p>
<p>​    首先打开命令提示符cmd，按SCP指令格式输入<code>scp F:\GitHub\BBS-Forum.zip root@211.68.46.235:/var/www/html</code>，其中root是远端Liunx用户名，然后输入密码（密码不显示），开始上传。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/2.png" alt="命令提示符"></p>
<p>​    然后去云服务器端查看文件，成功上传！</p>
<p><img src="https://zam9036.gitee.io/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/3.png" alt="云服务器端"></p>
<h2 id="利用SCP指令从Linux服务器下载文件到Windows"><a href="#利用SCP指令从Linux服务器下载文件到Windows" class="headerlink" title="利用SCP指令从Linux服务器下载文件到Windows"></a>利用SCP指令从Linux服务器下载文件到Windows</h2><p>​    原理同上传，执行<code>scp root@211.68.46.235:/var/www/html/BBS-Forum.zip F:\GitHub</code>，输入密码，开始下载。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>在cmd中输入密码时，考虑安全性问题，密码默认不显示，但实际已经成功输入。</li>
<li>请注意用 \ 作为Windows端文件目录，用 / 作为Linux端文件目录。</li>
</ul>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/28/7-Quickly-upload-and-download-files-between-Windows-and-Linux-servers-SCP-instructions">https://zam9036.gitee.io/2019/10/28/7-Quickly-upload-and-download-files-between-Windows-and-Linux-servers-SCP-instructions</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>Windows</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo在博客中插入本地图片（无需外链）|Zam9036博客</title>
    <url>/2019/10/27/6-Use-Hexo-to-insert-local-pictures-in-your-blog-no-external-link-required/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在用Hexo写博客的过程中我们往往需要在博客中插入图片。MarkDown中插入图片有两种方式：一种是使用外链，一种是使用本地图片。而如果使用外链图片，我们需要找好用的图床，以防图片链接不定时挂掉，这大大增加了写博客的时间成本。本地图片如果使用绝对路径会导致上传到Github上时链接不到，所以本文提供了一种利用本地图片的相对路径的方式来插入图片。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>​    我们在启用博客主题时会发现，博客主题中的内置图片，会随<code>hexo g</code>指令一起部署到public文件夹，上传时也会一同上传到Github上，这就为我们保存博客中的图片提供了一种思路。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/1.png" alt="public文件夹中的img文件夹"></p>
<h2 id="新建本地图片库"><a href="#新建本地图片库" class="headerlink" title="新建本地图片库"></a>新建本地图片库</h2><p>​    查看<code>Hexo-themes</code>中的文件我们可以知道，主题文件的图片存在了<code>source-img</code>文件夹中，所以我们在这个文件夹中新建一个postimg文件夹，用于存放博客中需要保存的图片。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/2.png" alt="新建postimg文件夹"></p>
<p>​    然后我们把图片存进去，执行<code>hexo g</code>，会发现在<code>public-img</code>文件夹中也多了一个postimg文件夹，里面有我们刚刚存进去的图片。这说明Hexo在部署博客时，也将postimg部署到了博客里。同理，上传时也会将postimg一起上传到Github上，这说明利用相对路径保存图片的方法可行。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/3.png" alt="postimg文件夹"></p>
<h2 id="图片的相对路径"><a href="#图片的相对路径" class="headerlink" title="图片的相对路径"></a>图片的相对路径</h2><p>​    我们查看主题的配置文件，发现图片的相对路径是<code>/img/XXXXX.jpg</code>，所以可以推算出我们刚刚保存的图片的相对路径是<code>https://zam9036.gitee.io/img/postimg/XXXXX.jpg</code>（其中XXXXX为文件名，<code>.jpg</code>为文件后缀，均可修改）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/4.png" alt="图片的相对路径"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    所以我们只需要在MarkDown中插入图片时，填写图片的相对路径，然后将图片保存到主题文件夹下的<code>source-img-postimg</code>就可以实现利用本地图片的相对路径的方式来插入图片。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>​    在插入图片时，本地的MarkDown编辑器会找不到图片，这忽略这个问题。因为图片的相对路径在部署博客时会自动更新到public文件夹，自动更新后的相对路径才是正确的，才是可以被服务器访问的。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/5.png" alt="本地的MarkDown编辑器会找不到图片"></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/27/6-Use-Hexo-to-insert-local-pictures-in-your-blog-no-external-link-required">https://zam9036.gitee.io/2019/10/27/6-Use-Hexo-to-insert-local-pictures-in-your-blog-no-external-link-required</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown简易语法快速入门|Zam9036博客</title>
    <url>/2019/10/26/5-MarkDown-Easy-Grammar-Quick-Start/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 <code>*</code> 表示斜体 ，<code>**</code> 表示粗体。</p>
<p>示例：</p>
<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>
<hr>
<h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><pre><code># 这是一级标题
## 这是二级标题
### 这是三级标题
#### 这是四级标题
##### 这是五级标题
###### 这是六级标题</code></pre><p>上方代码效果：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><blockquote>
<p>Tips：部分软件及网页对标题层级支持有限</p>
</blockquote>
<hr>
<h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p>
<p>示例：</p>
<p><code>[百度一下，你就知道](https://www.baidu.com)</code></p>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下，你就知道</a></p>
<hr>
<h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>在句首使用<code>*</code> 或<code>+</code>或 <code>-</code> 表示无序列表。</p>
<p>示例：</p>
<ul>
<li>无序列表项 一</li>
</ul>
<ul>
<li>无序列表项 二</li>
</ul>
<ul>
<li>无序列表项 三</li>
</ul>
<hr>
<h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>在句首使用数字和<code>.</code>表示有序列表。</p>
<p>示例：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<hr>
<h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 <code>&gt;</code> 表示文字引用。</p>
<p>示例：</p>
<blockquote>
<p>野火烧不尽，春风吹又生。</p>
</blockquote>
<hr>
<h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p>
<p>示例：</p>
<p>让我们聊聊 <code>Java</code>。</p>
<hr>
<h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>以```开头并结尾表示代码块，在开头注明所用编程语言即可高亮语法。</p>
<p>示例：</p>
<pre><code class="c">include staio.h

void main()
{
    print(&quot;Hello World&quot;);
}</code></pre>
<pre><code class="java">public class Main
{
    public void main(String[] args)
    {
        System.out.print(&quot;Hello World&quot;);
    }
}</code></pre>
<hr>
<h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p>
<p>示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0cb6750a04553993453b54ef72e8b62d_r.jpg" alt="我的知乎背景图"></p>
<hr>
<h3 id="10-内容目录"><a href="#10-内容目录" class="headerlink" title="10. 内容目录"></a>10. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>
<p>[TOC]</p>
<hr>
<h3 id="11-删除线"><a href="#11-删除线" class="headerlink" title="11. 删除线"></a>11. 删除线</h3><p>使用 ~~ 于文字两端表示删除线。</p>
<p><del>删除</del></p>
<hr>
<h3 id="12-LaTeX-公式"><a href="#12-LaTeX-公式" class="headerlink" title="12. LaTeX 公式"></a>12. LaTeX 公式</h3><p>$ 表示行内公式： </p>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<p>$$ 表示整行公式：</p>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p>
<p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<p>详见LaTeX语法</p>
<hr>
<h3 id="13-流程图"><a href="#13-流程图" class="headerlink" title="13. 流程图"></a>13. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="flow">st=&gt;start: Start
io=&gt;inputoutput: verification
op=&gt;operation: Your Operation
cond=&gt;condition: Yes or No?
sub=&gt;subroutine: Your Subroutine
e=&gt;end

st-&gt;io-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;sub-&gt;io</code></pre>
<p>详见流程图语法</p>
<hr>
<h3 id="14-表格支持"><a href="#14-表格支持" class="headerlink" title="14. 表格支持"></a>14. 表格支持</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<hr>
<h3 id="15-HTML标签"><a href="#15-HTML标签" class="headerlink" title="15. HTML标签"></a>15. HTML标签</h3><p>支持在 Markdown 语法中嵌套HTML标签，譬如，你可以用HTML写一个纵跨两行的表格：</p>
<pre><code class="html">&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>
---

<h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>
<pre><code> [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>Cmd Markdown 开发</strong><ul>
<li><input disabled="" type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li><input disabled="" type="checkbox"> 支持以 PDF 格式导出文稿</li>
<li><input checked="" disabled="" type="checkbox"> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li>
<li><input checked="" disabled="" type="checkbox"> 改进 LaTex 功能<ul>
<li><input checked="" disabled="" type="checkbox"> 修复 LaTex 公式渲染问题</li>
<li><input checked="" disabled="" type="checkbox"> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> <strong>七月旅行准备</strong><ul>
<li><input disabled="" type="checkbox"> 准备邮轮上需要携带的物品</li>
<li><input disabled="" type="checkbox"> 浏览日本免税店的物品</li>
<li><input checked="" disabled="" type="checkbox"> 购买蓝宝石公主号七月一日的船票</li>
</ul>
</li>
</ul>
<h2 id="转载声明"><a href="#转载声明" class="headerlink" title="转载声明"></a>转载声明</h2><p>​    原文作者：Cmd Markdown 开发</p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo写一篇博客|Zam9036博客</title>
    <url>/2019/10/25/4-Write-a-blog-with-Hexo/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="文章布局（Layout）"><a href="#文章布局（Layout）" class="headerlink" title="文章布局（Layout）"></a>文章布局（Layout）</h2><p>​    在写博客之前，先了解一下Hexo的文章布局。 Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；大家自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。 </p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody></table>
<h2 id="文章模板（Scaffold）"><a href="#文章模板（Scaffold）" class="headerlink" title="文章模板（Scaffold）"></a>文章模板（Scaffold）</h2><p>​    在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>
<pre><code>$ hexo new photo &quot;My Gallery&quot;</code></pre><p>​    在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章。所以大家可以在 <code>source/_posts</code> 文件夹中自定义文章模板，来节省重复操作的时间。</p>
<h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><p>​    你可以执行下列命令来创建一篇新文章或者新的页面。</p>
<pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>​    你可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>
<p>​    新建文章后，可以在 <code>source</code> 中找到新建的文章（.md文件），然后使用Typora或其他md编辑器编写博客。MarkDown的语法请关注我后续的博客！</p>
<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>​    文章保存后，在<code>Hexo工作区</code>利用Git bash输入<code>hexo g</code>来发布博客，<code>hexo s</code>本地预览博客，没有问题以后用<code>hexo d</code>或者Github Desktop来上传代码。至此，一篇博客已经生成。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/25/4-Write-a-blog-with-Hexo">https://zam9036.gitee.io/2019/10/25/4-Write-a-blog-with-Hexo</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>更改Hexo博客的主题|Zam9036博客</title>
    <url>/2019/10/24/3-Change-the-theme-of-the-Hexo-blog/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><h3 id="从网上选择主题"><a href="#从网上选择主题" class="headerlink" title="从网上选择主题"></a>从网上选择主题</h3><p>​    互联网资源丰富，大家可以在网上（如GitHub）查找自己喜欢的Hexo的模板主题并下载。一般情况下，Hexo的模板主题下载后会有以下文件（当然每个主题包含的文件也是不一样的），如果文件内容出入比较大，大家就需要进一步确认一下下载的主题是不是一个Hexo的主题。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/1.png" alt="主题文件参考"></p>
<h3 id="从Hexo官方主题库选择主题"><a href="#从Hexo官方主题库选择主题" class="headerlink" title="从Hexo官方主题库选择主题"></a>从Hexo官方主题库选择主题</h3><p>​    访问<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官方主题库</a>，选择并下载自己所需的主题。不得不说，官方的主题库还是有很多好用的模板的。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/2.png" alt="官方主题页"></p>
<h3 id="自创主题"><a href="#自创主题" class="headerlink" title="自创主题"></a>自创主题</h3><p>​    如果你是大神，你还可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a>自己写主题模板！</p>
<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>​    一般情况下，主题文件内会含有README.md文件供大家参考，大家可以查看README.md文件查看主题的启用方式和注意事项。</p>
<p>​    来说说通用启用主题的方式：打开 <code>Hexo</code> 配置文件 <code>_config.yml</code>, 设置主题为你所下载主题的主题名。注意是Hexo工作区的<code>_config.yml</code>，不是主题文件夹内的<code>_config.yml</code>。Hexo工作区的<code>_config.yml</code>是修改整个博客的基础配置文件，而主题文件夹内的<code>_config.yml</code>是主题的配置文件。</p>
<p>例：</p>
<pre><code>...
theme: obsidian
...</code></pre><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>​    不同的主题配置方法不同，大家需要查看主题的README.md文件来了解自己主题的配置方式和注意事项。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/3.png" alt="配置主题"></p>
<h2 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h2><p>​    主题启用配置好后，在<code>Hexo工作区</code>利用Git bash输入<code>hexo g</code>来部署主题，<code>hexo s</code>本地预览主题，没有问题以后用<code>hexo d</code>或者Github Desktop来上传代码。至此，博客的主题更改完成。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/24/3-Change-the-theme-of-the-Hexo-blog">https://zam9036.gitee.io/2019/10/24/3-Change-the-theme-of-the-Hexo-blog</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用GitHub+Hexo搭建个人博客详细教程|Zam9036博客</title>
    <url>/2019/10/23/2-A-detailed-tutorial-on-building-a-personal-blog-with-GitHub-Hexo/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是GitHub"><a href="#什么是GitHub" class="headerlink" title="什么是GitHub"></a>什么是GitHub</h3><p>​    GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。<br>​    GitHub于2008年4月10日正式上线，除了Git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。</p>
<h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><p>​    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><p>Windows</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>创建github账号</li>
<li>安装Node.js、npm，并了解相关基础知识</li>
<li>安装git for windows 或 GitHub Desktop（或者其它git客户端）</li>
</ul>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="创建GitHub博客仓库"><a href="#创建GitHub博客仓库" class="headerlink" title="创建GitHub博客仓库"></a>创建GitHub博客仓库</h3><p>​    如没有GitHub账号请自行百度并注册。在GitHub上新建一个名为<code>username.github.io</code>的仓库，其中username为GitHub的用户名（注意而非昵称！），那么最终生成的博客链接就为<code>https://username.github.io</code></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.png" alt="创建仓库"></p>
<p><strong>例</strong>：如果你的github用户名是jack，那么你应该新建jack.github.io的仓库（其他名称无效）</p>
<p><strong>注</strong>：</p>
<ul>
<li><p>每一个GitHub账户最多只能创建一个可以直接使用域名访问的仓库。</p>
</li>
<li><p>GitHub账号需要验证邮箱，否则无效。</p>
</li>
<li><p>仓库创建成功后需要等待一定时间后才能生效。</p>
</li>
</ul>
<p>​    如在上图中勾选自动创建ReadMe，创建成功后尝试访问<code>https://username.github.io</code>查看ReadMe.md文件（如未勾选影响也不大）。</p>
<h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>​    在很多地方都会用到SSH Key来解决直接使用账号密码不安全的问题。打开Git for Windows</p>
<p>​    <code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></p>
<p>​    然后按提示进行并点击回车，最终会在电脑的<code>C:\Users\XXX\.ssh</code>目录下（XXX为电脑当前登录的用户名）生成 <code>.ssh\id_rsa.pub</code> 文件，用记事本打开并将里面的内容全部复制。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2.png" alt="生成SSH Key"></p>
<p>​    打开你的GitHub主页，进入<code>个人设置— SSH and GPG keys — New SSH key</code>，将刚刚复制的文本复制到Key方框内，Title可随意填写。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/3.png" alt="配置SSH Key"></p>
<p>​    下面来检测一下是否通过SSH连接成功</p>
<p>​    <code>$ ssh -T git@github.com # 无需更改git@github.com</code></p>
<p>​    应该会提示 <code>Are you sure you want to continue connecting (yes/no)?</code> 输入yes，提示<code>Hi Zam90! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>说明SSH配置成功，然后输入以下指令</p>
<pre><code>$ git config --global user.name &quot;Username&quot;// 你的github用户名，注意不是昵称
$ git config --global user.email  &quot;xxx@xxx.com&quot;// 填写已经验证过的github注册邮箱</code></pre><h3 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h3><p>​    在电脑中新建一个文件夹（名字随意），但创建好之后无法随意更改，所以考虑好建在一个合适的位置。以我的<code>F:\Hexo</code>为例来做说明。</p>
<pre><code>$ cd /f/Hexo/  #跳转到文件夹位置
$ hexo init  #在此文件内创建Hexo工作区</code></pre><p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/4.png" alt="创建Hexo工作区"></p>
<p>​    创建完成后文件夹内应该有以上内容（除了public）</p>
<p>​    然后执行以下指令</p>
<p>​    <code>$ hexo g # 生成Hexo博客文件</code></p>
<p>​    此时Hexo会自动在public文件夹内生成博客文件</p>
<p>​    <code>$ hexo s # 启动本地预览服务</code></p>
<p>​    此时打开浏览器访问<code>localhost:4000</code>，可以看到默认生成的博客主页</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/5.png" alt="默认博客主页"></p>
<h3 id="上传博客至GitHub"><a href="#上传博客至GitHub" class="headerlink" title="上传博客至GitHub"></a>上传博客至GitHub</h3><h4 id="Git-bash上传"><a href="#Git-bash上传" class="headerlink" title="Git bash上传"></a>Git bash上传</h4><p>​    首先，验证你的SSH成功配置</p>
<p>​    然后用记事本打开Hexo工作区内的配置文件 <code>_config.yml</code> ，修改<code>deploy</code>部分：</p>
<pre><code>deploy:
  type: git
  repository: git@github.com:zam90/zam90.github.io.git
  branch: master</code></pre><p>​    然后在Git bash中输入</p>
<p>​    <code>hexo d</code></p>
<p>​    如报错： <code>Deployer not found: github 或者 Deployer not found: git</code> </p>
<p>​    输入以下指令安装插件解决：</p>
<p>​    <code>npm install hexo-deployer-git --save</code></p>
<p>​    然后再次<code>Hexo d</code>就可以了。</p>
<h4 id="GitHub-Desktop上传"><a href="#GitHub-Desktop上传" class="headerlink" title="GitHub Desktop上传"></a>GitHub Desktop上传</h4><p>​    自从GitHub Desktop上线后，上传代码就有了更方便的选择。</p>
<p>​    安装GitHub Desktop后，clone你的username.github.io仓库到Hexo工作区内的public文件夹，这样<code>Hexo g</code>后public文件夹内的新文件就会被GitHub Desktop检测到：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/6.png" alt="GitHub Desktop端"></p>
<p>​    然后输入Summary，点击Fetch origin就可以直接上传。</p>
<p>​    当然你也可以选择不把仓库clone到public文件夹内。clone时选择其他文件夹，然后把public内的文件复制到那个clone的文件夹，然后依然可以用GitHub Desktop上传。</p>
<h3 id="检测连接"><a href="#检测连接" class="headerlink" title="检测连接"></a>检测连接</h3><p>​    尝试访问<a href="https://username.github.io，如果成功显示和本地预览相同的界面说明博客搭建成功！" target="_blank" rel="noopener">https://username.github.io，如果成功显示和本地预览相同的界面说明博客搭建成功！</a></p>
<h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><h3 id="在启动本地预览界面后访问localhost-4000显示空白界面"><a href="#在启动本地预览界面后访问localhost-4000显示空白界面" class="headerlink" title="在启动本地预览界面后访问localhost:4000显示空白界面"></a>在启动本地预览界面后访问localhost:4000显示空白界面</h3><p>​    如打开页面显示为空白界面，大概率因为4000端口被占用，执行<code>$ hexo server -p 5000</code>，然后访问localhost:5000。</p>
<h3 id="Git上传失败"><a href="#Git上传失败" class="headerlink" title="Git上传失败"></a>Git上传失败</h3><p>​    请检查SSH Key的配置是否生效。同时注意修改Hexo工作区内的配置文件 <code>_config.yml</code> 。</p>
<p>​    修改<code>deploy</code>部分时：</p>
<pre><code>deploy:
  type: git
  repository: git@github.com:zam90/zam90.github.io.git
  branch: master</code></pre><p>​    注意<code>repository:</code>处不要写成 <code>repository: https:</code>（我遇过的坑）</p>
<h3 id="博客上传成功后访问时收到GitHub的Error邮件"><a href="#博客上传成功后访问时收到GitHub的Error邮件" class="headerlink" title="博客上传成功后访问时收到GitHub的Error邮件"></a>博客上传成功后访问时收到GitHub的Error邮件</h3><p>​    如收到GitHub的以下邮件：（我遇过的坑）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/7.jpg" alt="Error邮件"></p>
<p>​    请到<code>Hexo工作区—themes/landscape</code>下删除README.md文件后尝试重新上传，此问题可能是index.html与README.md文件冲突导致。</p>
<h3 id="博客上传成功后访问时收到GitHub的Warning邮件"><a href="#博客上传成功后访问时收到GitHub的Warning邮件" class="headerlink" title="博客上传成功后访问时收到GitHub的Warning邮件"></a>博客上传成功后访问时收到GitHub的Warning邮件</h3><p>​    如收到GitHub的以下邮件：（我遇过的坑）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/8.jpg" alt="Warning邮件"></p>
<p>​    请尝试重新配置SSH Key文件，并使用Git for Windows上传博客。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>​    如有其他问题，请参考<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">官方文档</a>，逐一排查尝试解决。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    至此个人博客已经搭建完成，在后续的文章中我会详细讲解如何更换博客主题、写博客、创建新页面、不使用外链插入图片……感谢您的持续关注！</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/23/2-A-detailed-tutorial-on-building-a-personal-blog-with-GitHub-Hexo">https://zam9036.gitee.io/2019/10/23/2-A-detailed-tutorial-on-building-a-personal-blog-with-GitHub-Hexo</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客|Zam9036博客</title>
    <url>/2019/10/23/1-First-blog/</url>
    <content><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>​    这是第一篇博客，网站已经能够稳定运行，博客系统可以使用。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/23/1-First-blog">https://zam9036.gitee.io/2019/10/23/1-First-blog</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>文章随笔</category>
      </categories>
  </entry>
  <entry>
    <title>关于About|Zam9036博客</title>
    <url>/about/index.html</url>
    <content><![CDATA[<img src="https://zam9036.gitee.io/img/avatar.png" style="height: 100px; width: 100px; border-radius: 50%; margin-bottom: 15px" />

<h3 id="欢迎Welcome"><a href="#欢迎Welcome" class="headerlink" title="欢迎Welcome"></a><code>欢迎Welcome</code></h3><p>​    欢迎来到<b style="color: #42d2ca"> <strong>Zam9036的博客</strong> </b>，在这里记录了一些生活的点滴和技术Demo。</p>
<p>​    Welcome to the <b style="color: #42d2ca"> <strong>Zam9036’s Blog</strong> </b>, where you’ll find something for life and some demo.</p>
<h3 id="个人介绍Introduction"><a href="#个人介绍Introduction" class="headerlink" title="个人介绍Introduction"></a><code>个人介绍Introduction</code></h3><p>​    我是Zam9036，是一个主修计算机科学与技术专业的学生</p>
<p>​    我的微信公众号：<b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>；</p>
<img src="https://zam9036.gitee.io/img/OfficialAccountQRCode.png" style="height: 150px; width: 525px; margin-bottom: 15px" />

<p>​    微信小程序：<b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>，欢迎大家关注！</p>
<img src="https://zam9036.gitee.io/img/MiniProgramQRCode.png" style="height: 150px; width: 525px; margin-bottom: 15px" />

<p>​    I am Zam9036, and I am a student majoring in computer science and technology.</p>
<p>​    My WeChat  Official Accounts : <b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>; </p>
<p>​    WeChat mini program : <b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>, welcome everyone to follow and pay attention!</p>
<h3 id="移动端APP-for-Android"><a href="#移动端APP-for-Android" class="headerlink" title="移动端APP for Android"></a><code>移动端APP for Android</code></h3><p>​    2019.11.3日，Zam9036正式推出了<b style="color: #42d2ca"> <strong>博客的Android端</strong> </b>，欢迎大家下载~</p>
<p>​    On 2019.11.3, Zam9036 officially launched <b style="color: #42d2ca"> <strong>the Android APP of the blog</strong> </b>, welcome everyone to download ~</p>
<p>​    <a href="https://pan.baidu.com/s/1wT_aJCdWudE73XFQL5FtwQ" target="_blank" rel="noopener"><code>下载地址Download</code></a></p>
<h3 id="PC端Program-for-Windows"><a href="#PC端Program-for-Windows" class="headerlink" title="PC端Program for Windows"></a><code>PC端Program for Windows</code></h3><p>​    2020.2.26日，Zam9036正式推出了<b style="color: #42d2ca"> <strong>博客的Windows端应用程序</strong> </b>，欢迎大家下载~</p>
<p>​    On 2020.2.26, Zam9036 officially launched <b style="color: #42d2ca"> <strong>the program for Windows of the blog</strong> </b>, welcome everyone to download ~</p>
<p>​    <a href="https://pan.baidu.com/s/1Xu6RipR8s7ulec3GHSWQ3w" target="_blank" rel="noopener"><code>下载地址Download</code></a> 提取码：ynuq</p>
<h3 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a><code>原创声明</code></h3><p>​    博客作者：<b style="color: #42d2ca"> <strong>Zam9036</strong> </b></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam90.github.io/" target="_blank" rel="noopener">Zam9036的博客</a>！</p>
]]></content>
  </entry>
  <entry>
    <title>时间轴Archives|Zam9036博客</title>
    <url>/archives/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签Tags|Zam9036的博客</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分类Categories|Zam9036博客</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
