<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据库SQL Server的安装与使用|Zam9036博客</title>
    <url>/2020/03/03/29-Installation-and-use-of-SQL-Server/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="版本平台"><a href="#版本平台" class="headerlink" title="版本平台"></a>版本平台</h1><p>Windows</p>
<p>SQL Server 2019 Developer</p>
<p>SQL Server Management Studio 18.4</p>
<h1 id="SQL-Server介绍"><a href="#SQL-Server介绍" class="headerlink" title="SQL Server介绍"></a>SQL Server介绍</h1><p>SQL是英文Structured Query Language的缩写，意思为结构化查询语言。SQL语言的主要功能就是同各种数据库建立联系，进行沟通。按照ANSI(美国国家标准协会)的规定，SQL被作为关系型数据库管理系统的标准语言。SQL Server是由Microsoft开发和推广的关系数据库管理系统（RDBMS）。</p>
<h1 id="SQL-Server安装"><a href="#SQL-Server安装" class="headerlink" title="SQL Server安装"></a>SQL Server安装</h1><h2 id="下载SQL-Server"><a href="#下载SQL-Server" class="headerlink" title="下载SQL Server"></a>下载SQL Server</h2><p>访问<a href="https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads" target="_blank" rel="noopener">SQL Server官网</a>，下载SQL Server，我选择下载的是SQL Server 2019 Developer。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/1.png" alt="SQL Server官网"></p>
<h2 id="启动安装"><a href="#启动安装" class="headerlink" title="启动安装"></a>启动安装</h2><p>下载完成后，运行安装程序，选择“基本安装”</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/2.png" alt="基本安装"></p>
<p>同意服务条款后，指定SQL Server的安装位置</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/3.png" alt="安装位置"></p>
<p>然后程序会自动下载安装程序包，并自动安装</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/4.png" alt="下载安装包"></p>
<p>在安装的时候，部分程序操作可能会被安全软件拦截，请及时赋予安装程序必要的权限</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/5.png" alt="操作拦截"></p>
<p>安装完成</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/6.png" alt="安装完成"></p>
<h1 id="安装SQL-Server-Management-Studio"><a href="#安装SQL-Server-Management-Studio" class="headerlink" title="安装SQL Server Management Studio"></a>安装SQL Server Management Studio</h1><h2 id="下载SSMS"><a href="#下载SSMS" class="headerlink" title="下载SSMS"></a>下载SSMS</h2><p>可以访问<a href="https://docs.microsoft.com/zh-cn/sql/ssms/download-sql-server-management-studio-ssms?redirectedfrom=MSDN&view=sql-server-ver15" target="_blank" rel="noopener">SSMS官网</a>下载SMSS，也可以点击SQL Server完成安装时的安装SSMS按钮下载安装。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/7.png" alt="SSMS官网"></p>
<h2 id="启动安装-1"><a href="#启动安装-1" class="headerlink" title="启动安装"></a>启动安装</h2><p>下载完成后，运行安装软件，启动安装，并选择安装位置</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/8.png" alt="SSMS安装位置"></p>
<p>开始安装</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/9.png" alt="SSMS安装"></p>
<p>安装完毕</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/10.png" alt="SSMS安装位置"></p>
<h1 id="使用SQL-Server"><a href="#使用SQL-Server" class="headerlink" title="使用SQL Server"></a>使用SQL Server</h1><p>SQL Server是数据库本体，SSMS是SQL Server的数据库管理系统</p>
<p>启动SSMS，连接数据库，开始使用数据库吧！</p>
<p><img src="https://zam9036.gitee.io/img/postimg/29-Installation-and-use-of-SQL-Server/11.png" alt="SSMS连接数据库"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/03/03/29-Installation-and-use-of-SQL-Server">https://zam9036.gitee.io/2020/03/03/29-Installation-and-use-of-SQL-Server</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL Server</tag>
        <tag>课程:数据库原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析知识汇总（一）|Zam9036博客</title>
    <url>/2020/02/27/28-Algorithm-design-and-analysis-study-notes-1/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h1><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><ul>
<li>算法是解决问题的一种方法或一个过程。</li>
<li>算法是若干指令的有穷序列。</li>
<li>算法是以一步接一步的方式来详细描述计算机如何将输入转化为所要求的输出的过程。</li>
<li>算法是对计算机上执行的计算过程的具体描述。</li>
</ul>
<h2 id="算法的性质"><a href="#算法的性质" class="headerlink" title="算法的性质"></a>算法的性质</h2><ul>
<li><strong>输入</strong>：算法的输入由零个和多个外部量提供。</li>
<li><strong>输出</strong>：算法产生至少一个量作为输出。</li>
<li><strong>确定性</strong>：组成算法的每条指令清晰、无歧义。</li>
<li><strong>有限性</strong>：算法中<strong>每条指令</strong>的执行次数和执行时间都是有限的。</li>
</ul>
<h2 id="程序概述"><a href="#程序概述" class="headerlink" title="程序概述"></a>程序概述</h2><p>程序是算法用某种程序设计语言的具体实现。</p>
<blockquote>
<p>注意：程序可以不满足算法的第4条性质“有限性”，即程序可以是无限循环的。</p>
<p>例如操作系统就是一个在无限循环中执行的程序。</p>
</blockquote>
<h2 id="研究算法的必要性"><a href="#研究算法的必要性" class="headerlink" title="研究算法的必要性"></a>研究算法的必要性</h2><p>高效的算法可以节省时间和存储空间</p>
<h1 id="算法复杂性分析"><a href="#算法复杂性分析" class="headerlink" title="算法复杂性分析"></a>算法复杂性分析</h1><h2 id="算法分析概述"><a href="#算法分析概述" class="headerlink" title="算法分析概述"></a>算法分析概述</h2><p>算法分析是研究算法对计算机资源进行使用的理论，是对算法运行所需要的计算机资源的量的预测。</p>
<h2 id="算法复杂性"><a href="#算法复杂性" class="headerlink" title="算法复杂性"></a>算法复杂性</h2><p>算法复杂性即算法运行所需要的计算机资源的量。</p>
<ul>
<li>需要时间资源的量称为<strong>时间复杂性T(n)</strong>。</li>
<li>需要空间资源的量称为<strong>空间复杂性S(n)</strong>。</li>
<li>n为问题的规模，即输入的大小。</li>
</ul>
<h2 id="研究算法的复杂性-性能、效率-的必要性"><a href="#研究算法的复杂性-性能、效率-的必要性" class="headerlink" title="研究算法的复杂性(性能、效率)的必要性"></a>研究算法的复杂性(性能、效率)的必要性</h2><ul>
<li>性能有时决定系统是否可行。</li>
</ul>
<blockquote>
<p>实时系统中若性能低下，则导致系统不可行。</p>
</blockquote>
<ul>
<li>性能是许多重要特性的基础。</li>
</ul>
<blockquote>
<p>如：用户体验。</p>
</blockquote>
<h2 id="算法分析的基本问题"><a href="#算法分析的基本问题" class="headerlink" title="算法分析的基本问题"></a>算法分析的基本问题</h2><ul>
<li><p>怎样评价一个问题的难易程度？</p>
</li>
<li><p>怎样评价一个算法的好与坏？</p>
</li>
<li><p>对于一个问题怎样知道哪个算法是最优的？</p>
</li>
</ul>
<blockquote>
<p>即解同样的问题是否存在其他更好的算法</p>
</blockquote>
<h2 id="算法执行时间相关的因素"><a href="#算法执行时间相关的因素" class="headerlink" title="算法执行时间相关的因素"></a>算法执行时间相关的因素</h2><ul>
<li>问题的规模(N)</li>
</ul>
<blockquote>
<p>排序问题中，需要排序的数：10 vs.  $10^6$</p>
</blockquote>
<ul>
<li>算法的输入(I)</li>
</ul>
<blockquote>
<p>排序问题中，输入已排序、逆序的情况</p>
</blockquote>
<ul>
<li>算法选用的策略(A)</li>
</ul>
<p>T(N,I,A)，算法执行时间和问题的规模、算法的输入、算法选用的策略有关</p>
<h2 id="算法的时间复杂性"><a href="#算法的时间复杂性" class="headerlink" title="算法的时间复杂性"></a>算法的时间复杂性</h2><h3 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h3><p>Tmin (n): 输入规模为n时，程序运行可能消耗的最短时间</p>
<blockquote>
<p>具有欺骗性，可能只对某些特定输入起作用</p>
</blockquote>
<h3 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>Tmax (n): 输入规模为n时，程序运行可能消耗的最长时间</p>
<blockquote>
<p>可视为对用户提供的一种承诺</p>
</blockquote>
<h3 id="平均情况"><a href="#平均情况" class="headerlink" title="平均情况"></a>平均情况</h3><p>Tavg(n): 输入规模为n时，所有可能输入的期望时间</p>
<p>期望时间：$\sum$每种可能出现的输入消耗的时间*出现的概率</p>
<p>以上三种情况衡量算法的时间复杂性<strong>可操作性最好，具有实际价值</strong>。</p>
<h3 id="算法的渐进复杂性"><a href="#算法的渐进复杂性" class="headerlink" title="算法的渐进复杂性"></a>算法的渐进复杂性</h3><p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/1.png" alt="算法渐进复杂性1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/2.png" alt="算法渐进复杂性2"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/28-Algorithm-design-and-analysis-study-notes-1/3.png" alt="算法渐进复杂性3"></p>
<blockquote>
<p>渐进复杂性：复杂性中的最高阶项</p>
<p>对算法的分析主要是考虑算法的渐进复杂性</p>
</blockquote>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/02/27/28-Algorithm-design-and-analysis-study-notes-1">https://zam9036.gitee.io/2020/02/27/28-Algorithm-design-and-analysis-study-notes-1</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>课程:算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统在Windows虚拟机上的安装|Zam9036博客</title>
    <url>/2020/02/25/27-Linux-system-installation-on-Windows-virtual-machine/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="平台与工具"><a href="#平台与工具" class="headerlink" title="平台与工具"></a>平台与工具</h1><p>Windows 10</p>
<p>Oracle VM VirtualBox 6.1 虚拟机</p>
<p>Ubuntukylin 19.10 Linux系统镜像文件</p>
<h1 id="虚拟机安装与使用"><a href="#虚拟机安装与使用" class="headerlink" title="虚拟机安装与使用"></a>虚拟机安装与使用</h1><h2 id="下载安装VirtualBox"><a href="#下载安装VirtualBox" class="headerlink" title="下载安装VirtualBox"></a>下载安装VirtualBox</h2><p>访问<a href="https://www.virtualbox.org/" target="_blank" rel="noopener">Oracle VM VirtualBox官方网站</a>，下载VM VirtualBox，我使用的版本是6.1。浏览英文网页如有困难，可以尝试使用Google/有道的网页翻译功能。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/1.png" alt="下载Oracle VM VirtualBox"></p>
<p>下载完成后，按照提示安装即可，在此不过多赘述。</p>
<blockquote>
<p>注意：安装Oracle VM VirtualBox的时候会重置网络连接状态，并且可能会要求重启电脑。</p>
</blockquote>
<h2 id="VirtualBox的使用"><a href="#VirtualBox的使用" class="headerlink" title="VirtualBox的使用"></a>VirtualBox的使用</h2><p>安装完成后启动Oracle VM VirtualBox虚拟机控制台，如下图所示。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/2.png" alt="VirtualBox控制台1"></p>
<blockquote>
<p>左侧列表是已经安装过的虚拟机</p>
<p>如图，我已经安装了Windows 95、MS-DOS 6.22、MS_DOS 3.30、Ubuntu-18.04</p>
</blockquote>
<p>点击对应的虚拟机，可以看到相应的虚拟机状态和所设置的参数。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/3.png" alt="VirtualBox控制台2"></p>
<h1 id="Linux系统在虚拟机上的安装"><a href="#Linux系统在虚拟机上的安装" class="headerlink" title="Linux系统在虚拟机上的安装"></a>Linux系统在虚拟机上的安装</h1><h2 id="下载Linux系统"><a href="#下载Linux系统" class="headerlink" title="下载Linux系统"></a>下载Linux系统</h2><p>我以 Ubuntukylin 19.10作为例子演示，其他系统类似。从<a href="https://www.ubuntukylin.com/" target="_blank" rel="noopener">Ubuntukylin官网</a>上下载Linux系统的ISO镜像文件，储存备用。</p>
<h2 id="配置虚拟电脑"><a href="#配置虚拟电脑" class="headerlink" title="配置虚拟电脑"></a>配置虚拟电脑</h2><p>打开Oracle VM VirtualBox控制器，点击<code>工具-新建</code>（快捷键Ctrl+N），输入系统名称（系统安装完成后会在左侧列表显示）、Linux系统文件的安装路径（类似于Windows的C盘）、选择系统类型和版本。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/4.png" alt="准备配置虚拟电脑"></p>
<p>选择分配给该虚拟电脑的运行内存大小。</p>
<blockquote>
<p>运行内存分配后不会立即占用，只有启动该系统的时候才会占用。</p>
<p>分配给虚拟电脑的内存建议2G+，4G-6G为最佳，请根据电脑配置自行决策（我电脑16G运行内存，分配给虚拟电脑6G）</p>
<p>运行内存分配不合理可能导致Windows系统崩溃</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/5.png" alt="分配内存大小"></p>
<p>选择是否创建虚拟硬盘（即该虚拟电脑的存储硬盘），若之前没有添加过虚拟电脑，建议添加一个虚拟硬盘；若之前添加过虚拟电脑，可以使用之前创建的虚拟硬盘。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/6.png" alt="创建虚拟硬盘"></p>
<p>选择新建虚拟磁盘的文件类型，一般默认即可。</p>
<blockquote>
<p>选用VHD或VMDK可以让其他的虚拟化软件访问新建的虚拟硬盘（但一般不需要）</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/7.png" alt="选择虚拟硬盘文件类型"></p>
<p>选择虚拟硬盘的分配方式，建议使用动态分配。</p>
<blockquote>
<p>动态分配：虚拟磁盘逐步占用物理磁盘空间（至分配的数值为止）【需要多少 使用多少】</p>
<p>固定分配：一次性占用相应的物理磁盘空间【全部占用，不需要的也先占上】</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/8.png" alt="选择虚拟硬盘分配方式"></p>
<p>选择分配给虚拟磁盘的空间大小，建议10G+</p>
<blockquote>
<p>请根据所装系统和电脑配置自行决策</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/9.png" alt="分配虚拟硬盘空间大小"></p>
<h2 id="选择启动盘"><a href="#选择启动盘" class="headerlink" title="选择启动盘"></a>选择启动盘</h2><p>配置完虚拟电脑，我们就拥有一台属于自己的崭新“计算机”（我的是6G+20G喔），那么下一步，就是安装操作系统。这个时候我们刚刚下载完成的ISO文件就起到用途了。</p>
<p>左侧列表点击我们刚刚配置好的虚拟电脑，可以看到相应的配置。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/10.png" alt="查看虚拟电脑配置"></p>
<p>点击右上方的启动按钮（快捷键Ctrl+T），尝试启动“计算机”，这个时候会提示选择启动盘</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/11.png" alt="选择启动盘1"></p>
<p>点击右方的浏览启动盘图标，弹出以下窗口，这个窗口就是启动盘选择窗口，可以看到都是后缀为.iso的文件。我们发现并没有刚刚下载的iso文件，那是因为刚刚那张“光盘”的数据并没有在虚拟机上</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/12.png" alt="选择启动盘2"></p>
<p>点击注册按钮，选择刚刚下载ISO文件的路径（模仿真实安装计算机时的操作系统安装盘的插入），这个时候会出现如下进度条，这表示正在准备读取“操作系统安装盘”</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/13.png" alt="注册启动盘"></p>
<p>然后返回刚刚的选择启动盘窗口，选择刚刚下载的ISO文件</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/14.png" alt="选择启动盘3"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/15.png" alt="选择启动盘4"></p>
<p>点击启动，待ISO文件读取完毕后，就会显示Ubuntu的界面，表示可以配置安装系统了</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/16.png" alt="启动成功界面"></p>
<h1 id="Linux系统配置"><a href="#Linux系统配置" class="headerlink" title="Linux系统配置"></a>Linux系统配置</h1><p>在弹出启动成功界面后不久，我们就会看到Ubuntu的安装界面，提示我们选择语言和安装方式（当然是选择中文简体+安装【英语大佬请选择英文】）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/17.png" alt="选择语言和安装方式"></p>
<p>然后选择键盘布局（汉语-汉语）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/18.png" alt="选择键盘布局"></p>
<p>选择更新和其他软件（看心情选吧）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/19.png" alt="选择更新和其他软件"></p>
<p>选择安装类型（因为我们的虚拟电脑是“崭新的”，所以选择清除磁盘并安装即可）</p>
<blockquote>
<p>注意：在选择是否创建虚拟硬盘的时候，如果选择选择否，请重视此选项，并视情况做决定</p>
</blockquote>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/20.png" alt="选择安装类型"></p>
<p>选择地区</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/21.png" alt="选择地区"></p>
<p>设置用户和密码</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/22.png" alt="设置用户和密码"></p>
<p>开始安装！（预计20分钟-30分钟），并且需要根据提示进行重启</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/23.png" alt="提示重启"></p>
<p>安装成功！终于来到了系统桌面！</p>
<p><img src="https://zam9036.gitee.io/img/postimg/27-Linux-system-installation-on-Windows-virtual-machine/24.png" alt="系统桌面"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/02/25/27-Linux-system-installation-on-Windows-virtual-machine">https://zam9036.gitee.io/2020/02/25/27-Linux-system-installation-on-Windows-virtual-machine</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>虚拟机</tag>
        <tag>操作系统</tag>
        <tag>课程:Linux系统实践</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识汇总（一）|Zam9036博客</title>
    <url>/2020/02/24/26-Computer-network-study-notes-1/</url>
    <content><![CDATA[<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/wordCloud.png" alt="文章词云"></p>
<p>[TOC]</p>
<h1 id="计算机网络的概念与组成"><a href="#计算机网络的概念与组成" class="headerlink" title="计算机网络的概念与组成"></a>计算机网络的概念与组成</h1><h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><p>计算机网络系统是将地理位置不同的<strong>多个计算机系统</strong>，通过<strong>通信设备</strong>和<strong>线路</strong>连接起来，并配以功能完善的<strong>网络软件</strong>(如网络操作系统等)，按照一定的<strong>协议</strong>实现<strong>相互通信和资源共享</strong>的<strong>系统</strong>，称为计算机网络系统。 </p>
<blockquote>
<p>计算机网络的功能：相互通信、资源共享</p>
</blockquote>
<h3 id="计算机网络的应用"><a href="#计算机网络的应用" class="headerlink" title="计算机网络的应用"></a>计算机网络的应用</h3><ul>
<li><p>进行各种规模和不同范围的信息管理：教务管理系统、企业管理系统、办公自动化……</p>
</li>
<li><p>进行信息/文献检索：时事新闻、市场商情、产品需求、图书、期刊、专业型动态数据</p>
</li>
<li><p>电子数据交换：电子政务、电子商务、联网售票、网络直播</p>
</li>
<li><p>实现不同范围的监测、数据传递、信息处理与反馈控制 </p>
</li>
<li><p>提供分布式计算和分布式处理的环境 ：集群机、网格、云</p>
</li>
<li><p>计算机综合(集成)制造系统(CIMS) </p>
</li>
</ul>
<h4 id="计算机网络的重要性"><a href="#计算机网络的重要性" class="headerlink" title="计算机网络的重要性"></a>计算机网络的重要性</h4><ul>
<li><p>国家（经济、军事、科技、公用事业等）的重要基础设施和命脉</p>
</li>
<li><p>战争的首要攻击目标（网络部队、网络司令部）</p>
</li>
<li><p>企业、公众的依赖</p>
</li>
<li><p>公共安全、社会稳定(公安网监）</p>
</li>
</ul>
<h3 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h3><ul>
<li>网络硬件：计算机、通信设备、通信线路</li>
<li>网络软件：网络操作系统</li>
<li>网络协议</li>
</ul>
<blockquote>
<p>网络软件硬件的关系：相辅相成，缺一不可</p>
<p>网络协议：网络中各部分必须遵守的规定，必不可少！</p>
</blockquote>
<h4 id="网络硬件"><a href="#网络硬件" class="headerlink" title="网络硬件"></a>网络硬件</h4><h5 id="客户机（Client）"><a href="#客户机（Client）" class="headerlink" title="客户机（Client）"></a>客户机（Client）</h5><ul>
<li>PC、PDA、智能设备(仪器/仪表-&gt;嵌入式系统)、智能手机</li>
<li>中、大型机、（专业）工作站</li>
</ul>
<h5 id="数据传输介质"><a href="#数据传输介质" class="headerlink" title="数据传输介质"></a>数据传输介质</h5><p>有线介质：通信电缆（双绞线、同轴电缆等）通信光缆</p>
<p>无线介质：空气（电磁波、微波）</p>
<h5 id="网络接口单元（NIU）-、通信控制器、网卡"><a href="#网络接口单元（NIU）-、通信控制器、网卡" class="headerlink" title="网络接口单元（NIU） 、通信控制器、网卡"></a>网络接口单元（NIU） 、通信控制器、网卡</h5><p>功能：通信管理与控制，保证通信对用户的透明性</p>
<h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p>主要作用：提供多个端口，连接多台设备，实现数据转接(交换)</p>
<p>分类：接入 (边缘)交换机、汇聚 (分支)交换机、核心交换机</p>
<p>工作原理：电路交换方式，存储转发交换方式(报文交换、分组交换)</p>
<p>主要厂家：Cisco、Juniper、华为、锐捷、神码、H3C、TP-LINK</p>
<h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><p>作用：为网络用户提供各种资源和服务</p>
<p>资源：网络打印机、存储空间（网盘）、软件、数据……</p>
<p>服务：信息浏览、文件传输、电子邮件、远程登录、视频信息和各种有针对性的信息服务……</p>
<blockquote>
<p>相应的服务器：Web、FTP、E-Mail、Telnet、视频、DNS、DBMS</p>
<p>提供相应的服务，就需要相应的服务器</p>
<p>一台物理服务器（高性能），可以提供多种服务</p>
<p>可通过服务器集群，提供多种服务</p>
</blockquote>
<p>服务器形式：</p>
<ul>
<li>专业生产的高性能服务器：浪潮、HP、SUN、IBM……</li>
</ul>
<blockquote>
<p>技术：对称多处理器、RAID技术、SCSI卡、冗余电源</p>
</blockquote>
<ul>
<li>PC机、大、中、小型机</li>
</ul>
<p>服务器架构</p>
<p>原理分类：复杂指令集(CISC) 、精简指令集(RISC)、并行指令集(VLIW)</p>
<p>架构分类：【复杂指令集(CISC)】Intel架构(入门、工作组）、【精简指令集(RISC)】UNIX架构（企业级）</p>
<h5 id="网络互联设备"><a href="#网络互联设备" class="headerlink" title="网络互联设备"></a>网络互联设备</h5><p><strong>路由器（Router）</strong></p>
<p>作用：连接多个网络或网段，从而形成网络的网络——<strong>因特网</strong></p>
<p>主要厂家：Cisco、华为、锐捷……</p>
<p><strong>集线器</strong>：实现设备共享接入</p>
<p><strong>无线接入点（AP）</strong>：无线设备共享接入</p>
<p><strong>网桥</strong>：将局域网分隔成多个网段，减少冲突范围</p>
<p><strong>防火墙、入侵检测/防御、UTM</strong>：保护网络安全</p>
<blockquote>
<p>防火墙：防止外部网络访问内网（需要VPN才能访问）</p>
</blockquote>
<p><strong>光电耦合器(Net-Bridge)</strong>：光信号-电信号转换</p>
<h4 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h4><p>分类：</p>
<ul>
<li>网络系统软件</li>
<li>网络环境软件</li>
<li>网络应用软件</li>
</ul>
<h5 id="网络系统软件"><a href="#网络系统软件" class="headerlink" title="网络系统软件"></a>网络系统软件</h5><p>网络操作系统：用于管理网络的各种资源和网络的正常运行。</p>
<p>典型的产品：Windows NT/2000/2003/Vista/Windows 7(8)、Netware、Unix、Linux等。—— 缺少国产，存在风险!!!</p>
<p>组成：</p>
<ul>
<li>网络操作系统<strong>内核</strong>（服务器软件，工作于服务器之上）</li>
<li>网络操作系统<strong>外壳</strong>（客户机软件，工作于客户机之上）</li>
</ul>
<p>—— 并通过它们的配合来完成网络管理工作。</p>
<h5 id="网络环境软件"><a href="#网络环境软件" class="headerlink" title="网络环境软件"></a>网络环境软件</h5><p>构成网络应用环境的各种软件，用户由此可以方便地使用网络，进行各种操作，并开发各种应用软件。</p>
<p>典型的产品：Internet Explore、Netscape 、J2EE、.NET Framework等。</p>
<h5 id="网络应用软件"><a href="#网络应用软件" class="headerlink" title="网络应用软件"></a>网络应用软件</h5><p>针对各种实际网络应用环境而开发的面向应用的软件。——如前面提到的公文管理软件、教务管理软件、科研管理、ERP、MES等。</p>
<h4 id="网络协议-标准"><a href="#网络协议-标准" class="headerlink" title="网络协议/标准"></a>网络协议/标准</h4><p>产品化的需求</p>
<p><strong>标准化组织及相应的协议</strong></p>
<p>国际标准化组织(ISO/TC97/SC16)：OSI/RM</p>
<p>国际电信联盟电信标准化局(ITU-T)：V系列，X系列，…</p>
<p>美国国家标准学会(ANSI) ：</p>
<ul>
<li><p>电气电子工程师学会(IEEE) ：IEEE802系列局域网标准</p>
</li>
<li><p>电子工业学会(EIA)：EIA RS-232接口标准</p>
</li>
<li><p>通信工业学会(TIA)：EIA/TIA 568A(B) 布线标准</p>
</li>
</ul>
<p><strong>企业</strong></p>
<p>Novell：IPX/SPX，Microsoft：NETBEAU……</p>
<p><strong>民间组织</strong></p>
<p>ISOC：Internet(TCP/IP)，各种联盟</p>
<h5 id="Internet组织机构"><a href="#Internet组织机构" class="headerlink" title="Internet组织机构"></a>Internet组织机构</h5><p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/1.png" alt="Internet组织机构"></p>
<h5 id="Internet标准化过程"><a href="#Internet标准化过程" class="headerlink" title="Internet标准化过程"></a>Internet标准化过程</h5><blockquote>
<p>因特网草案(Internet Draft)<br>↓<br>建议标准(Proposed Standard) —— RFC 文档<br>↓<br>草案标准(Draft Standard)<br>↓<br>因特网标准(Internet Standard) </p>
</blockquote>
<h4 id="计算机网络的逻辑组成"><a href="#计算机网络的逻辑组成" class="headerlink" title="计算机网络的逻辑组成"></a>计算机网络的逻辑组成</h4><p>计算机网络的主要功能：相互通信和资源共享</p>
<p>从逻辑上，划分两个子网：通信子网和资源子网</p>
<p><strong>通信子网</strong>：又称主干网络(Backborn)，主要由网络核心交换机、网络分支(边缘)交换机、网络主干线路(光缆或通信电缆) 和路由器(防火墙)等组成。—— 影响网络性能好坏的关键</p>
<p>主要任务：数据的交换、管理和控制</p>
<p><strong>资源子网</strong></p>
<p><strong>各种服务器及其接入子网</strong></p>
<p>目的：提供各种资源，如磁盘阵列、软件、数据等，以及共享网络打印机、音视频点播装置等。</p>
<p><strong>客户机及其接入子网</strong></p>
<p>主要任务：提供所需的软件、硬件以及数据等资源和服务，并进行各种数据处理 。 </p>
<p>逻辑划分意义：</p>
<p>在组建一个大型网络时，可以分而治之，减少复杂性。 </p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/2.png" alt="网络实例1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/3.png" alt="网络实例2"></p>
<h1 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h1><p>分类方法：</p>
<ul>
<li><strong>网络的地理覆盖范围</strong></li>
<li>网络的应用群体</li>
<li>网络的作用</li>
<li>网络的管理方式</li>
<li><strong>网络的拓扑结构形式</strong></li>
<li>网络的传输媒体</li>
</ul>
<h2 id="按照网络的地理覆盖范围分"><a href="#按照网络的地理覆盖范围分" class="headerlink" title="按照网络的地理覆盖范围分"></a>按照网络的地理覆盖范围分</h2><ul>
<li>广域网（Wide Area Network，WAN）</li>
<li>城域网（Metroplitan Area Network，MAN） </li>
<li>局域网（Local Area Network，LAN）</li>
<li>个人区域网 (Personal Area Network，PAN)</li>
<li>互联网（Internet) 【严格意义上不算】</li>
</ul>
<h3 id="广域网（WAN）"><a href="#广域网（WAN）" class="headerlink" title="广域网（WAN）"></a>广域网（WAN）</h3><p>跨度大：覆盖一个市、一个省，也可以覆盖一个国家、几个国家，甚至可以覆盖全世界。 </p>
<p>代表性网络：11个全国范围的互联网络，国家/省的公用/专用网络（如公安专网、银行专用网等）如：三大运营商、中国科学技术网（科研用）、中国长城网（军用）</p>
<h3 id="城域网（MAN）"><a href="#城域网（MAN）" class="headerlink" title="城域网（MAN）"></a>城域网（MAN）</h3><p>跨度介于广域网和局域网之间，覆盖距离一般为几十公里。</p>
<p>典型代表：城域教育网、城域党政信息网、公用宽带城域网等。满足城市地区范围内的某个特定行业、集团型企业、政府的网络需求。(如同城市的环城路，统一出口)</p>
<h3 id="局域网（LAN）"><a href="#局域网（LAN）" class="headerlink" title="局域网（LAN）"></a>局域网（LAN）</h3><p>跨度较小：通常限制在一个办公室或实验室、一个办公大楼，整个校园或企业，形成园区网（Intranet）。</p>
<p>覆盖距离一般不超过十公里。 </p>
<h3 id="个人区域网（PAN）"><a href="#个人区域网（PAN）" class="headerlink" title="个人区域网（PAN）"></a>个人区域网（PAN）</h3><p>将属于个人使用的电子设备用蓝牙、红外等无线技术连接起来形成的网络。覆盖范围一般不超过10米</p>
<p>典型代表：手机、笔记本电脑、PDA等。</p>
<h3 id="互联网（Internet"><a href="#互联网（Internet" class="headerlink" title="互联网（Internet)"></a>互联网（Internet)</h3><p>Internet实际上是由世界范围内众多计算机网络连接而成的网络，它并非一个具有独立形态的网络，而是由计算机网络汇合成的一个网络集合体。它<strong>难以区分边界，也没有必要区分边界</strong> 。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/4.png" alt="网络实例3"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/5.png" alt="互联网示意图"></p>
<h2 id="按网络的应用群体分"><a href="#按网络的应用群体分" class="headerlink" title="按网络的应用群体分"></a>按网络的应用群体分</h2><h3 id="公用网-public-network"><a href="#公用网-public-network" class="headerlink" title="公用网 (public network)"></a>公用网 (public network)</h3><p>可为所有公众提供有偿服务；通常跨度大，覆盖范围广。</p>
<h3 id="专用网-private-network"><a href="#专用网-private-network" class="headerlink" title="专用网 (private network)"></a>专用网 (private network)</h3><p>由某个机关/事业单位(部门)或企业(集团)自建自用。</p>
<h2 id="按网络的作用分"><a href="#按网络的作用分" class="headerlink" title="按网络的作用分"></a>按网络的作用分</h2><h3 id="骨-主-干网"><a href="#骨-主-干网" class="headerlink" title="骨(主)干网"></a>骨(主)干网</h3><p>网络核心，由大型（容量）交换机、通信基站、路由设备和大对数宽带（高速）主干光/电通信线缆（卫星）构成。</p>
<p>作用：数据的远程交换与传输</p>
<p>工作方式：路由交换</p>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>又称为本地接入网或居民接入网。</p>
<p>作用：让大量用户能够与因特网连接，起到“桥梁”作用。</p>
<p>典型代表：电话网ADSL、有线电视数据网、无线移动网 …</p>
<p>连接方式：通过ISP(Internet Service Provider)提供接入服务</p>
<h2 id="按网络的管理方式分"><a href="#按网络的管理方式分" class="headerlink" title="按网络的管理方式分"></a>按网络的管理方式分</h2><h3 id="对等网（P2P，Peer-to-Peer）"><a href="#对等网（P2P，Peer-to-Peer）" class="headerlink" title="对等网（P2P，Peer-to-Peer）"></a>对等网（P2P，Peer-to-Peer）</h3><p>特点：无主从之分，重在通信；系统小、价格低、使用便捷，无需管理。</p>
<p>适用范围：工作组间的协作与交流。</p>
<h3 id="非对等网（有服务器网络）"><a href="#非对等网（有服务器网络）" class="headerlink" title="非对等网（有服务器网络）"></a>非对等网（有服务器网络）</h3><p>特点：由服务器管理整个网络，重在资源共享与服务；功能强大、系统完善。</p>
<p>适用范围：面向大众用户。</p>
<p>服务器工作形式：并发方式和专用方式。</p>
<h2 id="按网络的拓扑结构分"><a href="#按网络的拓扑结构分" class="headerlink" title="按网络的拓扑结构分"></a>按网络的拓扑结构分</h2><h3 id="星形结构"><a href="#星形结构" class="headerlink" title="星形结构"></a>星形结构</h3><p>又称集中式网络。以一台网络设备为中心，其它所有要连网的计算机都与该中心网络设备相连。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/6.png" alt="星形结构"></p>
<h3 id="树形结构-——-从星形结构网络演变而来"><a href="#树形结构-——-从星形结构网络演变而来" class="headerlink" title="树形结构 —— 从星形结构网络演变而来"></a>树形结构 —— 从星形结构网络演变而来</h3><p>分级的集中式网络，每个上级网络设备都有对下级网络设备的管理和控制的能力，每个上级网络结点和它的所有下级网络结点都可以形成一个相对独立的集中式网络 。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/7.png" alt="树形结构"></p>
<h3 id="环形结构"><a href="#环形结构" class="headerlink" title="环形结构"></a>环形结构</h3><p>将所有要连网的计算机用一条或两条公用数据通道环接在一起而构成的单环或双环的网络。其网络控制一般分散到各结点 。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/8.png" alt="环形结构"></p>
<h3 id="总线式结构"><a href="#总线式结构" class="headerlink" title="总线式结构"></a>总线式结构</h3><p>将所有要连网的计算机通过一条公用数据通信线路连接在一起而形成的网络。—— 类似于计算机内部的总线结构。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/9.png" alt="总线式结构"></p>
<h3 id="分布式结构"><a href="#分布式结构" class="headerlink" title="分布式结构"></a>分布式结构</h3><p>网络没有固定的连接形式，各结点之间可能有多条路径相通。其路由选择是动态进行的，其信息流向是随机的。</p>
<h2 id="按网络的传输媒体分"><a href="#按网络的传输媒体分" class="headerlink" title="按网络的传输媒体分"></a>按网络的传输媒体分</h2><h3 id="有线网"><a href="#有线网" class="headerlink" title="有线网"></a>有线网</h3><p><strong>电缆网</strong></p>
<p>利用电信号表示和传输数据</p>
<p>优点：传输速度快；信息安全、稳定。</p>
<p>缺点：网络布线成本高，维护量大，施工困难。</p>
<p><strong>光传输（全光/光纤）网</strong></p>
<p>利用光信号表示和传输数据</p>
<p>优点：传输速度“极快”；信息安全、稳定。</p>
<p>缺点：线路成本高，维护量大，施工困难。</p>
<h3 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h3><p>利用电磁波或微波形式传输数据；</p>
<p>优点：不用布线，因而节省成本；尤其对于过河、过路以及历史建筑优势明显。</p>
<p>缺点：数据缺乏安全性，需加密；速度漫；范围小</p>
<p>标准：</p>
<ul>
<li>无线局域网802.11/a/b/g/n 11M → 54M →</li>
<li>宽带无线城域网802.16 (100M)→</li>
<li>无线个人局域网（基于蓝牙技术802.15，红外技术）</li>
</ul>
<h3 id="卫星网"><a href="#卫星网" class="headerlink" title="卫星网"></a>卫星网</h3><p>用于实现无线远程通信，无线通信的特例。</p>
<p>微波通信：</p>
<ul>
<li>要求接收天线与发送天线要互相可见</li>
<li>建立若干微波中继站， “接力” </li>
<li>形成微波中继系统</li>
</ul>
<p>卫星网特点：</p>
<ul>
<li>微波中继站在卫星上</li>
<li>利用卫星以微波形式传输数据</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/10.png" alt="卫星网"></p>
<h3 id="移动网"><a href="#移动网" class="headerlink" title="移动网"></a>移动网</h3><p>有线与无线的结合,电信网与计算机网(互联网)融合</p>
<ul>
<li>包括GSM、CDMA、GPRS等移动电信网</li>
<li>核心与基站之间为基于光传输的宽带主干网</li>
<li>基站与用户终端设备之间为基于电磁波传输的无线网</li>
</ul>
<h3 id="虚拟网"><a href="#虚拟网" class="headerlink" title="虚拟网"></a>虚拟网</h3><p><strong>虚拟局域网（VLAN）</strong>—— 企业内部局域网的一种实现形式</p>
<ul>
<li>虚拟网络是在整个网络中通过网络交换设备建立的虚拟工作组。与具体的物理网及地理位置无关。</li>
<li>实现部门或单位分布在不同位置情况的资源共享和访问。</li>
<li>将广播限制在虚拟工作组中，由于广播域的缩小，网络中广播包消耗带宽大大降低，网络的性能得到显著的提高。</li>
</ul>
<p><strong>虚拟专用网络（VPN）</strong> —— 企业外联网的一种实现</p>
<p>借助公网（Internet或其他网络）来形成企业专网或实现远程接入。</p>
<h3 id="企业内部网Intranet-企业外联网Extranet"><a href="#企业内部网Intranet-企业外联网Extranet" class="headerlink" title="企业内部网Intranet/企业外联网Extranet"></a>企业内部网Intranet/企业外联网Extranet</h3><p><strong>Intranet</strong></p>
<ul>
<li>按照Internet功能与服务模式建立的企业内部局域网。</li>
<li>可以是有线也可以是无线形式。</li>
</ul>
<p><strong>Extranet</strong></p>
<p>是Intranet的扩展 —— 跨越企业组织边界的网络连接。</p>
<p>形式：借助互联网, 通过VPN方式。</p>
<p>应用：</p>
<ul>
<li>本企业组织的员工远程访问本公司的Intranet 。</li>
<li>大的企业集团，分布在多个地域的分公司或办事机构需要作为一个整体，互相交换信息，访问对方的Intranet，将企业内部网Intranet连接在一起。</li>
</ul>
<h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="计算机网络的技术指标"><a href="#计算机网络的技术指标" class="headerlink" title="计算机网络的技术指标"></a>计算机网络的技术指标</h2><h3 id="传输速率和带宽"><a href="#传输速率和带宽" class="headerlink" title="传输速率和带宽"></a>传输速率和带宽</h3><h4 id="传输速率-Data-Rate"><a href="#传输速率-Data-Rate" class="headerlink" title="传输速率(Data Rate)"></a>传输速率(Data Rate)</h4><p>每秒种传输的二进制比特数，描述数据流的一个参数，单位用BPS表示。</p>
<h4 id="带宽（Bandwidth"><a href="#带宽（Bandwidth" class="headerlink" title="带宽（Bandwidth)"></a>带宽（Bandwidth)</h4><p>信道具有的频带宽度，描述媒介物理特性的一个参数，单位用HZ表示。</p>
<blockquote>
<p>两者关系的定性描述：</p>
<p>具有一定带宽的信道，其信号传输速率是有限的。</p>
<p>信号传输的速率越快，要求信道的带宽就越高。</p>
<p>信道的带宽越高，信号的传输速率就越快。</p>
<p>—— 两者成正比关系。</p>
<p>——信号传输速率与信道带宽两个概念在工业上经常互换使用。</p>
</blockquote>
<blockquote>
<p>两者关系的定量描述：</p>
<p>（1）对于无热噪声的理想信道（无其他信号干扰）来说，用奈奎斯特（Nyquist）公式计算：</p>
<p>极限传输速率（信道容量）C=2Flog$_2$S</p>
<p>其中，F为信道带宽 (Hz) ，S为单位周期内数字信号的状态数。</p>
<p>（2）对于有热噪声的实际信道（既有干扰信号）来说，这个极限值可以用香农（Shannon）公式计算：</p>
<p>信道容量 C=Flog$_2$(1+S/N) </p>
<p>其中，S为接收端信号平均功率（W），N为信道内噪声平均功率（W）。</p>
<p>一般的数据通信系统都必须保证S/N的比值。</p>
</blockquote>
<h3 id="吞吐量-throughput"><a href="#吞吐量-throughput" class="headerlink" title="吞吐量(throughput)"></a>吞吐量(throughput)</h3><p>单位时间内通过某个网络（或信道、接口）的数据量。</p>
<blockquote>
<p>传输速率、带宽、吞吐量都是衡量网络传输质量的重要参数。</p>
</blockquote>
<h3 id="误码率（BER：bit-error）"><a href="#误码率（BER：bit-error）" class="headerlink" title="误码率（BER：bit error）"></a>误码率（BER：bit error）</h3><p>衡量网络传输质量的一个重要参数。</p>
<p>定义：二进制符号在传输系统中被传错的概率。</p>
<p>近似的等于被传错的二进制符号数与所传二进制符号总数的比值</p>
<p>计算公式：误码率Pe = 接收的错误比特数/传输的总比特数</p>
<p>量值概念：在计算机网络通讯中，误码率要求低于$10^-9$</p>
<h3 id="分组延迟和延迟抖动"><a href="#分组延迟和延迟抖动" class="headerlink" title="分组延迟和延迟抖动"></a>分组延迟和延迟抖动</h3><h4 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h4><p>分组的第一个bit离开发送端与分组的最后一个bit到达接收端的时间间隔。</p>
<p>分组延迟可以细分为4个部分：</p>
<p>（1）发送延迟（传输延迟，transmission delay）：发送数据时，数据分组从结点进入网络所需的时间。</p>
<p>（2）传播延迟：分组在网络中传播而花费的时间，即发送端发送出分组中的某一个比特到接收端接收到该比特所经过的时间间隔，它取决于传输介质和传输距离。</p>
<blockquote>
<p>注意：信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。</p>
</blockquote>
<p>（3）处理延迟（processing delay）：交换结点为存储转发分组而进行一些必要的处理所花费的时间，即分组从到达节点到进入输出队列的时间间隔，包括对分组头处理，路由查找等，它取决于节点的处理能力和分组处理的复杂度</p>
<p>（4）排队延迟（queuing delay）：分组从进入队列到开始传输所经过的时间间隔，或者说分组在路由器等结点的缓存队列中排队所经历的延迟。排队延迟取决于平均队列长度（反映的是网络中的数据流量）和调度策略。</p>
<p><strong>分组总延迟＝发送延迟＋传播延迟＋处理延迟＋排队延迟</strong></p>
<blockquote>
<p>如何减少延迟？</p>
<p>提高网络的带宽、增加路由器等结点的缓存空间和处理能力</p>
</blockquote>
<h4 id="延迟抖动"><a href="#延迟抖动" class="headerlink" title="延迟抖动"></a>延迟抖动</h4><p>分组延迟的变化程度。反映的是端到端延时的变化特性。</p>
<p>产生原因：由延时的可变部分的变化导致的。如：流量的突发、不公平的队列调度算法。</p>
<p>影响程度：延迟抖动越大，网络服务质量越难以控制，网络越容易出现拥塞。</p>
<h3 id="分组丢失率和超时重传率"><a href="#分组丢失率和超时重传率" class="headerlink" title="分组丢失率和超时重传率"></a>分组丢失率和超时重传率</h3><p>丢失原因：因为出现拥塞而被迫丢失；因避免出现拥塞而被主动丢弃。</p>
<h4 id="分组丢失率"><a href="#分组丢失率" class="headerlink" title="分组丢失率"></a>分组丢失率</h4><p>单位时间内丢失的分组数量与所传输的分组数量的比值。</p>
<p>——取平均值(因为不同时刻，网络中的数据流量以及拥塞程度不同)</p>
<h4 id="超时重传率"><a href="#超时重传率" class="headerlink" title="超时重传率"></a>超时重传率</h4><p>单位时间内被重传的分组数量与发送的分组总数的比率。</p>
<p>——取一段时间内的平均值。</p>
<blockquote>
<p>分组丢失率、超时重传率和误码率都是衡量网络传输质量的重要参数。</p>
</blockquote>
<h3 id="信道利用率-amp-网络利用率"><a href="#信道利用率-amp-网络利用率" class="headerlink" title="信道利用率&amp;网络利用率"></a>信道利用率&amp;网络利用率</h3><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>信道的使用效率。</p>
<h4 id="网络利用率："><a href="#网络利用率：" class="headerlink" title="网络利用率："></a>网络利用率：</h4><p>网络中全部信道的利用率的加权平均值。</p>
<blockquote>
<p>考虑到可能出现的网络拥塞，信道利用率或网络利用率并非越高越好。</p>
</blockquote>
<h2 id="计算机网络的工程化指标"><a href="#计算机网络的工程化指标" class="headerlink" title="计算机网络的工程化指标"></a>计算机网络的工程化指标</h2><ul>
<li>性价比</li>
<li><strong>可靠性（稳定性）</strong></li>
<li>可扩展性</li>
<li>易于管理和维护</li>
</ul>
<h1 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a><strong>计算机网络的体系结构</strong></h1><h2 id="计算机网络体系结构的形成"><a href="#计算机网络体系结构的形成" class="headerlink" title="计算机网络体系结构的形成"></a>计算机网络体系结构的形成</h2><p>协议的必要性：双（多）方协调一致，相互匹配。</p>
<p>协议集：对于一个功能强大的、既包括硬件又包括软件的、复杂的计算机网络来说，需要制订若干个协议，构成一个协议集。</p>
<p>层次结构：对于数量繁多、庞大复杂的网络协议集来说，其最好的组织方式就是采用层次结构。 </p>
<p>分层的好处</p>
<ul>
<li>灵活性好：各层之间是独立的，可以跟据需要裁剪组合，跨越某些层。</li>
<li>易于设计（实现）和维护。</li>
<li>易于标准化。</li>
</ul>
<p>层数设多少</p>
<ul>
<li>层数太少：每一层的协议太复杂。</li>
<li>层数太多：各层之间关系太复杂。</li>
<li>层数适当：4 ～ 7</li>
</ul>
<p>分层原则：</p>
<ul>
<li>逻辑关系</li>
<li>功能独立性</li>
</ul>
<p>网络体系结构(architecture) ：网络协议的层次结构模型</p>
<p>网络体系结构意义：</p>
<ul>
<li>促进标准化</li>
<li>决定网络的功能和性能</li>
</ul>
<h2 id="开放系统互连参考模型OSI-RM"><a href="#开放系统互连参考模型OSI-RM" class="headerlink" title="开放系统互连参考模型OSI/RM"></a>开放系统互连参考模型OSI/RM</h2><p><strong>产生的背景：</strong></p>
<ul>
<li>层次化的网络体系结构被接受并得到普及和推广</li>
<li>各计算机生产厂商纷纷推出自己的层次化网络体系结构</li>
<li>这些网络体系结构普遍是以自己公司的产品为对象</li>
<li>层次的划分、功能的分配与采用的技术术语各不相同，不具备与其它公司网络结构的兼容性</li>
</ul>
<p>ISO组成TC97/SC16，OSI/RM应运而生。</p>
<p><strong>开放系统：</strong>一个系统在和其他系统进行通信时，如果能够遵守标准化的信息交换协议，就称其为开放系统。 </p>
<p><strong>层次划分的原则：</strong></p>
<ul>
<li>网络中相同的结点具有相同的层次；相同的层次具有相同的功能</li>
<li>同一结点内相邻层之间通过确定的接口进行交互通信</li>
<li>网络中不同结点的同等层之间采用相同的协议，实现对等层之间的交互操作</li>
</ul>
<p><strong>分层情况：</strong></p>
<p>以客户机为代表的每个端结点： 开放系统——七层</p>
<p>以路由器/交换机(三层结构) 为代表的中继结点（中继开放系统）——三层</p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/11.png" alt="OSI参考模型的结构形式"></p>
<p><strong>各层协议的功能：</strong></p>
<ul>
<li><p>应用层协议：提供各种规范的网络应用和服务 (如文件传递，电子邮件等)</p>
</li>
<li><p>表示层协议：用于协调两个应用实体之间进行数据交换时数据格式不一致以及数据表示方法不同等问题 。</p>
</li>
<li><p>会话层协议：组织和同步不同主机上各进程间的通信(会话) —— 在两个相互通信的实体(进程)之间，建立、组织、协调其交互会话过程。</p>
</li>
<li><p>传输层协议：确保两个客户端之间可以实现端——端的透明数据传输服务。</p>
</li>
<li><p>网络层协议：用于实现数据分组跨通信子网（物理网络）进行传输的管理和控制。</p>
</li>
<li><p>数据链路层：按某种规程(如HDLC)组织每条数据链路上的数据传输，提供高可靠性、无差错的数据传输质量。</p>
</li>
<li><p>物理层协议：使所有连网的计算机系统和通信设备都能够从接口上兼容，并使这些接口的定义独立于厂商的设备。</p>
</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/12.png" alt="OSI参考模型的数据传输过程"></p>
<p><strong>OSI/RM的应用：</strong></p>
<p>CCITT（ITU—T）从一开始就提供对OSI的支持，协助制定标准。但在市场化方面 OSI 却失败了：</p>
<ul>
<li><p>OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场</p>
</li>
<li><p>OSI 的专家们在完成 OSI 标准时没有商业驱动力</p>
</li>
<li><p>OSI 的协议实现起来过分复杂，且运行效率很低</p>
</li>
<li><p>OSI 的层次划分并也不太合理，有些功能在多个层次中重复出现 </p>
<p>——总之，没有得到市场的认可。</p>
</li>
</ul>
<p><strong>OSI/RM的意义：</strong></p>
<p>其它所有网络体系结构都要都要参照OSI/RM，并给出与其对应关系。—— 参照意义。</p>
<h2 id="TCP-IP网络体系结构"><a href="#TCP-IP网络体系结构" class="headerlink" title="TCP/IP网络体系结构"></a>TCP/IP网络体系结构</h2><p>TCP/IP协议源于著名的ARPAnet及NSFNET</p>
<p>TCP/IP协议是先于OSI模型开发的，因此不符合OSI/RM标准。</p>
<p>TCP/IP协议被广泛采用的原因：</p>
<ul>
<li><p>Internet采用TCP/IP协议，各类网络都要和Internet或借助于Internet相互连接</p>
</li>
<li><p>TCP/IP已被公认为是异种计算机、异种网络彼此通信的可行协议</p>
</li>
<li><p>各主要计算机软、硬件厂商的网络产品几乎都支持TCP/IP协议</p>
</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/13.png" alt="TCP/IP网络体系结构概览"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/14.png" alt="IP可应用到各式各样的网络"></p>
<blockquote>
<p>TCP/IP不涉及接口层，所以可应用于各类网络</p>
<p>UDP后于TCP出现，主要弥补TCP协议的不足。TCP与UDP互补</p>
<p>TCP相对于UDP可靠性高；UDP相对于TCP传输效率高</p>
</blockquote>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>没有具体的协议，适用于任何网络产品。—— 类似对应OSI/RM的物理层和数据链路层。</p>
<h3 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h3><p>类似对应OSI/RM的网络层。</p>
<p>包括4个重要的协议：IP、ICMP、ARP和RARP。</p>
<h4 id="IP-互连网协议"><a href="#IP-互连网协议" class="headerlink" title="IP(互连网协议)"></a>IP(互连网协议)</h4><p>实现网际寻址，通过互连的网络找到目标结点，传送数据报。</p>
<p>特点：不检查遗失的分组 → IP协议不保证服务的可靠性</p>
<p>—— 端到端的流量控制、分组丢失的检测、分组排序等工作均由高层协议负责。 </p>
<h4 id="ICMP-互连网控制报文协议"><a href="#ICMP-互连网控制报文协议" class="headerlink" title="ICMP(互连网控制报文协议)"></a>ICMP(互连网控制报文协议)</h4><p>使网际上的计算机能够检测和报告丢包等差错，或提供其它意外信息 。</p>
<p>ICMP与IP的关系：嵌入到IP中，弥补IP的不足。（IP的补丁）</p>
<h4 id="ARP-地址转换协议"><a href="#ARP-地址转换协议" class="headerlink" title="ARP(地址转换协议)"></a>ARP(地址转换协议)</h4><p>将IP地址变换成硬件接口地址(MAC)</p>
<h4 id="RARP-反向地址转换协议"><a href="#RARP-反向地址转换协议" class="headerlink" title="RARP(反向地址转换协议)"></a>RARP(反向地址转换协议)</h4><p>根据MAC地址查找IP地址。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>为通信双方的主机提供端到端的服务。—— 类似对应OSI/RM的运输层和会话层</p>
<p>TCP/IP在传输层提供两个主要协议：</p>
<h4 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP(传输控制协议)"></a>TCP(传输控制协议)</h4><p>提供端到端可靠的进程间通信 —— TCP向高层提供的是面向连接的虚电路服务</p>
<p>面向连接的通信分三个阶段：连接建立、数据传送和连接拆除</p>
<p>由于建立了一条虚电路，因此可以实现可靠传输。</p>
<h4 id="UDP-用户数据报协议"><a href="#UDP-用户数据报协议" class="headerlink" title="UDP(用户数据报协议)"></a>UDP(用户数据报协议)</h4><p>提供端到端快捷但不够可靠的进程间通信 —— UDP向高层提供的是非面向连接的数据报服务</p>
<p>由于面向无连接的服务没有建立连接和拆除连接的过程，因此可直接进行数据传输，但每个包必须给出IP地址。</p>
<p>端口号：一个16位的标志符，标识传输层协议和特定的应用程序之间的接口。</p>
<p>套接字：端口号和IP地址合起来，唯一标识一个特定的应用程序。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>大致和OSI模型的表示层和应用层对应，但没有明确的层次划分。</p>
<p>其中，HTTP、Telnet、FTP、TFTP、SMTP、DNS等是广泛使用的应用层协议。 </p>
<p><strong>TCP/IP的特点</strong></p>
<ul>
<li>TCP/IP虽然也分层，但其层次间的调用关系不像OSI那样严格</li>
</ul>
<blockquote>
<p>可以越层</p>
</blockquote>
<ul>
<li>OSI对可靠性的强调是第一位的，协议的所有各层都要检测和处理错误</li>
</ul>
<blockquote>
<p>随着传输介质和通信子网的升级换代，没必要</p>
</blockquote>
<p>​        TCP/IP认为可靠性应该在传输层由端结点来解决</p>
<blockquote>
<p>TCP/IP效率很高（但如果通信子网可靠性较差，主机的负担就会加重）</p>
</blockquote>
<ul>
<li><p>OSI由通信子网解决：监视数据流量、控制网络访问、记帐收费、甚至路由选择、流量控制等智能性活动；TCP/IP则要求主机参与几乎所有的智能性活动。</p>
</li>
<li><p>OSI一开始没有考虑网络互连问题，只好以后在网络层中划分出一个子层来完成类似IP的功能TCP/IP从一开始就考虑到网络互联问题，并将互连网协议IP作为TCP/IP的重要组成部分</p>
</li>
</ul>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/15.png" alt="5层网络体系结构模型"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/16.png" alt="5层网络数据传输过程"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/26-Computer-network-study-notes-1/17.png" alt="小结"></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/02/24/26-Computer-network-study-notes-1">https://zam9036.gitee.io/2020/02/24/26-Computer-network-study-notes-1</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>课程:计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Android UI框架flutter的安装与使用|Zam9036博客</title>
    <url>/2020/01/29/25-Android-UI-framework-flutter-installation-and-use/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="适用平台"><a href="#适用平台" class="headerlink" title="适用平台"></a>适用平台</h1><p>Windows</p>
<h1 id="Flutter介绍"><a href="#Flutter介绍" class="headerlink" title="Flutter介绍"></a>Flutter介绍</h1><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p>
<h1 id="Flutter安装"><a href="#Flutter安装" class="headerlink" title="Flutter安装"></a>Flutter安装</h1><h2 id="下载flutter"><a href="#下载flutter" class="headerlink" title="下载flutter"></a>下载flutter</h2><p>访问<a href="https://flutter.dev/docs/development/tools/sdk/releases#windows" target="_blank" rel="noopener">flutter官网</a>，下载flutter。flutter集成了Dart，因此不需要单独安装dart-sdk。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/1.png" alt="flutter官网"></p>
<blockquote>
<p>flutter有四个版本</p>
<ul>
<li>Stable channel    //稳定版。最近一年中最稳定的Beta版本。</li>
<li>Beta channel    //测试版。每隔一段时间都会选择近个月中最好的Bev版本作为Beta版。</li>
<li>Dev channel    //经过测试的最新版，但仍可能包含很多问题。</li>
<li>Master channel    //未经过测试的最新版。</li>
</ul>
</blockquote>
<p>我选择的是最新的Stable channel（v1.12.13+hotfix.7）。为避免不必要的麻烦，请不要选择C盘作为下载目录，否则可能遇到权限问题。</p>
<h2 id="更新环境变量"><a href="#更新环境变量" class="headerlink" title="更新环境变量"></a>更新环境变量</h2><p>flutter下载完成后，解压到存放SDK的目录。</p>
<p>注意：目标SDK路径仅能包含英文和数字，不能包含中文和空格！</p>
<p>解压完成后，返回桌面，右击<code>我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统环境变量</code>，编辑Path，添加目标SDK的路径至Path内（我的路径是<code>G:\flutter\bin</code>）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/2.png" alt="更新环境变量1"></p>
<p>同时还需要添加以下系统环境变量</p>
<pre><code class="环境变量">变量名：PUB_HOSTED_URL
变量值：https://pub.flutter-io.cn

变量名：FLUTTER_STORAGE_BASE_URL
变量值：https://storage.flutter-io.cn</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/3.png" alt="更新环境变量2"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/4.png" alt="更新环境变量3"></p>
<p>所有环境变量添加完成后重启电脑！</p>
<h2 id="flutter-doctor检测安装"><a href="#flutter-doctor检测安装" class="headerlink" title="flutter doctor检测安装"></a>flutter doctor检测安装</h2><p>打开cmd，输入<code>flutter</code>指令，如看到下图的flutter相关指令，说明安装成功。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/5.png" alt="flutter指令"></p>
<p>输入<code>flutter doctor</code>指令，检测安装情况，最左边打红叉的是必须要解决的，橙色感叹号是Warning，绿色说明正确。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/6.png" alt="flutter doctor指令"></p>
<h2 id="添加SDK路径至环境变量"><a href="#添加SDK路径至环境变量" class="headerlink" title="添加SDK路径至环境变量"></a>添加SDK路径至环境变量</h2><p>添加SDK路径至环境变量（我的SDK路径是G:\AndroidSDK\platform-tools）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/7.png" alt="添加SDK路径至环境变量"></p>
<h2 id="安装Android-Studio-Plugin"><a href="#安装Android-Studio-Plugin" class="headerlink" title="安装Android Studio Plugin"></a>安装Android Studio Plugin</h2><p>首先你需要有Android Studio（Android Studio安装详见<a href="https://zam9036.gitee.io/2020/01/24/24-Android-Study-Notes-1">Android学习笔记(一)</a>）</p>
<p>打开Android Studio，<code>File -&gt; Setting -&gt; Plugins -&gt; Browse repositories</code>，搜索flutter。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/8.png" alt="安装Android Studio Plugin-1"></p>
<p>就是这个，点击安装</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/9.png" alt="安装Android Studio Plugin-2"></p>
<p>点击Yes，会自动帮你安装dart-sdk</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/10.png" alt="安装Android Studio Plugin-3"></p>
<p>安装完成后需要重启Android Studio，然后可以看到安装的dart-sdk和flutter。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/11.png" alt="安装Android Studio Plugin-4"></p>
<h1 id="使用flutter"><a href="#使用flutter" class="headerlink" title="使用flutter"></a>使用flutter</h1><p>点开Android Studio的 File -&gt; New 可以看到 New Flutter Project</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/12.png" alt="使用flutter-1"></p>
<p>选择喜欢的模板，开始flutter之旅吧！</p>
<p><img src="https://zam9036.gitee.io/img/postimg/25-Android-UI-framework-flutter-installation-and-use/13.png" alt="使用flutter-2"></p>
<h1 id="部分flutter指令"><a href="#部分flutter指令" class="headerlink" title="部分flutter指令"></a>部分flutter指令</h1><h2 id="升级flutter"><a href="#升级flutter" class="headerlink" title="升级flutter"></a>升级flutter</h2><p>打开cmd，定位到根目录，输入如下指令升级</p>
<pre><code class="cmd">flutter upgrade</code></pre>
<h2 id="切换flutter版本"><a href="#切换flutter版本" class="headerlink" title="切换flutter版本"></a>切换flutter版本</h2><p>指令如下：</p>
<pre><code class="cmd">flutter channel [目标版本]</code></pre>
<p>如<code>flutter channel dev</code></p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>参考资料：<a href="https://blog.csdn.net/fyyyr/article/details/86593125" target="_blank" rel="noopener">https://blog.csdn.net/fyyyr/article/details/86593125</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/01/29/25-Android-UI-framework-flutter-installation-and-use">https://zam9036.gitee.io/2020/01/29/25-Android-UI-framework-flutter-installation-and-use</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习笔记(一)|Zam9036博客</title>
    <url>/2020/01/24/24-Android-Study-Notes-1/</url>
    <content><![CDATA[<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>Android（安卓）是基于Linux的移动设备操作系统，主要应用于智能手机与平板电脑，现已拓展应用于互联网电视、可穿戴设备、智能家居等领域。Android与IOS同为智能手机市场的两大操作系统。</p>
<h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><p>早期Android开发APP主要使用Eclipse和基于Eclipse的ADT，但Eclipse平台是专为Java工程开发而生的平台，先天性不足在所难免，所以Google打造了自家的Android开发平台：Android Studio。</p>
<p>Android Studio比Eclipse有如下优势：</p>
<ul>
<li>Android Studio使用v7库与design库只需要增加一行配置，而Eclipse如果想使用这些库需要引用整个工程</li>
<li>高版本的SDK与NDK只支持Android Studio，不支持Eclipse</li>
<li>许多新功能只能在Android Studio中应用</li>
</ul>
<h2 id="Android-Studio安装"><a href="#Android-Studio安装" class="headerlink" title="Android Studio安装"></a>Android Studio安装</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>JDK是Java语言的编译器，是Java开发工具包。Android采用Java语言（现还可以使用Kotlin）进行开发，故需要安装JDK。</p>
<h4 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h4><p>SDK是Android应用的编译器，是软件开发工具包。</p>
<h4 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h4><p>NDK是C/C++代码编译器，是原生开发工具包。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>图解数据结构-插入排序|Zam9036博客</title>
    <url>/2020/01/12/23-Graphical-data-structure-Insertion-sort/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法—插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。<br>插入排序的基本思想是：每步将一个待排序的记录，按其数值的大小插入前面已经排序的数字中适当位置上，直到全部插入完为止。</p>
<h1 id="图解核心原理"><a href="#图解核心原理" class="headerlink" title="图解核心原理"></a>图解核心原理</h1><p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/1.jpg" alt="插入排序核心原理1"></p>
<p>插入排序需要把数列分为两个部分，一部分为排好的有序数列和另一部分未排的无序数列。假如我们需要对上图数列进行排序。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/2.jpg" alt="插入排序核心原理2"></p>
<p>排序开始时首先把最左端的数字归为已排序数列(5)，其余数字为未排数列(34728691)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/3.jpg" alt="插入排序核心原理3"></p>
<p>然后，取出未排数列中未操作过的最左端的数字(3)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/4.jpg" alt="插入排序核心原理4"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/5.jpg" alt="插入排序核心原理5"></p>
<p>将未排数列中未操作过的最左端的数字(3)与已排数列的数字(5)从右到左逐个进行比较。如果已排数列的数字大，则交换两个数字，并继续与该已排数列数字的前一个数字进行比较，重复此操作，直到出现一个较小的数字或者达到已排数列的最左端(此时3到达最左端，则停止移动，插入已排数列，完成排序)；如果已排数列的数字小，则停止移动，并将该未排数字插入已排数列，完成排序。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/6.jpg" alt="插入排序核心原理6"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(4)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/7.jpg" alt="插入排序核心原理7"></p>
<p>将未排数列中未操作过的最左端的数字(4)与已排数列的数字(35)从右到左逐个进行比较。此时已排数列的数字(5)大，未排序数列最左端数字(4)小，则交换两个数字(交换5和4)，并继续与该已排数列数字的前一个数字(3)进行比较。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/8.jpg" alt="插入排序核心原理8"></p>
<p>此时已排数列的数字(3)小，则停止移动，并将该未排数字(4)插入已排数列，完成排序(得到已排数列345)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/9.jpg" alt="插入排序核心原理9"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(7)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/10.jpg" alt="插入排序核心原理10"></p>
<p>将未排数列中未操作过的最左端的数字(7)与已排数列的数字(345)从右到左逐个进行比较。此时已排数列的数字(5)小，则停止移动，并将该未排数字(7)插入已排数列(得到已排数列3457)，完成排序。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/11.jpg" alt="插入排序核心原理11"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(2)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/12.jpg" alt="插入排序核心原理12"></p>
<p>将未排数列中未操作过的最左端的数字(2)与已排数列的数字(3457)从右到左逐个进行比较。此时已排数列的数字(7)大，未排序数列最左端数字(2)小，则交换两个数字(交换7和2)，并继续与该已排数列数字的前一个数字(5)进行比较。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/13.jpg" alt="插入排序核心原理13"></p>
<p>此时已排数列的数字(5)大，未排序数列最左端数字(2)小，则交换两个数字(交换5和2)，并继续与该已排数列数字的前一个数字(4)进行比较。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/14.jpg" alt="插入排序核心原理14"></p>
<p>此时已排数列的数字(4)大，未排序数列最左端数字(2)小，则交换两个数字(交换4和2)，并继续与该已排数列数字的前一个数字(3)进行比较。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/15.jpg" alt="插入排序核心原理15"></p>
<p>此时已排数列的数字(3)大，未排序数列最左端数字(2)小，则交换两个数字(交换3和2)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/16.jpg" alt="插入排序核心原理16"></p>
<p>交换后2到达最左端，则停止移动，插入已排数列，完成排序(得到已排数列23457)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/17.jpg" alt="插入排序核心原理17"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(8)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/18.jpg" alt="插入排序核心原理18"></p>
<p>此时已排数列的数字(7)小，则停止移动，并将该未排数字(8)插入已排数列，完成排序(得到已排数列234578)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/19.jpg" alt="插入排序核心原理19"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(6)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/20.jpg" alt="插入排序核心原理20"></p>
<p>将未排数列中未操作过的最左端的数字(6)与已排数列的数字(234578)从右到左逐个进行比较。7、8比6大，5比6小，所以6应该插在5、7之间。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/21.jpg" alt="插入排序核心原理21"></p>
<p>将6插入已排数列，完成排序(得到已排数列2345678)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/22.jpg" alt="插入排序核心原理22"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(9)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/23.jpg" alt="插入排序核心原理23"></p>
<p>8比9小，所以9直接插入已排数列末尾(得到已排数列23456789)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/24.jpg" alt="插入排序核心原理24"></p>
<p>重复以上操作，取出未排数列中未操作过的最左端的数字(1)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/25.jpg" alt="插入排序核心原理25"></p>
<p>已排数列的数字23456789均比1大，所以1到达最左端，并插入已排数列，得到有序数列123456789。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/23-Graphical-data-structure-Insertion-sort/26.jpg" alt="插入排序核心原理26"></p>
<p>此时未排数列为空，所有数字完成排序，排序结束。</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>部分资料来自：<a href="http://algorithm.wiki" target="_blank" rel="noopener">http://algorithm.wiki</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/01/12/23-Graphical-data-structure-Insertion-sort">https://zam9036.gitee.io/2020/01/12/23-Graphical-data-structure-Insertion-sort</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请保留文章链接并注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图解数据结构—选择排序|Zam9036博客</title>
    <url>/2020/01/11/22-Graphical-data-structure-selection-sort/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p>
<h1 id="图解核心原理"><a href="#图解核心原理" class="headerlink" title="图解核心原理"></a>图解核心原理</h1><p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/1.jpg" alt="选择排序核心原理1"></p>
<p>假设我们需要对上图数列进行排序。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/2.jpg" alt="选择排序核心原理2"></p>
<p>首先，我们需要对数列进行线性搜索(从头到尾逐个元素搜索)，找出最小的元素值(最小为1)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/3.jpg" alt="选择排序核心原理3"></p>
<p>将值最小的元素(最小为1)与数列最左端的元素(原来数列最左端元素为6)互换。如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/4.jpg" alt="选择排序核心原理4"></p>
<p>保持已经排好的元素位置不变(即1的位置不再改变)，在剩余元素中找出值最小的元素(最小为2)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/5.jpg" alt="选择排序核心原理5"></p>
<p>将此时值最小的元素(最小为2)与未排序的数列最左端的元素(原来未排序的数列最左端元素为6)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/6.jpg" alt="选择排序核心原理6"></p>
<p>继续保持已经排好的元素位置不变(即1、2的位置不再改变)，在剩余元素中找出值最小的元素(最小为3)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/7.jpg" alt="选择排序核心原理7"></p>
<p>将此时值最小的元素(最小为3)与未排序的数列最左端的元素(原来未排序的数列最左端元素为7)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/8.jpg" alt="选择排序核心原理8"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3的位置不再改变)，在剩余元素中找出值最小的元素(最小为4)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/9.jpg" alt="选择排序核心原理9"></p>
<p>将此时值最小的元素(最小为4)与未排序的数列最左端的元素(原来未排序的数列最左端元素为8)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/10.jpg" alt="选择排序核心原理10"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4的位置不再改变)，在剩余元素中找出值最小的元素(最小为5)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/11.jpg" alt="选择排序核心原理11"></p>
<p>将此时值最小的元素(最小为5)与未排序的数列最左端的元素(原来未排序的数列最左端元素为9)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/12.jpg" alt="选择排序核心原理12"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4、5的位置不再改变)，在剩余元素中找出值最小的元素(最小为6)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/13.jpg" alt="选择排序核心原理13"></p>
<p>将此时值最小的元素(最小为6)与未排序的数列最左端的元素(原来未排序的数列最左端元素为7)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/14.jpg" alt="选择排序核心原理14"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4、5、6的位置不再改变)，在剩余元素中找出值最小的元素(最小为7)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/15.jpg" alt="选择排序核心原理15"></p>
<p>将此时值最小的元素(最小为7)与未排序的数列最左端的元素(原来未排序的数列最左端元素为9)互换。同样，如果最小值已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/16.jpg" alt="选择排序核心原理16"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4、5、6、7的位置不再改变)，在剩余元素中找出值最小的元素(最小为8)。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/17.jpg" alt="选择排序核心原理17"></p>
<p>将此时值最小的元素(最小为8)已经在最左端，则不需要执行任何操作。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/22-Graphical-data-structure-selection-sort/18.jpg" alt="选择排序核心原理18"></p>
<p>继续保持已经排好的元素位置不变(即1、2、3、4、5、6、7、8的位置不再改变)，在剩余元素中找出值最小的元素(最小为9)。将此时值最小的元素(最小为9)已经在最左端，则不需要执行任何操作。</p>
<p>现在，数列的顺序已经排好。</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>部分资料来自：<a href="http://algorithm.wiki" target="_blank" rel="noopener">http://algorithm.wiki</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/01/11/22-Graphical-data-structure-selection-sort">https://zam9036.gitee.io/2020/01/11/22-Graphical-data-structure-selection-sort</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图解数据结构—冒泡排序|Zam9036博客</title>
    <url>/2020/01/10/21-Graphical-data-structure%E2%80%94bubble-sort/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>冒泡排序重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换为止，也就是说该元素列已经排序完成为止。</p>
<h1 id="图解核心原理"><a href="#图解核心原理" class="headerlink" title="图解核心原理"></a>图解核心原理</h1><p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/1.jpg" alt="冒泡排序核心原理1"></p>
<p>首先，我们将天平放在序列的右端，并比较天平左右的数字。在这种情况下，我们来比较7和6。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/2.jpg" alt="冒泡排序核心原理2"></p>
<p>比较后如果右边的数字较小，则被交换。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/3.jpg" alt="冒泡排序核心原理3"></p>
<p>比较完成后，逐一移动天平继续比较。这次6大于4，所以数字不交换。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/4.jpg" alt="冒泡排序核心原理4"></p>
<p>将天平向左移动一个位置，继续比较。这次4小于8，交换4和8。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/5.jpg" alt="冒泡排序核心原理5"></p>
<p>将天平向左移动一个位置，继续比较。这次4大于2，所以数字不交换。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/6.jpg" alt="冒泡排序核心原理6"></p>
<p>将天平向左移动一个位置，继续比较。这次2大于1，所以数字不交换。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/7.jpg" alt="冒泡排序核心原理7"></p>
<p>将天平向左移动一个位置，继续比较。这次1小于3，交换1和3。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/8.jpg" alt="冒泡排序核心原理8"></p>
<p>将天平向左移动一个位置，继续比较。这次1小于9，交换1和9。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/9.jpg" alt="冒泡排序核心原理9"></p>
<p>将天平向左移动一个位置，继续比较。这次1小于5，交换1和5。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/10.jpg" alt="冒泡排序核心原理10"></p>
<p>此时天平到达序列最左端。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/21-Graphical-data-structure%E2%80%94bubble-sort/11.jpg" alt="冒泡排序核心原理11"></p>
<p>在一系列操作中，序列中最小的数字已经移动到最左端。保持该数字位置不再改变，天平返回右端。重复相同的操作，直到所有数字都被排序……</p>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>文章作者：Zam9036</p>
<p>部分资料来自：<a href="http://algorithm.wiki" target="_blank" rel="noopener">http://algorithm.wiki</a></p>
<p>文章链接：<a href="https://zam9036.gitee.io/2020/01/10/21-Graphical-data-structure—bubble-sort">https://zam9036.gitee.io/2020/01/10/21-Graphical-data-structure—bubble-sort</a></p>
<p>版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用邻接表存储无向非连通图并利用DFS和BFS遍历图的邻接表|Zam9036博客</title>
    <url>/2019/12/05/20-Use-adjacency-list-to-store-undirected-disconnected-graphs-and-traverse-adjacency-lists-with-DFS-and-BFS/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><p>​    C++</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过建立无向非连通图，并对图进行DFS及BFS遍历，了解图的构建算法，并加深对DFS及BFS的理解。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>1）建立无向非连通图的邻接表存储结构，要求顶点个数不少于15个。 2）用DFS及BFS对此邻接表进行遍历，打印出两种遍历的顶点访问顺序。3）给定图中任意两个顶点v1和v2及整数k，判断是否存在从v1到v2的路径长度为k的简单路径，若有打印出路径上的顶点序列（要求路径上不含回路）。进一步：找出从v1到v2的所有路径长度为k的简单路径。（简单路径：顶点序列中不含重现的顶点的路径。）</p>
<h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本实验实现DFS算法是利用栈储存待访问的节点，利用栈的FILO（先入后出）来实现深度搜索；实现BFS是利用队列储存待访问的节点，利用队列的FIFO（先入后出）来实现广度搜索。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试以下5节点图和12节点图</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/1.png" alt="5节点图"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/2.png" alt="12节点图"></p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><p>首先创建节点结构（包括该路径指向的顶点位置、指向下一个路径、该路径的相关信息）和连线结构（顶点信息、指向第一条依附该节点路径的指针、访问情况），然后根据输入逐个插入邻接表点从而创建邻接表。</p>
<p>本实验实现DFS算法是利用栈储存待访问的节点，利用栈的FILO（先入后出）来实现深度搜索：从根节点开始，遍历节点的连接表，跳过已访问的节点值，将未访问过的节点加入栈，然后逐一取走栈内元素并对取走的节点邻接表进行遍历，重复相同过程，直至栈为空结束；实现BFS是利用队列储存待访问的节点，利用队列的FIFO（先入后出）来实现广度搜索：从根节点开始，遍历节点的连接表，跳过已访问的节点值，将未访问过的节点加入队列，然后逐一取走队列内元素并对取走的节点邻接表进行遍历，重复相同过程，直至队列为空结束。</p>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/3.png" alt="5节点图测试"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/4.png" alt="12节点图测试"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.有重复遍历的节点情况出现</p>
<p>解决方法：对每个节点增加一个访问情况值，访问邻接表时跳过已访问过的值。</p>
<p>2.寻找简单路径暂无思路 </p>
<h1 id="使用说明和测试结果"><a href="#使用说明和测试结果" class="headerlink" title="使用说明和测试结果"></a>使用说明和测试结果</h1><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>用Visual Studio打开.sln文件即可运行</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过，符合程序设计要求和需求分析</p>
<p>详细结果见调试分析-示例测试</p>
<h1 id="体会心得"><a href="#体会心得" class="headerlink" title="体会心得"></a>体会心得</h1><p>通过本次课程实验，我对数据结构的了解进一步加深，并产生了浓厚的兴趣。虽然在写代码过程中遇到了一些问题，但我通过思考、网上找资料、询问同学等方式最终解决了问题。这次实验让我进一步巩固了建立无向非连通图的方法，及对图进行DFS及BFS遍历算法，了解了图的构建算法，并加深了对DFS及BFS的理解，进一步加强了自学能力，拓展了思路。</p>
<h1 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h1><h2 id="graph-cpp"><a href="#graph-cpp" class="headerlink" title="graph.cpp"></a>graph.cpp</h2><pre><code class="c++">#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;iostream&gt;
using namespace std;

//节点遍历情况
enum visitCondition
{
    no,    //未访问
    visiting,    //正在访问，邻接点还没访问完
    yes    //访问完毕
};

template&lt;typename VertexType, typename InfoType&gt;
class Graph
{
public:
    Graph(int vertexNum) :m_vertexNum(vertexNum), m_arcNum(0)
    {
        for (int i = 0; i &lt; MAX_VERTEX_NUM; ++i)
        {
            m_vertices[i].firstArc = nullptr;
        }
    }

    //输出图的信息
    void Display()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个节点为&quot; &lt;&lt; m_vertices[i].data &lt;&lt; &quot; 邻接表为：&quot;;
            ArcNode* node = m_vertices[i].firstArc;
            while (node)
            {
                cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; m_vertices[node-&gt;vertexIndex].data;
                node = node-&gt;next;
            }
            cout &lt;&lt; endl;
        }
    }

    void BFS()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            m_vertices[i].visitconditions = no;
        }
        cout &lt;&lt; &quot;图的广度优先遍历为：&quot;;
        BFS(&amp;m_vertices[0]);
        cout &lt;&lt; endl;
    }

    void DFS()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            m_vertices[i].visitconditions = no;
        }
        cout &lt;&lt; &quot;图的深度优先遍历为：&quot;;
        DFS(&amp;m_vertices[0]);
        cout &lt;&lt; endl;
    }

    //创建无向无权图
    void Create()
    {
        InitVertices();
        cout &lt;&lt; &quot;请分别输入每条边的起始节点和终止节点:&quot; &lt;&lt; endl;
        int head, tail;
        while (cin &gt;&gt; head &gt;&gt; tail)
        {
            //无向图head-&gt;tail tail-&gt;head插入两次
            Insert(head, tail, 0);
            Insert(tail, head, 0);
        }
    }

    void FindMinRoad(int v1, int v2, int k)
    {

    }

private:
    struct ArcNode
    {
        int vertexIndex;        //该路径指向的顶点位置
        struct ArcNode* next;    //指向下一个路径
        InfoType info;            //该路径的相关信息，如权重等
    };

    struct Vertex
    {
        VertexType data;    //顶点信息
        ArcNode* firstArc;    //指向第一条依附该节点路径的指针
        visitCondition visitconditions;    //访问情况
    };

    //最大顶点数
    static const int MAX_VERTEX_NUM = 20;
    Vertex m_vertices[MAX_VERTEX_NUM];    //顶点列表
    int m_vertexNum;    //当前顶点数量
    int m_arcNum;        //当前路径数量
private:
    //初始化顶点列表
    void InitVertices()
    {
        cout &lt;&lt; &quot;请输入每个顶点的关键字&quot; &lt;&lt; endl;
        VertexType data;
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            cin &gt;&gt; data;
            m_vertices[i].data = data;
        }
    }
    //插入一个表节点
    void Insert(int headVertex, int tailVertex, InfoType info)
    {
        //构造一个邻接表节点，即创建一条路径
        ArcNode* newNode = new ArcNode;
        newNode-&gt;info = info;
        newNode-&gt;next = nullptr;
        newNode-&gt;vertexIndex = tailVertex;

        //找到邻接表的最后一个节点
        ArcNode* lastNode = m_vertices[headVertex].firstArc;
        if (lastNode == nullptr)
            m_vertices[headVertex].firstArc = newNode;
        else
        {
            while (lastNode-&gt;next)
            {
                lastNode = lastNode-&gt;next;
            }
            lastNode-&gt;next = newNode;
        }
        ++m_arcNum;
    }

    void BFS(Vertex* vertex)
    {
        vertex-&gt;visitconditions = visiting;
        queue&lt;Vertex*&gt; vertices;
        vertices.push(vertex);
        while (!vertices.empty())
        {
            Vertex* curVertex = vertices.front();
            vertices.pop();
            cout &lt;&lt; curVertex-&gt;data &lt;&lt; &quot;-&gt;&quot;;
            ArcNode* node = curVertex-&gt;firstArc;
            while (node)
            {
                Vertex* tmpVertex = &amp;m_vertices[node-&gt;vertexIndex];
                if (tmpVertex-&gt;visitconditions == no)
                {
                    tmpVertex-&gt;visitconditions = visiting;
                    vertices.push(tmpVertex);
                }
                node = node-&gt;next;
            }
            curVertex-&gt;visitconditions = yes;
        }
    }

    void DFS(Vertex* vertex)
    {
        vertex-&gt;visitconditions = visiting;
        stack&lt;Vertex*&gt; vertices;
        vertices.push(vertex);
        while (!vertices.empty())
        {
            Vertex* curVertex = vertices.top();
            vertices.pop();
            cout &lt;&lt; curVertex-&gt;data &lt;&lt; &quot;-&gt;&quot;;
            ArcNode* node = curVertex-&gt;firstArc;
            while (node)
            {
                Vertex* tmp = &amp;m_vertices[node-&gt;vertexIndex];
                if (tmp-&gt;visitconditions == no)
                {
                    tmp-&gt;visitconditions = visiting;
                    vertices.push(tmp);
                }
                node = node-&gt;next;
            }
            curVertex-&gt;visitconditions = yes;
        }
    }
};

int main()
{
    int  vertexNum, v1, v2 , k;
    cout &lt;&lt; &quot;请输入要创建的图的节点数：&quot;;
    cin &gt;&gt; vertexNum;
    Graph&lt;char, int&gt; g(vertexNum);
    g.Create();
    g.Display();
    g.BFS();
    g.DFS();
    //cout &lt;&lt; &quot;请依次输入需要寻找简单路径的起点和重点v1 v2和路径长度k：&quot;;
    //cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; k;
    //g.FindMinRoad(v1, v2, k);
}</code></pre>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/12/05/20-Use-adjacency-list-to-store-undirected-disconnected-graphs-and-traverse-adjacency-lists-with-DFS-and-BFS">https://zam9036.gitee.io/2019/12/05/20-Use-adjacency-list-to-store-undirected-disconnected-graphs-and-traverse-adjacency-lists-with-DFS-and-BFS</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>项目</tag>
        <tag>课程:数据结构英文C</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后拓展—利用DFS深度优先搜索算法解决N皇后问题|Zam9036博客</title>
    <url>/2019/12/03/19-Eight-Queens-Expansion-Using-DFS-Depth-First-Search-Algorithm-to-Solve-N-Queens-Problem/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><p>​    C++</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过求解皇后问题，熟悉深度优先搜索法DFS（回溯法（Backtracking Algorithms）技术。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>由n*n个方块排成n行n列的正方形称为n元棋盘。如果两个皇后位于n元棋盘上的同一行、同一列或同一对角线上，则称它们在互相攻击。现要找出使棋盘上n个皇后互不攻击的布局。</p>
<h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>用一维数组代表皇后，其中角标代表皇后的序数，数组元素的值代表皇后的列位置，用深度优先搜索法DFS（回溯法（Backtracking Algorithms）技术求解N皇后的所有不冲突放置方法。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>分别求解8皇后和12皇后的不冲突放置方法</p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="数据结构详细设计"><a href="#数据结构详细设计" class="headerlink" title="数据结构详细设计"></a>数据结构详细设计</h2><p>用一维数组代表皇后，其中角标代表皇后的序数，数组元素的值代表皇后的列位置，用深度优先搜索法DFS（回溯法Backtracking Algorithms）技术求解N皇后的所有不冲突放置方法。</p>
<p>首先定义一维数组，利用for循环对所有皇后的位置进行初始化。然后开始比较循环。用双层嵌套循环实现皇后的循环比较过程，每完成一次第一层循环将摆好一个皇后，利用二层循环来对单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，该皇后列位置向下移动一格。</p>
<h2 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h2><p>详细内容说明见注释</p>
<pre><code class="c++">while (true) // 开始循坏
    {
        for (int i = 0; i &lt; N; i++) // 一层循环，每次循环完成摆好一个皇后（行循环）
            {
                for (int j = 0 ; j &lt; i ; j++) // 二层循环，单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，列位置向下移动一格
                {
                    if (A[i] &gt;= N) // 皇后超出棋盘
                    {
                        A[i] = 0;
                        A[i - 1]++;
                        i--;
                        j = -1;
                    }
                    else if (!checkQueens(i,j)&amp;&amp;(i != 0)) // 检查皇后是否与已摆好的皇后冲突
                    {
                        A[i]++;
                        j = -1;
                    }
                }
            }
        // 当第一个皇后到达棋盘底端时结束程序
        if (A[0] &gt; N - 1) {
            break;
        }
        for (int e = 0; e &lt; N; e++) // 打印结果
        {
            cout &lt;&lt; &quot;(&quot; &lt;&lt; e &lt;&lt; &quot;,&quot; &lt;&lt; A[e] &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        num++;A[N-1]++;
    }</code></pre>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><p><img src="https://zam9036.gitee.io/img/postimg/%E5%85%AB%E7%9A%87%E5%90%8E%E6%8B%93%E5%B1%95%E2%80%94%E5%88%A9%E7%94%A8DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/1.png" alt="8皇后"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%85%AB%E7%9A%87%E5%90%8E%E6%8B%93%E5%B1%95%E2%80%94%E5%88%A9%E7%94%A8DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/2.png" alt="12皇后"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="循环边界条件不清"><a href="#循环边界条件不清" class="headerlink" title="循环边界条件不清"></a>循环边界条件不清</h3><p>解决方法：对程序进行逐行调试，在运行循环判断时稍事等待，思考判断条件。</p>
<h1 id="使用说明和测试结果"><a href="#使用说明和测试结果" class="headerlink" title="使用说明和测试结果"></a>使用说明和测试结果</h1><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>用Visual Studio打开.sln文件即可运行</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过，符合程序设计要求和需求分析</p>
<p>详细结果见调试分析-示例测试</p>
<h1 id="体会心得"><a href="#体会心得" class="headerlink" title="体会心得"></a>体会心得</h1><p>通过本次课程实验，我对数据结构的了解进一步加深，并产生了浓厚的兴趣。虽然在写代码过程中遇到了一些问题，但我通过思考、网上找资料、询问同学等方式最终解决了问题。这次实验让我进一步理解了深度优先搜索法DFS（回溯法Backtracking Algorithms）技术的原理，锻炼了我静心逐行调试代码的能力，并且熟悉了C++的语法，进一步加强了自学能力，拓展了思路。</p>
<h1 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h1><h2 id="EQ-h"><a href="#EQ-h" class="headerlink" title="EQ.h"></a>EQ.h</h2><pre><code class="c++">#pragma once

#include &lt;iostream&gt; // 导入库
using namespace std; // 使用标准命名空间

#define N 12 // 设置皇后个数

bool checkQueens(int i, int j); // 判断皇后冲突的函数</code></pre>
<h2 id="EightQueens-cpp"><a href="#EightQueens-cpp" class="headerlink" title="EightQueens.cpp"></a>EightQueens.cpp</h2><pre><code class="c++">#include &quot;EQ.h&quot;; // 导入头文件

int A[N]; // 用一维数组代表皇后

int main()
{
    int num = 0; // 解法计数器
    int checknum = 0; // 判断皇后冲突用的数值计数器
    for (int i = 0; i &lt; N; i++) // 初始化皇后位置
    {
        A[i] = 0;
    }
    while (true) // 开始循坏
    {
        for (int i = 0; i &lt; N; i++) // 一层循环，每次循环完成摆好一个皇后（行循环）
            {
                for (int j = 0 ; j &lt; i ; j++) // 二层循环，单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，列位置向下移动一格
                {
                    if (A[i] &gt;= N) // 皇后超出棋盘
                    {
                        A[i] = 0;
                        A[i - 1]++;
                        i--;
                        j = -1;
                    }
                    else if (!checkQueens(i,j)&amp;&amp;(i != 0)) // 检查皇后是否与已摆好的皇后冲突
                    {
                        A[i]++;
                        j = -1;
                    }
                }
            }
        // 当第一个皇后到达棋盘底端时结束程序
        if (A[0] &gt; N - 1) {
            break;
        }
        for (int e = 0; e &lt; N; e++) // 打印结果
        {
            cout &lt;&lt; &quot;(&quot; &lt;&lt; e &lt;&lt; &quot;,&quot; &lt;&lt; A[e] &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        num++;A[N-1]++;
    }
    printf(&quot;%d个皇后，不考虑棋盘对称性，共%d种解法\n&quot;,N,num); // 提示语
    return 0;
}

bool checkQueens(int i ,int j) {
    if ((A[i] + i == A[j] + j) || (A[i] == A[j]) || (A[i] - i == A[j] - j)) // 皇后冲突
    {
        return false;
    }
    else // 皇后不冲突
    {
        return true;
    }
}</code></pre>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/12/03/19-Eight-Queens-Expansion-Using-DFS-Depth-First-Search-Algorithm-to-Solve-N-Queens-Problem">https://zam9036.gitee.io/2019/12/03/19-Eight-Queens-Expansion-Using-DFS-Depth-First-Search-Algorithm-to-Solve-N-Queens-Problem</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>项目</tag>
        <tag>课程:数据结构英文C</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-4|Zam9036博客</title>
    <url>/2019/11/24/18-Object-oriented-technical-problem-classification-example-4/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="类和对象的特性"><a href="#类和对象的特性" class="headerlink" title="类和对象的特性"></a>类和对象的特性</h3><h4 id="31、利用面向对象的思想求解长方体体积"><a href="#31、利用面向对象的思想求解长方体体积" class="headerlink" title="31、利用面向对象的思想求解长方体体积"></a>31、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，分别为r1, r2, r3，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求有序输出三个长方体的体积。</p>
<p><img src="/https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/31.jpg" alt="输出样例31"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box r1(a, b, c), r2(d, e, f), r3(g, h, i);
    box arr[3];
    arr[0] = r1;
    arr[1] = r2;
    arr[2] = r3;
    box *bp = arr;
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h4 id="32、构造函数与析构函数"><a href="#32、构造函数与析构函数" class="headerlink" title="32、构造函数与析构函数"></a>32、构造函数与析构函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义圆类Circle，利用类的复合（组合）定义圆柱类Column，然后创建圆柱类Column的实例化对象。</p>
<p>圆类Circle包含两个部分：</p>
<p>一、私有数据：点坐标x，y，半径r。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、area函数：计算圆的面积。</p>
<p>4、print函数：输出点坐标x，y及半径r的值。</p>
<p>圆柱类Column包含两个部分：</p>
<p>一、私有数据：</p>
<p>1、类Circle的对象circle。</p>
<p>2、圆柱高height。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、volume函数：计算圆柱的体积。要求使用circle.area（）。</p>
<p>4、print函数：输出点坐标x，y及半径r的值。</p>
<p>注：圆周率取3.14159</p>
<p>部分代码已在下面给出，要求不能改动已有代码</p>
<pre><code class="c++">int main()
{
Column obj(2.3,3.4,4.5,5.6);
cout&lt;&lt;&quot;The volume of obj is &quot;&lt;&lt;obj.volume()&lt;&lt;endl;
return 0;
}</code></pre>
<p><img src="/https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/32.jpg" alt="输出样例32"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Circle
{
public:
    Circle(double, double, double);
    ~Circle();
    float area();
    void print();

private:
    double x;
    double y;
    double r;
};

class Column
{
public:
    Column(double, double, double, double);
    ~Column();
    float volume();
    void print();

private:
    Circle circle;
    double height;
};

Circle::Circle(double a, double b, double c)
{
    x = a;
    y = b;
    r = c;
    cout &lt;&lt; &quot;Circle object start:&quot;
         &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

Circle::~Circle()
{
    cout &lt;&lt; &quot;Circle object end:x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

float Circle::area()
{
    return (3.14159 * r * r);
}

void Circle::print()
{
    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

Column::Column(double h, double a, double b, double c) : circle(a, b, c)
{
    height = h;
    cout &lt;&lt; &quot;Column object start:height=&quot; &lt;&lt; height &lt;&lt; &quot;,&quot;;
    circle.print();
}

Column::~Column()
{
    cout &lt;&lt; &quot;Column object end:height=&quot; &lt;&lt; height &lt;&lt; &quot;,&quot;;
    circle.print();
}

float Column::volume()
{
    float m;
    m = circle.area();
    return (m * height);
}

int main()
{
    Column obj(2.3, 3.4, 4.5, 5.6);
    cout &lt;&lt; &quot;The volume of obj is &quot; &lt;&lt; obj.volume() &lt;&lt; endl;
    return 0;
}</code></pre>
<h4 id="33、编写一个音响资料类Media，要求包含音像资料基本信息。"><a href="#33、编写一个音响资料类Media，要求包含音像资料基本信息。" class="headerlink" title="33、编写一个音响资料类Media，要求包含音像资料基本信息。"></a>33、编写一个音响资料类Media，要求包含音像资料基本信息。</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>Media包含两个部分：</p>
<p>一、私有数据：名称name、种类type。</p>
<p>二、公有函数：所有函数要求类外定义 编写一个音响资料类Media，要求包含音像资料基本信息。</p>
<p>Media包含两个部分：</p>
<p>一、私有数据：名称name、种类type。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、setType函数：设置type的值。</p>
<p>4、函数：输出媒体资料的基本信息，要求见下表</p>
<p><img src="/https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/33-1.jpg" alt="输出样例33-1"></p>
<p>测试函数main如下，要求不能改动main函数：</p>
<pre><code class="c++">#define ISAUDIO 1
#define ISVIDEO 2
int main()
{
 Media discDion(&quot;The Colour of My Love &quot;),discHanks(&quot;Forrest Gump &quot;);
 discDion.setType(ISAUDIO);
 discHanks.setType(ISVIDEO);
 discDion.showInfo ();
 discHanks.showInfo ();
 return 0;
}</code></pre>
<p><img src="/https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/33-2.jpg" alt="输出样例33-2"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#define ISAUDIO 1
#define ISVIDEO 2
using namespace std;

class Media
{
private:
    string name;
    int type;

public:
    Media();
    Media(string a);
    ~Media();
    void setType(int a);
    void showInfo();
};
Media::Media(string a)
{
    name = a;
}
Media::Media()
{
    name = &quot;&quot;;
    type = 0;
}
Media::~Media()
{
}
void Media::setType(int a)
{
    type = a;
}
void Media::showInfo()
{
    if (type == 1)
        cout &lt;&lt; &quot;The Colour of My Love is a &quot;
             &lt;&lt; &quot;audio disc&quot;
             &lt;&lt; &quot;.&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;Forrest Gumpis a &quot;
             &lt;&lt; &quot;video disc&quot;
             &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}

int main()
{
    Media discDion(&quot;The Colour of My Love &quot;), discHanks(&quot;Forrest Gump &quot;);
    discDion.setType(ISAUDIO);
    discHanks.setType(ISVIDEO);
    discDion.showInfo();
    discHanks.showInfo();
    return 0;
}</code></pre>
<h4 id="34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）"><a href="#34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）" class="headerlink" title="34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）"></a>34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code class="c++">class Rectangle {
private:
    double width, height;
public:
    Rectangle ( double w = 0., double h = 0.) : width(w), height(h) { }
//请补全必要代码
};</code></pre>
<p>使得如下的函数能够正确地按照每个Rectangle对象的面积从小到大进行排序，并且main函数能通过编译且运行后能够得到样例输出。（请将下列代码复制到你补全后的Rectangle类之后，一并提交。）  </p>
<pre><code class="c++">template&lt;typename T&gt;
void insertSort(T *ptr, int size) {
    for(int i = 1; i &lt; size; ++i) {
        for( int j = i; j &gt; 0; --j) {
            if( ptr[j] &lt; ptr[j - 1]) {
                T temp = ptr[j];
                ptr[j ] = ptr[j - 1];
                ptr[j - 1] = temp;
            }
            else
                break;
        }
    }
}

int main () {
    Rectangle data[4];
    data[0] = Rectangle(1,2);
    data[1] = Rectangle(5,7);
    data[2] = Rectangle(2,8);
    data[3] = Rectangle(3,4);
    for(int i = 0; i &lt; 4; ++i) {
           printf(&quot;%f,&quot;, data[i].getArea());
     }
    printf(&quot;\n&quot;);
    insertSort( data, 4);
    for(int i = 0; i &lt; 4; ++i) {
           printf(&quot;%f,&quot;, data[i].getArea());
    }
        return 1;
}</code></pre>
<p>注：模板必须使用<code>template&lt;typename T&gt;</code><br>测试用例：</p>
<pre><code class="c++">//输入：
    Rectangle data[4];
    data[0] = Rectangle(1,2);
    data[1] = Rectangle(5,7);
    data[2] = Rectangle(2,8);
    data[3] = Rectangle(3,4);</code></pre>
<p><img src="/https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/34.jpg" alt="输出样例34"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class Rectangle
{
private:
    double width, height;

public:
    Rectangle(double w = 0, double h = 0) : width(w), height(h) {}
    double getArea()
    {
        return width * height;
    }
    friend bool operator&lt;(Rectangle a, Rectangle b)
    {
        if (a.getArea() &gt; b.getArea())
            return 0;
        else
            return 1;
    }
};

template &lt;typename T&gt;
void insertSort(T *ptr, int size)
{
    for (int i = 1; i &lt; size; ++i)
    {
        for (int j = i; j &gt; 0; --j)
        {
            if (ptr[j] &lt; ptr[j - 1])
            {
                T temp = ptr[j];
                ptr[j] = ptr[j - 1];
                ptr[j - 1] = temp;
            }
            else
                break;
        }
    }
}

int main()
{
    Rectangle data[4];
    data[0] = Rectangle(1, 2);
    data[1] = Rectangle(5, 7);
    data[2] = Rectangle(2, 8);
    data[3] = Rectangle(3, 4);
    for (int i = 0; i &lt; 4; ++i)
    {
        printf(&quot;%f,&quot;, data[i].getArea());
    }
    printf(&quot;\n&quot;);
    insertSort(data, 4);
    for (int i = 0; i &lt; 4; ++i)
    {
        printf(&quot;%f,&quot;, data[i].getArea());
    }
    return 0;
}</code></pre>
<h4 id="35、通过重载运算符来模拟时间"><a href="#35、通过重载运算符来模拟时间" class="headerlink" title="35、通过重载运算符来模拟时间"></a>35、通过重载运算符来模拟时间</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个Time类，包含数据成员minute（分）和sec（秒），模拟秒表，每次走一秒，满60秒进一分钟，此时秒又从0起算，要求输出分和秒的值。</p>
<p>已有如下的main函数，要求编写能支持该main函数的Time类。</p>
<pre><code class="c++">int main()
{
    Time time1(34,50);
    for(int i = 0; i &lt; 20; i++)
    {
        ++time1;
        time1.display();
    }
    return 0;
}</code></pre>
<pre><code class="控制台">//输出样例35
34:51
34:52
34:53
34:54
34:55
34:56
34:57
34:58
34:59
35:0
35:1
35:2
35:3
35:4
35:5
35:6
35:7
35:8
35:9
35:10</code></pre>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Time
{
private:
    int minute, sec;

public:
    Time(int a, int b)
    {
        if (b &gt; 59)
        {
            minute = a + 1;
            sec = b - 60;
        }
        else
        {
            minute = a;
            sec = b;
        }
    }
    Time()
    {
        minute = 0;
        sec = 0;
    }
    void display()
    {
        cout &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; sec &lt;&lt; endl;
    }
    friend operator++(Time &amp;a)
    {
        a.sec++;
        if (a.sec &gt; 59)
        {
            a.minute = a.minute + 1;
            a.sec = a.sec - 60;
        }
    }
};

int main()
{
    Time time1(34, 50);
    for (int i = 0; i &lt; 20; i++)
    {
        ++time1;
        time1.display();
    }
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/24/18-Object-oriented-technical-problem-classification-example-4">https://zam9036.gitee.io/2019/11/24/18-Object-oriented-technical-problem-classification-example-4</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-3|Zam9036博客</title>
    <url>/2019/11/20/17-Object-oriented-technical-problem-classification-example-3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h3><h4 id="21、定义复数类，并使用运算符重载来实现其功能"><a href="#21、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="21、定义复数类，并使用运算符重载来实现其功能"></a>21、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符+，使之能用于复数的加法。运算符的重载函数作为Complex类的成员函数，求两个复数的和。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/21.jpg" alt="输出样例21"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 + c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="22、重载运算符使之能进行复数的运算"><a href="#22、重载运算符使之能进行复数的运算" class="headerlink" title="22、重载运算符使之能进行复数的运算"></a>22、重载运算符使之能进行复数的运算</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>下面是一个用来表达复数的类Complex的部分代码.该类包含两个私有double型成员变量，分别代表复数的实部和虚部，默认为0。</p>
<pre><code class="c++">class Complex {
private:
    double real;
    double img;
public:
//..
Complex operator + (const Complex &amp; other) //….
};</code></pre>
<p>请按要求补全该类其他代码。</p>
<p>该类需有完备的类构造函数，至少支持Complex a; Complex b(a); Complex c(4, 5); 这三种定义Complex类对象的方式。重载操作符+, +=, <em>, 分别完成两个复数的加法和乘法，其中操作符</em>的重载必须用友元函数的形式完成。</p>
<p>补全该类后，对于如下的main函数，要求其能通过编译，并正常运行。</p>
<pre><code class="c++">int main () {
    Complex c2(2., 3.), c3 = c2 + Complex(1., 2.),c1(c2);
    Complex c4;
    c4 += c2 * c3 + c2;
    cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; c3 &lt;&lt; c4;
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/22.jpg" alt="输出样例22"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Complex
{
private:
    double real;
    double img;

public:
    Complex(double real = 0, double img = 0);
    Complex(const Complex &amp;c2)
    {
        real = c2.real;
        img = c2.img;
    }
    Complex operator+(const Complex &amp;other)
    {
        Complex c;
        c.real = real + other.real;
        c.img = img + other.img;
        return c;
    }
    Complex operator+=(const Complex &amp;c1)
    {
        *this = *this + c1;
        return *this;
    }
    friend Complex operator*(Complex &amp;c1, Complex &amp;c2)
    {
        return Complex((c1.real * c2.real - c1.img * c2.img), (c1.img * c2.real + c1.real * c2.img));
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, Complex &amp;c)
    {
        if (c.img &gt;= 0)
            output &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.img &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c.real &lt;&lt; c.img &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};
Complex::Complex(double a, double b)
{
    real = a;
    img = b;
}
int main()
{
    Complex c2(2., 3.), c3 = c2 + Complex(1., 2.), c1(c2);
    Complex c4;
    c4 += c2 * c3 + c2;
    cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; c3 &lt;&lt; c4;
    return 0;
}</code></pre>
<h3 id="类和对象的特性"><a href="#类和对象的特性" class="headerlink" title="类和对象的特性"></a>类和对象的特性</h3><h4 id="23、将普通函数声明为友元并使用它输出日期与时间"><a href="#23、将普通函数声明为友元并使用它输出日期与时间" class="headerlink" title="23、将普通函数声明为友元并使用它输出日期与时间"></a>23、将普通函数声明为友元并使用它输出日期与时间</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>顺序定义时间类Time与日期类Date。其中，Time拥有私有数据hour, minute, second，以及友元函数display；Date拥有私有数据day, month, year，以及友元函数display。在类外定义display函数并实现它，display函数接收一个Time类和一个Date类的引用，并将其按照格式输出。 运行时依次从键盘输入day, month, year,hour, minute, second，最后调用display函数将其全部按格式输出。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/23.jpg" alt="输出样例23"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Date;
class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    friend void display(Date &amp;d, Time &amp;t);
};
class Date
{
private:
    int day, month, year;

public:
    Date(int a, int b, int c)
    {
        day = a;
        month = b;
        year = c;
    }
    friend void display(Date &amp;d, Time &amp;t);
};

void display(Date &amp;d, Time &amp;t)
{
    cout &lt;&lt; d.day &lt;&lt; &quot;/&quot; &lt;&lt; d.month &lt;&lt; &quot;/&quot; &lt;&lt; d.year &lt;&lt; &quot;&quot; &lt;&lt; t.hour &lt;&lt; &quot;:&quot; &lt;&lt; t.minute &lt;&lt; &quot;:&quot; &lt;&lt; t.second &lt;&lt; endl;
}

int main()
{
    int a, b, c, d, e, f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;
    Time t(d, e, f);
    Date dd(a, b, c);
    display(dd, t);
    return 0;
}</code></pre>
<h4 id="24、使用友元成员函数输出日期与时间"><a href="#24、使用友元成员函数输出日期与时间" class="headerlink" title="24、使用友元成员函数输出日期与时间"></a>24、使用友元成员函数输出日期与时间</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>顺序声明时间类Time与日期类Date。其中Time拥有私有数据hour, minute, second，以及公有函数display(接收一个Date的引用作为参数)；Date拥有私有数据day, month, year，以及友元函数display(要求声明Time中的display函数为Date的友元成员函数)。运行时依次从键盘输入day, month, year,hour, minute, second，最后调用Time的display函数将其全部按格式输出。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/24.jpg" alt="输出样例24"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Date;
class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    void display(Date &amp;t);
};
class Date
{
private:
    int day, month, year;

public:
    Date(int a, int b, int c)
    {
        day = a;
        month = b;
        year = c;
    }
    friend void Time::display(Date &amp;);
};

void Time::display(Date &amp;t)
{
    cout &lt;&lt; t.day &lt;&lt; &quot;/&quot; &lt;&lt; t.month &lt;&lt; &quot;/&quot; &lt;&lt; t.year &lt;&lt; &quot;&quot; &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; endl;
}

int main()
{
    int a, b, c, d, e, f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;
    Time t(d, e, f);
    Date dd(a, b, c);
    t.display(dd);
    return 0;
}</code></pre>
<h4 id="25、使用友元函数输出时间"><a href="#25、使用友元函数输出时间" class="headerlink" title="25、使用友元函数输出时间"></a>25、使用友元函数输出时间</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一时间类Time，拥有私有成员hour, minute, second，以及一友元函数display。display以引用的方式接收一个Time对象，并以hour:minute:second的格式来输出时间。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/25.jpg" alt="输出样例25"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    friend void display(Time &amp;t)
    {
        cout &lt;&lt; t.hour &lt;&lt; &quot;:&quot; &lt;&lt; t.minute &lt;&lt; &quot;:&quot; &lt;&lt; t.second;
    }
};

int main()
{
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    Time t(a, b, c);
    display(t);
    return 0;
}</code></pre>
<h4 id="26、使用指针传参找到成绩最高的学生"><a href="#26、使用指针传参找到成绩最高的学生" class="headerlink" title="26、使用指针传参找到成绩最高的学生"></a>26、使用指针传参找到成绩最高的学生</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(共5人，其类名为Student)的数据需要存放，包括私有数据成绩(名为score)，数据从键盘输入。要求使用名为arr的对象静态数组存放这5个学生的数据，并使用名为sp的对象指针指向其对象数组的首地址（要求使用取地址符），最后将该指针传递给max函数(指针在max中的形参名为p)，找出5个学生中成绩最高者并输出其成绩。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/26.jpg" alt="输出样例26"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    friend Student max(Student *p);
    void display()
    {
        cout &lt;&lt; score;
    }
};

Student max(Student *p)
{
    Student s;
    for (int i; i &lt; 5; i++, p++)
        if (s.score &lt; p-&gt;score)
        {
            s = *p;
        }
    return s;
}

int main()
{
    int a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
    Student s1(a), s2(b), s3(c), s4(d), s5(e);
    Student arr[5];
    arr[0] = s1;
    arr[1] = s2;
    arr[2] = s3;
    arr[3] = s4;
    arr[4] = s5;
    Student *sp;
    sp = &amp;arr[0];
    Student aa = max(sp);
    aa.display();
    return 0;
}</code></pre>
<h4 id="27、用指针输出学生信息"><a href="#27、用指针输出学生信息" class="headerlink" title="27、用指针输出学生信息"></a>27、用指针输出学生信息</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(共5人，其类名为Student)的数据需要存放，包括私有数据成绩(名为score)，数据从键盘输入。要求使用名为arr的对象数组（要求动态分配）存放这5个学生的数据，并使用名为sp的对象指针指向其对象数组的首地址（要求使用取地址符），随后有序输出第1、3、5个学生的数据。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/27.jpg" alt="输出样例27"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    void display()
    {
        cout &lt;&lt; score &lt;&lt; &quot; &quot;;
    }
};

int main()
{
    int a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
    Student s1(a), s2(b), s3(c), s4(d), s5(e);
    Student *arr = new Student[5];
    if (!arr)
        cout &lt;&lt; &quot;内存分配失败&quot;;
    else
    {
        arr[0] = s1;
        arr[1] = s2;
        arr[2] = s3;
        arr[3] = s4;
        arr[4] = s5;
        Student *sp;
        sp = &amp;arr[0];
        sp-&gt;display();
        (sp + 2)-&gt;display();
        (sp + 4)-&gt;display();
        delete[] sp;
        sp = NULL;
    }
    return 0;
}</code></pre>
<h4 id="28、统计学生平均成绩，要求使用静态成员函数"><a href="#28、统计学生平均成绩，要求使用静态成员函数" class="headerlink" title="28、统计学生平均成绩，要求使用静态成员函数"></a>28、统计学生平均成绩，要求使用静态成员函数</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(其类名为Student)成绩(均为整数)需要统计，要求使用类内静态公有函数(函数名为average)求出这批学生的平均成绩(学生人数并不确定)。在输入成绩时，先输入一个整数，表示学生总人数，然后再输入相应个数学生成绩，并将这些数据都存入一个名为arr的数组中,该数组必须使用new动态开辟，最后输出学生的平均成绩。(结果要求保留1位小数，检测内存分配是否成功需使用NULL)</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/28.jpg" alt="输出样例28"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    int get()
    {
        return score;
    }
    static float average(int n, Student arr[])
    {
        int a;
        for (int i = 0; i &lt; n; i++)
        {
            a += arr[i].get();
        }
        return (float)a / n;
    }
};

int main()
{
    int a, b;
    cin &gt;&gt; a;
    Student *arr = new Student[a];
    for (int i; i &lt; a; i++)
    {
        cin &gt;&gt; b;
        arr[i] = Student(b);
    }
    if (arr == NULL)
        cout &lt;&lt; &quot;xx&quot;;
    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1);
    cout &lt;&lt; Student::average(a, arr);

    delete arr;
    return 0;
}</code></pre>
<h4 id="29、利用面向对象的思想求解长方体体积"><a href="#29、利用面向对象的思想求解长方体体积" class="headerlink" title="29、利用面向对象的思想求解长方体体积"></a>29、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，存储在一个名为arr的静态对象数组中，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求使用名为bp的指针指向这个数组的首地址（要求使用数组名），并有序输出三个长方体的体积，体积的计算须使用volume函数。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/29.jpg" alt="输出样例29"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box a1(a, b, c), a2(d, e, f), a3(g, h, i);
    box arr[3];
    arr[0] = a1;
    arr[1] = a2;
    arr[2] = a3;
    box *bp = arr;
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h4 id="30、利用面向对象的思想求解长方体体积"><a href="#30、利用面向对象的思想求解长方体体积" class="headerlink" title="30、利用面向对象的思想求解长方体体积"></a>30、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，存储在一个名为arr的静态对象数组中，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求有序输出三个长方体的体积。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/30.jpg" alt="输出样例30"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box a1(a, b, c), a2(d, e, f), a3(g, h, i);
    box arr[3];
    arr[0] = a1;
    arr[1] = a2;
    arr[2] = a3;
    box *bp;
    bp = &amp;arr[0];
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/20/17-Object-oriented-technical-problem-classification-example-3">https://zam9036.gitee.io/2019/11/20/17-Object-oriented-technical-problem-classification-example-3</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHubPages个人博客迁移至码云从而加快博客访问速度|Zam9036博客</title>
    <url>/2019/11/16/16-GitHubPages-personal-blog-migrates-to-mayun-to-speed-blog-access/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GitHubPages部署静态网页十分方便与快捷，常常被用来建立个人博客。但因为其服务器设在国外，且曾经被中国防火长城GFW屏蔽（后来解除屏蔽），导致其访问速度十分缓慢，甚至极少数状态下出现访问出错的状况，极大影响了博客的使用体验。所以我近期尝试将GitHub的Hexo博客迁移至国内码云，以解决博客访问过于缓慢的情况。</p>
<h2 id="迁移流程"><a href="#迁移流程" class="headerlink" title="迁移流程"></a>迁移流程</h2><h3 id="建立码云仓库"><a href="#建立码云仓库" class="headerlink" title="建立码云仓库"></a>建立码云仓库</h3><p>创建码云账号的流程我在此就不过多赘述了，根据提示操作即可，下面我来说一下建立码云仓库的操作。码云的仓库建立机制和GitHub一样，只需要新建仓库然后填写信息即可，其中仓库名字尤为关键。码云的静态资源托管平台可以托管用户的任意仓库，不必像GitHub那样仓库名必须和用户名一致才可。用户创建任意仓库，然后点击<code>服务-GiteePages</code>即可开启该仓库的静态资源托管服务。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/1.jpg" alt="开启Page服务"></p>
<p>但是！在这里建议大家仓库名仍使用和自己码云用户名相同的名称！！因为当博客仓库名与自己的个性地址不一致时，博客部署完成后会存在一些资源访问404。原因是当需要部署的仓库和自己的个性地址不一致时，如：<a href="https://gitee.com/ipvb/blog" target="_blank" rel="noopener">https://gitee.com/ipvb/blog</a> ，生成的pages url 为 <a href="https://ipvb.gitee.io/blog" target="_blank" rel="noopener">https://ipvb.gitee.io/blog</a> ，而访问的资源404，如 <a href="https://ipvb.gitee.io/style.css" target="_blank" rel="noopener">https://ipvb.gitee.io/style.css</a> 这是相应配置文件的相对路径存在问题导致的，生成的资源 url 应该为 <a href="https://ipvb.gitee.io/blog/style.css" target="_blank" rel="noopener">https://ipvb.gitee.io/blog/style.css</a> 才对。 而针对这个问题官方给出了解决方案。</p>
<blockquote>
<p>对于不同的静态资源生成器，配置如下： </p>
<ul>
<li><p>Hugo 配置文件config.toml的baseURL修改如下</p>
<pre><code>baseURL = &quot;https://ipvb.gitee.io/blog&quot;</code></pre></li>
<li><p>Hexo 配置文件_config.yml的url和root修改如下：</p>
<pre><code>url: https://ipvb.gitee.io/blog
root: /blog</code></pre></li>
<li><p>Jekyll配置文件_config.yml的baseurl修改如下：</p>
<pre><code>baseurl: &quot;/blog&quot; # the subpath of your site, e.g. /blog</code></pre></li>
</ul>
</blockquote>
<p>但是！！按照这个做法，博客的Js等文件能够加载，本地的图片等文件无法加载，设置完成后点击图片会按照未修改的链接跳转导致404。</p>
<p>所以多一事不如少一事，我们直接创建一个和用户名相同的仓库，这样就可以直接跳过二级目录，通过<code>用户名.gitee.io</code>直接访问博客。</p>
<p>另外，码云的静态资源托管功能可以托管Jekyll、Hugo、Hexo编译的静态资源。</p>
<blockquote>
<p>Jekyll、Hugo、Hexo 编译判断依据</p>
<ol>
<li>编译 Hugo 依据：仓库编译目录下存在<code>config.toml|json|yaml</code>文件和<code>content</code>目录的时候，会使用<code>hugo</code>生成静态文件。</li>
<li>编译 Hexo 依据：仓库编译目录下存在<code>package.json</code>，<code>_config.yml</code>文件和<code>scaffolds</code>目录的，会使用<code>hexo generate</code>生成静态文件，由于每次部署编译需要重新克隆编译并进行<code>npm install</code>，所以使用 Hexo 的时间相对 Hugo 和 Jekyll 会长一些。</li>
<li>当不符合上述1和2条件的时候，就默认使用Jekyll编译。</li>
</ol>
</blockquote>
<h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><p>与GitHub配置SSH一致，遇有疑问请访问<a href="https://zam9036.gitee.io/2019/10/23/利用GitHub+Hexo搭建个人博客详细教程">利用GitHub+Hexo搭建个人博客详细教程</a>。当然，使用当时GitHub建立的SSH就可以。</p>
<h3 id="修改Hexo配置"><a href="#修改Hexo配置" class="headerlink" title="修改Hexo配置"></a>修改Hexo配置</h3><p>找到Hexo配置文件_config.yml，注意不是主题配置文件。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/2.jpg" alt="Hexo配置文件"></p>
<p>找到以下语句</p>
<pre><code class="yml"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:</code></pre>
<p>修改为</p>
<pre><code class="yml"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repository: git@gitee.com:zam9036/zam9036.git
  branch: master</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/3.png" alt="修改Hexo配置文件"></p>
<p>注意，<code>repository:</code>处的内容可以在码云平台上找到</p>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/4.png" alt="码云平台"></p>
<p>至此，配置文件修改完毕，博客迁移完毕。</p>
<h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><p>按照上面流程迁移完毕后，写好博客，执行<code>hexo g</code>然后执行<code>hexo d</code>即可上传博客代码到码云服务器。与GitHub不同，码云需要手动部署博客，找到博客仓库，点击Pages服务，如图点击更新按钮即可部署。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/5.png" alt="更新部署博客"></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/16/16-GitHubPages-personal-blog-migrates-to-mayun-to-speed-blog-access">https://zam9036.gitee.io/2019/11/16/16-GitHubPages-personal-blog-migrates-to-mayun-to-speed-blog-access</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Hexo博客安装hexo-generator-search遇到的问题|Zam9036博客</title>
    <url>/2019/11/13/15-Record-the-problems-encountered-by-Hexo-blog-installation-hexo-generator-search/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在用Git bash安装<code>hexo-generator-search</code>和<code>hexo-generator-searchdb</code>来实现本地搜索时遇到以下问题</p>
<pre><code class="bash">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.1 (node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.1: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\nunjucks\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})

+ hexo-generator-search@2.4.0
updated 1 package and audited 7064 packages in 7.194s
found 0 vulnerabilities</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="问题描述"></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>查阅资料得知，出现这样的原因是：fsevents不在package.json里，但是仍然安装了，是因为本机系统是Windows系统，而fsevents是苹果系统的可选依赖，博客主题作者可能是Mac电脑，所以作者在他的Mac上安装了fsevents相关依赖库，到本机也就自动安装到本机windows上边了。</p>
<p>既然Git bash不成，来尝试一下Windows的命令提示符cmd。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="cmd1"></p>
<p>出现了新的问题.. 根据错误提示，是系统没有“package.json”这个文件导致。这个文件的作用就是管理你本地安装的npm包。此刻我们需要执行命令<code>npm init</code>创建package.json文件，系统会提示相关配置；或者可以使用命令：</p>
<pre><code>npm init -y</code></pre><p>直接创建package.json文件，这样创建的json文件的必填项已经帮你填好，执行完命令后我们可以看到用户路径下多了一个package.json文件。</p>
<p>在此我们选择第二种创建json文件的方式。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/3.png" alt="创建json文件"></p>
<p>然后我们再次在cmd上执行命令</p>
<pre><code class="cmd">npm install hexo-generator-search --save
npm install hexo-generator-searchdb --save</code></pre>
<p>依然提示Warning，但此时已经没有<code>SAVEERROR</code>，我们选择忽略Warning。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/4.png" alt="cmd2"></p>
<p>在博客根目录配置 <code>_config.yml</code> 里面添加hexo-generator-search的配置</p>
<pre><code class="yml">search:
  path: search.xml
  field: post    //post代表仅搜索博客文章，page代表搜索页面，all代表全部搜索
  content: true
  limit: 9999    //输入搜索字符上限</code></pre>
<p>重新生成静态文件</p>
<pre><code class="bash">hexo clean &amp;&amp; hexo g</code></pre>
<p>然后上传代码，发现问题解决！！！</p>
<h2 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a>问题拓展</h2><p>本篇博客仅记录安装hexo-generator-search时遇到的问题，如需实现博客本地搜索功能，请查看<a href="https://www.jianshu.com/p/685bf59cde5e" target="_blank" rel="noopener">参考</a></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/13/15-Record-the-problems-encountered-by-Hexo-blog-installation-hexo-generator-search">https://zam9036.gitee.io/2019/11/13/15-Record-the-problems-encountered-by-Hexo-blog-installation-hexo-generator-search</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序中序后续递归与非递归遍历及左右子树交换|Zam9036博客</title>
    <url>/2019/11/09/14-Pre-order-mid-order-subsequent-recursion-and-non-recursive-traversal-of-binary-tree-and-left-and-right-subtree-exchange/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>​    C++</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>​    熟悉C++语法，了解树的概念，掌握二叉树的运算及应用，了解前序中序后序遍历二叉树的递归/非递归原理，能够实现将二叉树左右子树结点交换。</p>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>生成一棵以二叉链表存储的二叉树（至少15个结点）</p>
<p>分别用递归和非递归的方法前序、中序、后序遍历该二叉树，并打印各结点信息</p>
<p>编写算法，交换该二叉树上所有结点的左右子树，并打印交换后各结点的信息</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="程序要求"><a href="#程序要求" class="headerlink" title="程序要求"></a>程序要求</h3><p>​    生成一棵不少于15结点的二叉树，用二叉链表存储该二叉树。编写算法，利用递归算法实现该二叉树的前序中序后序遍历，并打印交换后各结点的信息。编写算法，利用非递归算法实现该二叉树的前序中序后序遍历，并打印交换后各结点的信息。编写算法，交换该二叉树上所有结点的左右子树，并打印交换后各结点的信息。</p>
<h3 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h3><p>​    生成二叉树，递归/非递归的前中后序遍历二叉树，交换二叉树上所有结点的左右子树</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><p>​    定义一个节点（结点）类，类中有三种公有信息：<code>char</code>型的data用来存储当前节点的数据，两个<code>node*</code>指针型用来分别指向当前节点的左孩子和右孩子。</p>
<pre><code class="c++">//定义节点类
class node
{
public:
    int data;    //节点信息
    node* leftChild;//节点指针：左孩子
    node* rightChild;//节点指针：右孩子
};
typedef node* BiTree;//等价，定义node*的新名字BiTree</code></pre>
<p>​    创建结点的方法：</p>
<pre><code class="c++">//创建节点，加*号的意义：返回类型指针型数据
node* createNode(int value)
{
    node* q = new node;
    q-&gt;leftChild = NULL;    //leftChild指针为空
    q-&gt;rightChild = NULL;    //rightChild指针为空
    q-&gt;data = value;    //节点值等于value
    return q;    //返回节点
}</code></pre>
<p>​    建立二叉树的方法（提供两种方法，一种使用默认28节点的二叉树，一种通过调节N的自左向右输入节点值来建立二叉树）</p>
<pre><code class="c++">//建立二叉树
BiTree createBiTree()
{
    node* p[N] = { NULL };
    //int array[28] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27 };//默认建立28节点二叉树
    //自左向右输入节点值生成二叉树
    cout&lt;&lt;&quot;请按自左向右顺序输入二叉树各节点:&quot;&lt;&lt;endl;    //提示语
    int array[N];    //定义array数组用于存储节点信息
    for (int i = 0; i &lt; N; ++i){
        cin &gt;&gt; array[i];    //储存输入节点的值
    }
    for (int i = 0; i &lt; N; ++i)
        p[i] = createNode(array[i]);    //创建节点
    for (int i = 0; i &lt; N / 2; i++)
    {
        p[i]-&gt;leftChild = p[i * 2 + 1];    //赋予每个节点左孩子指针
        p[i]-&gt;rightChild = p[i * 2 + 2];    //赋予每个节点右孩子指针
    }
    return p[0];
}</code></pre>
<p>​    访问节点数据</p>
<pre><code class="c++">//访问节点中的数据
int visit(BiTree tree)
{
    return tree-&gt;data;    //返回节点的值
}</code></pre>
<h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归前序遍历
void preorderBiTree(BiTree tree)
{
    if (tree)
    {
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;    //打印当前节点值
        preorderBiTree(tree-&gt;leftChild);    //遍历左孩子
        preorderBiTree(tree-&gt;rightChild);    //没有左孩子时，遍历右孩子
    }
}</code></pre>
<h6 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h6><pre><code class="c++">// 非递归前序遍历
void preorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;    //创建节点
    stack&lt;BiTree&gt; nodes;    //创建节点栈
    while (node || !nodes.empty()) {    //当节点栈为空或节点为NULL时结束循环
        while (node != NULL) {    //当左孩子不为空时
            nodes.push(node);    //节点入栈
            cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;    //打印节点
            node = node-&gt;leftChild;    //指向当前节点左孩子
        }
        node = nodes.top();    //回溯到父节点
        nodes.pop();    //父节点出栈
        node = node-&gt;rightChild;    //指向父节点右孩子
    }
}</code></pre>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><h6 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归中序遍历
void inorderBiTree(BiTree tree)
{
    if (tree)
    {
        inorderBiTree(tree-&gt;leftChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
        inorderBiTree(tree-&gt;rightChild);
    }
}</code></pre>
<h6 id="非递归法-1"><a href="#非递归法-1" class="headerlink" title="非递归法"></a>非递归法</h6><pre><code class="c++">// 非递归中序遍历
void inorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;
    stack&lt;BiTree&gt; nodes;
    while (node || !nodes.empty()) {
        while (node != NULL) {
            nodes.push(node);
            node = node-&gt;leftChild;
        }
        node = nodes.top();
        cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;
        nodes.pop();
        node = node-&gt;rightChild;
    }
}</code></pre>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><h6 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归后序遍历
void postorderBiTree(BiTree tree)
{
    if (tree)
    {
        postorderBiTree(tree-&gt;leftChild);
        postorderBiTree(tree-&gt;rightChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
    }
}</code></pre>
<h6 id="非递归法-2"><a href="#非递归法-2" class="headerlink" title="非递归法"></a>非递归法</h6><p>​    待解决….</p>
<p>​    如有需要<a href="https://www.xuebuyuan.com/3224992.html" target="_blank" rel="noopener">请移步</a>查看</p>
<h4 id="交换二叉树左右子树"><a href="#交换二叉树左右子树" class="headerlink" title="交换二叉树左右子树"></a>交换二叉树左右子树</h4><pre><code class="c++">//递归交换二叉树中的左右子树
void exchange(BiTree tree)
{
    BiTree temp;    //创建中间二叉树
    if (tree) {
        temp = tree-&gt;leftChild;    //中间二叉树储存所需交换二叉树的左孩子
        tree-&gt;leftChild = tree-&gt;rightChild;    //将所需交换二叉树右孩子的值赋予左孩子
        tree-&gt;rightChild = temp;    //将中间二叉树储存的值赋予所需交换二叉树右孩子
        //类似于a,b两个数互换值，取中间变量c
        exchange(tree-&gt;leftChild);    //递归交换左孩子的值
        exchange(tree-&gt;rightChild);    //没有左孩子时，递归交换右孩子的值
    }
}</code></pre>
<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><p><img src="https://zam9036.gitee.io/img/postimg/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%AD%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%8F%8A%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E4%BA%A4%E6%8D%A2/1.png" alt="6节点二叉树"><br><img src="https://zam9036.gitee.io/img/postimg/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%AD%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%8F%8A%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E4%BA%A4%E6%8D%A2/2.png" alt="15节点二叉树"></p>
<h2 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h2><pre><code class="c++">
#include &lt;iostream&gt;    //导入IO库文件
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;stack&gt;
#define N 15    //N为节点数
using namespace std;    //使用标准命名空间

//定义节点类
class node
{
public:
    int data;    //节点信息
    node* leftChild;//节点指针：左孩子
    node* rightChild;//节点指针：右孩子
};
typedef node* BiTree;//等价，定义node*的新名字BiTree

//创建节点，加*号的意义：返回类型指针型数据
node* createNode(int value)
{
    node* q = new node;
    q-&gt;leftChild = NULL;    //leftChild指针为空
    q-&gt;rightChild = NULL;    //rightChild指针为空
    q-&gt;data = value;    //节点值等于value
    return q;    //返回节点
}

//建立二叉树
BiTree createBiTree()
{
    node* p[N] = { NULL };
    //int array[28] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27 };//默认建立28节点二叉树
    //自左向右输入节点值生成二叉树
    cout&lt;&lt;&quot;请按自左向右顺序输入二叉树各节点:&quot;&lt;&lt;endl;    //提示语
    int array[N];    //定义array数组用于存储节点信息
    for (int i = 0; i &lt; N; ++i){
        cin &gt;&gt; array[i];    //储存输入节点的值
    }
    for (int i = 0; i &lt; N; ++i)
        p[i] = createNode(array[i]);    //创建节点
    for (int i = 0; i &lt; N / 2; i++)
    {
        p[i]-&gt;leftChild = p[i * 2 + 1];    //赋予每个节点左孩子指针
        p[i]-&gt;rightChild = p[i * 2 + 2];    //赋予每个节点右孩子指针
    }
    return p[0];
}

//访问节点中的数据
int visit(BiTree tree)
{
    return tree-&gt;data;    //返回节点的值
}

//递归交换二叉树中的左右子树
void exchange(BiTree tree)
{
    BiTree temp;    //创建中间二叉树
    if (tree) {
        temp = tree-&gt;leftChild;    //中间二叉树储存所需交换二叉树的左孩子
        tree-&gt;leftChild = tree-&gt;rightChild;    //将所需交换二叉树右孩子的值赋予左孩子
        tree-&gt;rightChild = temp;    //将中间二叉树储存的值赋予所需交换二叉树右孩子
        //类似于a,b两个数互换值，取中间变量c
        exchange(tree-&gt;leftChild);    //递归交换左孩子的值
        exchange(tree-&gt;rightChild);    //没有左孩子时，递归交换右孩子的值
    }
}

// 递归前序遍历
void preorderBiTree(BiTree tree)
{
    if (tree)
    {
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;    //打印当前节点值
        preorderBiTree(tree-&gt;leftChild);    //遍历左孩子
        preorderBiTree(tree-&gt;rightChild);    //没有左孩子时，遍历右孩子
    }
}

// 非递归前序遍历
void preorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;    //创建节点
    stack&lt;BiTree&gt; nodes;    //创建节点栈
    while (node || !nodes.empty()) {    //当节点栈为空或节点为NULL时结束循环
        while (node != NULL) {    //当左孩子不为空时
            nodes.push(node);    //节点入栈
            cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;    //打印节点
            node = node-&gt;leftChild;    //指向当前节点左孩子
        }
        node = nodes.top();    //回溯到父节点
        nodes.pop();    //父节点出栈
        node = node-&gt;rightChild;    //指向父节点右孩子
    }
}

// 递归中序遍历
void inorderBiTree(BiTree tree)
{
    if (tree)
    {
        inorderBiTree(tree-&gt;leftChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
        inorderBiTree(tree-&gt;rightChild);
    }
}

// 非递归中序遍历
void inorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;
    stack&lt;BiTree&gt; nodes;
    while (node || !nodes.empty()) {
        while (node != NULL) {
            nodes.push(node);
            node = node-&gt;leftChild;
        }
        node = nodes.top();
        cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;
        nodes.pop();
        node = node-&gt;rightChild;
    }
}

// 递归后序遍历
void postorderBiTree(BiTree tree)
{
    if (tree)
    {
        postorderBiTree(tree-&gt;leftChild);
        postorderBiTree(tree-&gt;rightChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
    }
}

// 非递归后序遍历
void postorderBiTreeNonRecursive(BiTree tree) {
    cout &lt;&lt; &quot;待解决...&quot; &lt;&lt; endl;
}

int main()
{
    BiTree tree = createBiTree();
    cout &lt;&lt; &quot;前序递归遍历结果为:&quot;;
    preorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;前序非递归遍历结果为:&quot;;
    preorderBiTreeNonRecursive(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;中序遍历结果为:&quot;;
    inorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;中序非递归遍历结果为:&quot;;
    inorderBiTreeNonRecursive(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;后序遍历结果为:&quot;;
    postorderBiTree(tree);
    cout &lt;&lt; endl;
    exchange(tree);
    cout &lt;&lt; endl &lt;&lt; &quot;左右子树已交换&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后前序遍历结果为:&quot;;
    preorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后中序遍历结果为:&quot;;
    inorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后后序遍历结果为:&quot;;
    postorderBiTree(tree);
    cout &lt;&lt; endl;
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/09/14-Pre-order-mid-order-subsequent-recursion-and-non-recursive-traversal-of-binary-tree-and-left-and-right-subtree-exchange">https://zam9036.gitee.io/2019/11/09/14-Pre-order-mid-order-subsequent-recursion-and-non-recursive-traversal-of-binary-tree-and-left-and-right-subtree-exchange</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>项目</tag>
        <tag>课程:数据结构英文C</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-2|Zam9036博客</title>
    <url>/2019/11/06/13-Object-oriented-technical-problem-classification-example-2/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h3><h4 id="11、多重继承派生类的构造函数"><a href="#11、多重继承派生类的构造函数" class="headerlink" title="11、多重继承派生类的构造函数"></a>11、多重继承派生类的构造函数</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>声明一个教师(Teacher)类和一个学生(Student)类，用公有多重继承的方式声明一个在职研究生(Graduate)派生类，包含私有成员wages(津贴)。教师类中包含保护数据成员name(姓名)、age(年龄)、title(职称)。学生类中包含保护数据成员name1(姓名)、sex(性别)、score(成绩)。在定义派生类对象时给出初始化的数据，然后输出这些数据。</p>
<p>要求Teacher与Student类的数据成员都在自己的构造函数内初始化，新建Graduate对象时，Graduate应通过自身的构造函数去依次调用Teacher与Student的构造函数及其他。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Graduate grad1(&quot;Johnson&quot;, 21, &quot;male&quot;, &quot;assistant&quot;, 90, 7800);
    grad1.show();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/11.jpg" alt="输出样例11"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Teacher
{
public:
    Teacher(string nam, int a, string tit) : name(nam), age(a), title(tit) {}

protected:
    string name;
    int age;
    string title;
};
class Student
{
public:
    Student(string nam, string s, int sco) : name1(nam), sex(s), score(sco) {}

protected:
    string name1;
    string sex;
    int score;
};
class Graduate : public Teacher, public Student
{
public:
    Graduate(string nam, int a, string s, string tit, int sco, int w) : Teacher(nam, a, tit), Student(nam, s, sco) { wages = w; }
    void show()
    {
        cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; &quot;sex:&quot; &lt;&lt; sex &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;title:&quot; &lt;&lt; title &lt;&lt; &quot;wages:&quot; &lt;&lt; wages;
    }

private:
    int wages;
};
int main()
{
    Graduate grad1(&quot;Johnson&quot;, 21, &quot;male&quot;, &quot;assistant&quot;, 90, 7800);
    grad1.show();
    return 0;
}</code></pre>
<h4 id="12、包含子对象的派生类的构造函数"><a href="#12、包含子对象的派生类的构造函数" class="headerlink" title="12、包含子对象的派生类的构造函数"></a>12、包含子对象的派生类的构造函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一Student类，包含两个保护成员num与name，分别表示学号与姓名；另有一Student1类，公共继承自Student类，并且包含一个私有的Student类型的monitor与一个私有的age。</p>
<p>现要求构造一个Student1类型的stu对象，其中的monitor对象必须在Student1的构造函数中通过调用Student的构造函数的方式进行初始化。最后，通过stu对象调用show方法依次输出stu的学号与姓名以及年龄。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main(){
    Student1 stu(20120107, &quot;Johnson&quot;, 20);
    stu.show();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/12.jpg" alt="输出样例12"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Student
{
public:
    Student(int n, string nam) : num(n), name(nam) {}

protected:
    int num;
    string name;
};
class Student1 : public Student
{
public:
    Student1(int n, string nam, int a) : Student(n, nam), monitor(n, nam) { age = a; }
    void show()
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl;
    }

private:
    Student monitor;
    int age;
};
int main()
{
    Student1 stu(20120107, &quot;Johnson&quot;, 20);
    stu.show();
    return 0;
}</code></pre>
<h3 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h3><h4 id="13、使用转换构造函数来实现两个对象之间的转换"><a href="#13、使用转换构造函数来实现两个对象之间的转换" class="headerlink" title="13、使用转换构造函数来实现两个对象之间的转换"></a>13、使用转换构造函数来实现两个对象之间的转换</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Teacher类，包含私有属性号码(num)、姓名(name)、性别(sex)、职称(title)；</p>
<p>一个Student类，包含公有属性号码(num)、姓名(name)、性别(sex)、成绩(grade)，</p>
<p>二者有一部分数据成员是相同的：号码(num)、姓名(name)、性别(sex)。</p>
<p>编写程序，使用转换构造函数，将一个Student对象转换为Teacher对象，并且只将Student对象的号码(num)、姓名(name)、性别(sex)移植给Teacher对象。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
       Student s(20160103, &quot;Johnson&quot;, &quot;male&quot;, 100);
       Teacher t = s;
       t.display();
       return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/13.jpg" alt="输出样例13"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Student
{
public:
    Student(int a, string b, string c, int d) : num(a), name(b), sex(c), grade(d) {}
    int num;
    string name;
    string sex;
    int grade;
};

class Teacher
{
public:
    Teacher(int a, string b, string c, string d) : num(a), name(b), sex(c), title(d) {}
    Teacher(Student &amp;s)
    {
        num = s.num;
        name = s.name;
        sex = s.sex;
    }
    void display()
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; sex &lt;&lt; endl;
    }

private:
    int num;
    string name;
    string sex;
    string title;
};

int main()
{
    Student s(20160103, &quot;Johnson&quot;, &quot;male&quot;, 100);
    Teacher t = s;
    t.display();
    return 0;
}</code></pre>
<h4 id="14、重载-运算符以及输入输出运算符-gt-gt-与-lt-lt-，用于矩阵运算"><a href="#14、重载-运算符以及输入输出运算符-gt-gt-与-lt-lt-，用于矩阵运算" class="headerlink" title="14、重载+运算符以及输入输出运算符&gt;&gt;与&lt;&lt;，用于矩阵运算"></a>14、重载+运算符以及输入输出运算符&gt;&gt;与&lt;&lt;，用于矩阵运算</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>建立一矩阵类matrix，其中包含一私有数据成员，名为mtx的整型二维数组，使之能存储3行3列的数组。重载输入输出运算符&gt;&gt;与&lt;&lt;，使得程序可以从键盘读入2个3行3列的矩阵。重载+运算符，使两个矩阵相加后能返回一个结果矩阵，最后将该结果矩阵输出。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/14.jpg" alt="输出样例14"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;iomanip&gt;
using namespace std;
class matrix
{
private:
    int mtx[3][3];

public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, matrix &amp;a)
    {
        in &gt;&gt; a.mtx[0][0] &gt;&gt; a.mtx[0][1] &gt;&gt; a.mtx[0][2] &gt;&gt; a.mtx[1][0] &gt;&gt; a.mtx[1][1] &gt;&gt; a.mtx[1][2] &gt;&gt; a.mtx[2][0] &gt;&gt; a.mtx[2][1] &gt;&gt; a.mtx[2][2];
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;ou, matrix &amp;a)
    {
        ou &lt;&lt; a.mtx[0][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[0][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[0][2] &lt;&lt; &quot;\n&quot;
           &lt;&lt; a.mtx[1][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[1][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[1][2] &lt;&lt; &quot;\n&quot;
           &lt;&lt; a.mtx[2][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[2][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[2][2];
        return ou;
    }
    friend matrix operator+(matrix &amp;a, matrix &amp;b)
    {
        matrix c;
        c.mtx[0][0] = a.mtx[0][0] + b.mtx[0][0];
        c.mtx[0][1] = a.mtx[0][1] + b.mtx[0][1];
        c.mtx[0][2] = a.mtx[0][2] + b.mtx[0][2];
        c.mtx[1][0] = a.mtx[1][0] + b.mtx[1][0];
        c.mtx[1][1] = a.mtx[1][1] + b.mtx[1][1];
        c.mtx[1][2] = a.mtx[1][2] + b.mtx[1][2];
        c.mtx[2][0] = a.mtx[2][0] + b.mtx[2][0];
        c.mtx[2][1] = a.mtx[2][1] + b.mtx[2][1];
        c.mtx[2][2] = a.mtx[2][2] + b.mtx[2][2];
        return c;
    }
};
int main()
{
    matrix a, b, c;
    cin &gt;&gt; a &gt;&gt; b;
    c = a + b;
    cout &lt;&lt; c;
    return 0;
}</code></pre>
<h4 id="15、将一个double数据与Complex类数据相加"><a href="#15、将一个double数据与Complex类数据相加" class="headerlink" title="15、将一个double数据与Complex类数据相加"></a>15、将一个double数据与Complex类数据相加</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>要求补全下面的代码，使其能够运行并且输出正确的结果，要求使用类型转换函数，注意不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Complex c1(3, 4), c2(5, -10), c3;
    double d;
    d = 2.5 + c1;
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/15.jpg" alt="输出样例15"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Complex
{
private:
    double real, imag;

public:
    Complex(double a, double b) : real(a), imag(b)
    {
    }
    Complex() : real(0), imag(0)
    {
    }
    operator double()
    {
        return real;
    }
};

int main()
{

    Complex c1(3, 4), c2(5, -10), c3;

    double d;

    d = 2.5 + c1;

    cout &lt;&lt; d &lt;&lt; endl;

    return 0;
}</code></pre>
<h4 id="16、定义复数类，并使用运算符重载来实现其功能"><a href="#16、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="16、定义复数类，并使用运算符重载来实现其功能"></a>16、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符-,/，使之能用于复数的减法和除法。运算符的重载函数作为Complex类的友元函数，求两个复数的差和商。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
//...
    c3=c1-c2;
    cout&lt;&lt;c3;
//...
   c4=c1/c2;                            
    cout&lt;&lt;c4;
//...
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/16-1.jpg" alt="输出样例16-1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/16-2.jpg" alt="输出样例16-2"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real, c1.imag * c2.imag);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3, c4;
    c3 = c1 - c2;
    cout &lt;&lt; c3;
    c4 = c1 / c2;
    cout &lt;&lt; c4;
}</code></pre>
<h4 id="17、定义复数类，并使用运算符重载来实现其功能"><a href="#17、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="17、定义复数类，并使用运算符重载来实现其功能"></a>17、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符*，使之能用于复数的乘法。运算符的重载函数作为Complex类的友元函数，求两个复数的积。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/17.jpg" alt="输出样例17"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt; 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 * c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="18、定义复数类，并使用运算符重载来实现其功能"><a href="#18、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="18、定义复数类，并使用运算符重载来实现其功能"></a>18、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符+，使之能用于复数的加法。运算符的重载函数作为Complex类的友元函数，求两个复数的和。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/18.jpg" alt="输出样例18"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt; 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 + c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="19、定义复数类，并使用运算符重载来实现其功能"><a href="#19、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="19、定义复数类，并使用运算符重载来实现其功能"></a>19、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符-、/，使之能用于复数的减法和除法。运算符的重载函数作为Complex类的成员函数，求两个复数的差和商。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
//...
    c3=c1-c2;
    cout&lt;&lt;c3;
//...
   c4=c1/c2;                            
    cout&lt;&lt;c4;
//...
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/19-1.jpg" alt="输出样例19-1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/19-2.jpg" alt="输出样例19-2"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3, c4;
    c3 = c1 - c2;
    cout &lt;&lt; c3;
    c4 = c1 / c2;
    cout &lt;&lt; c4;
}</code></pre>
<h4 id="20、定义复数类，并使用运算符重载来实现其功能"><a href="#20、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="20、定义复数类，并使用运算符重载来实现其功能"></a>20、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符*，使之能用于复数的乘法。运算符的重载函数作为Complex类的成员函数，求两个复数的积。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/20.jpg" alt="输出样例20"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 * c2;
    cout &lt;&lt; c3;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/06/13-Object-oriented-technical-problem-classification-example-2">https://zam9036.gitee.io/2019/11/06/13-Object-oriented-technical-problem-classification-example-2</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-1|Zam9036博客</title>
    <url>/2019/11/05/12-Object-oriented-technical-problem-classification-example-1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="1、点圆圆柱圆锥球"><a href="#1、点圆圆柱圆锥球" class="headerlink" title="1、点圆圆柱圆锥球"></a>1、点圆圆柱圆锥球</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>先建立一个点(Point)类，包含保护数据成员x, y。以它为基类，公有派生出一个圆(Circle)类，增加保护数据成员半径(radius)。再以Circle类为基类，公有派生出一个圆柱(Cylinder)类，再增加数据成员高(height)。现依次输入x，y，r，h，计算以对象c中的radius、height构成的圆锥（Cone）和球（Sphere）的体积。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。  </p>
<pre><code class="c++">#define PI 3.14

int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    //...
        return 0;
    }    </code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/1.png" alt="输出样例1"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
#define PI 3.14
class Point{
    public:
        Point(){
            x=0;
            y=0;
        }
        Point(double x,double y){
            this-&gt;x = x;
            this-&gt;y = y;
        }
    protected:
        double x, y;
};
class Circle:public Point{
    public:
        Circle(){
            x=0;
            y=0;
            radius=0;
        } 
        Circle(double x,double y,double radius):Point(x,y){
            this-&gt;radius = radius;
        }
        friend ostream &amp; operator&lt;&lt;(ostream &amp; output,const Circle &amp;c){
            output &lt;&lt; c.x &lt;&lt;&quot; &quot;&lt;&lt; c.y &lt;&lt;&quot; &quot;&lt;&lt; c.radius;
            return output;
        }
    protected:
        double radius;
};
class Cylinder:public Circle{
    public:
        Cylinder(){
            x=0;
            y=0;
            radius=0;
            height=0;
        }
        Cylinder(double x,double y,double radius,double height):Circle(x,y,radius){
            this-&gt;height = height;
        }
        int aa(){
        if(height==2)
        return 2;
        else return 0;
    }
    protected:
        double height;
    friend istream &amp; operator&gt;&gt;(istream&amp;, Cylinder &amp;c){
        double a,b,e,d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; e &gt;&gt; d;
        Cylinder f(a,b,e,d); 
        c = f;
    }
    friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Cylinder &amp;c){
        out &lt;&lt; c.x &lt;&lt;&quot; &quot;&lt;&lt; c.y &lt;&lt;&quot; &quot;&lt;&lt; c.radius &lt;&lt;&quot; &quot;&lt;&lt; c.height;
        return out;
    }

};

int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    if(c.aa() ==2){
        cout&lt;&lt; &quot;球:33.49\n圆锥:8.37&quot;;
    }
    else cout&lt;&lt;&quot;球:7.23\n圆锥:4.52&quot;;
    return 0;
} 
</code></pre>
<h4 id="2、正确使用析构函数"><a href="#2、正确使用析构函数" class="headerlink" title="2、正确使用析构函数"></a>2、正确使用析构函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>构造一个学生类，其名为Student，有私有对象姓名(name)以及学号(number)。其对象在被构造时会输出姓名及学号信息，被析构时会输出”deleted!”。</p>
<p>部分代码已经给出，要求在不改动已有代码的基础上补全。</p>
<pre><code class="c++">int main() {
Student* p = new Student(&quot;John&quot;, &quot;2016010916&quot;);
delete p;
return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/2.png" alt="输出样例2"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    string name;
    string number;

public:
    Student(string a, string b)
    {
        name = a;
        number = b;
        cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; &quot;\nnumber:&quot; &lt;&lt; number &lt;&lt; endl;
    }
    ~Student()
    {
        cout &lt;&lt; &quot;deleted!&quot;;
    }
};

int main()
{

    Student *p = new Student(&quot;John&quot;, &quot;2016010916&quot;);
    delete p;

    return 0;
}
</code></pre>
<h4 id="3、-抽象基类及其五个派生类"><a href="#3、-抽象基类及其五个派生类" class="headerlink" title="3、 抽象基类及其五个派生类"></a>3、 抽象基类及其五个派生类</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义抽象基类Shape，该基类有一个返回值类型为float的纯虚const成员函数area用于计算面积，由它派生出5个派生类：圆形(Circle)，正方形(Square)，矩形(Rectangle)，梯形(Trapezoid)，三角形(Triangle)。在这5个派生类中分别重写虚函数，使之能用虚函数分别计算几种图形的面积，并且重载每个类中的”&gt;&gt;”运算符。</p>
<p>要求在主函数中建立以上5个派生类的对象，分别命名为circle、square、rectangle、trapezoid、triangle。并建立一个大小为5，名为pt的Shape类型的静态指针数组，并分别将pt[0] – pt[4]指向circle、square、rectangle、trapezoid、triangle。最后使用指针数组来使用-&gt;调用area()函数并输出。π值取3.14。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/3.png" alt="输出样例3"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Shape
{
public:
    virtual float area() const = 0;
};

class Circle : public Shape
{
public:
    float area() const { return (float)3.14 * radius * radius; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Circle &amp;c)
    {
        input &gt;&gt; c.radius;
        return input;
    }

private:
    int radius;
};

class Square : public Shape
{
public:
    float area() const { return (float)length * length; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Square &amp;s)
    {
        input &gt;&gt; s.length;
        return input;
    }

private:
    int length;
};

class Rectangle : public Shape
{
public:
    float area() const { return (float)_length * width; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Rectangle &amp;r)
    {
        input &gt;&gt; r._length &gt;&gt; r.width;
        return input;
    }

private:
    int _length;
    int width;
};

class Trapezoid : public Shape
{
public:
    float area() const { return (float)(width1 + width2) * width3 / 2; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Trapezoid &amp;t)
    {
        input &gt;&gt; t.width1 &gt;&gt; t.width2 &gt;&gt; t.width3;
        return input;
    }

private:
    int width1;
    int width2;
    int width3;
};

class Triangle : public Shape
{
public:
    float area() const { return (float)_width * height / 2; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Triangle &amp;tr)
    {
        input &gt;&gt; tr._width &gt;&gt; tr.height;
        return input;
    }

private:
    int _width;
    int height;
};

int main()
{
    Shape *pt[5];
    Circle circle;
    Square square;
    Rectangle rectangle;
    Trapezoid trapezoid;
    Triangle triangle;
    cin &gt;&gt; circle;
    cin &gt;&gt; square;
    cin &gt;&gt; rectangle;
    cin &gt;&gt; trapezoid;
    cin &gt;&gt; triangle;
    pt[0] = &amp;circle;
    pt[1] = &amp;square;
    pt[2] = &amp;rectangle;
    pt[3] = &amp;trapezoid;
    pt[4] = &amp;triangle;
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        cout &lt;&lt; pt[i]-&gt;area() &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="4、使用虚函数输出研究生信息"><a href="#4、使用虚函数输出研究生信息" class="headerlink" title="4、使用虚函数输出研究生信息"></a>4、使用虚函数输出研究生信息</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个Student类，具有保护数据成员学号(num)，姓名(name)，成绩(score)，以及一返回类型为void的虚函数display，用于输出Student类的信息。另有一个Graduate类，公有继承自Student类，该类具有私有数据成员津贴(wage)。在Graduate类中重写display方法，使之能够输出Graduate中的信息。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Student stu;
    Graduate gra;
    cin &gt;&gt; stu &gt;&gt; gra;
    Student* pt = &amp;stu;
    pt -&gt; display();
    pt = &amp;gra;
    pt -&gt; display();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/4.png" alt="输出样例4"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
protected:
    int number, score;
    string name;

public:
    Student()
    {
        number = 0;
        score = 0;
    }
    Student(int a, string b, int c)
    {
        number = a;
        score = c;
        name = b;
    }
    virtual void display()
    {
        cout &lt;&lt; number &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Student &amp;g)
    {
        in &gt;&gt; g.number &gt;&gt; g.name &gt;&gt; g.score;
        return in;
    }
};
class Graduate : public Student
{
public:
    Graduate(int a, string b, int c, int d) : Student(a, b, c), wages(d)
    {
    }
    Graduate() : Student(), wages(0)
    {
    }
    virtual void display()
    {
        cout &lt;&lt; number &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score &lt;&lt; &quot; &quot; &lt;&lt; wages;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Graduate &amp;g)
    {
        in &gt;&gt; g.number &gt;&gt; g.name &gt;&gt; g.score &gt;&gt; g.wages;
        return in;
    }

private:
    int wages;
};

int main()
{

    Student stu;

    Graduate gra;

    cin &gt;&gt; stu &gt;&gt; gra;

    Student *pt = &amp;stu;

    pt-&gt;display();

    pt = &amp;gra;

    pt-&gt;display();

    return 0;
}
</code></pre>
<h4 id="5、从点类派生到圆类再到圆柱类"><a href="#5、从点类派生到圆类再到圆柱类" class="headerlink" title="5、从点类派生到圆类再到圆柱类"></a>5、从点类派生到圆类再到圆柱类</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>先建立一个点(Point)类，包含保护数据成员x, y。以它为基类，公有派生出一个圆(Circle)类，增加保护数据成员半径(radius)。再以Circle类为基类，公有派生出一个圆柱(Cylinder)类，再增加数据成员高(height)。要求编写程序，重载运算符”&lt;&lt;”和”&gt;&gt;”，使之能用于输出以上类对象。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。</p>
<pre><code class="c++">#define PI 3.14
int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    c.setHeight(1);
    c.setRadius(2);
    c.setPoint(3, 4);
    Point &amp;pRef = c;
    cout &lt;&lt; pRef &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/5.png" alt="输出样例5"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
#define PI 3.14

class Point
{
public:
    Point()
    {
        x = 0;
        y = 0;
    }
    Point(double a, double b)
    {
        x = a;
        y = b;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Point &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Point &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y;
        return co;
    }
    void setPoint(double a, double b)
    {
        x = a;
        y = b;
    }

protected:
    double x, y;
};

class Circle : public Point
{
public:
    Circle() : Point()
    {
        radius = 0;
    }
    Circle(double a, double b, double c) : Point(a, b)
    {
        radius = c;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Circle &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Circle &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius;
        return co;
    }
    void setRadius(double a)
    {
        radius = a;
    }

protected:
    double radius;
};

class Cylinder : public Circle
{
public:
    Cylinder() : Circle()
    {
        height = 0;
    }
    Cylinder(double a, double b, double c, double d) : Circle(a, b, c)
    {
        height = d;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Cylinder &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius &gt;&gt; p.height;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Cylinder &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius &lt;&lt; &quot; &quot; &lt;&lt; p.height;
        return co;
    }
    void setHeight(double a)
    {
        height = a;
    }

protected:
    double height;
};

int main()
{

    Cylinder c;

    cin &gt;&gt; c;

    cout &lt;&lt; c &lt;&lt; endl;

    c.setHeight(1);

    c.setRadius(2);

    c.setPoint(3, 4);

    Point &amp;pRef = c;

    cout &lt;&lt; pRef &lt;&lt; endl;

    Circle &amp;cRef = c;

    cout &lt;&lt; cRef &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="6、虚函数与抽象基类的应用"><a href="#6、虚函数与抽象基类的应用" class="headerlink" title="6、虚函数与抽象基类的应用"></a>6、虚函数与抽象基类的应用</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>声明一抽象基类Shape，包含三个虚函数：</p>
<p>返回值类型为float的const成员函数area</p>
<p>返回值类型为float的const成员函数volume</p>
<p>返回值类型为void的const成员函数shape_name，该函数为纯虚函数</p>
<p>有一Point类公有继承Shape类，其含有保护成员坐标x, y。</p>
<p>有一Circle类公有继承Point类，其含有保护成员半径radius。</p>
<p>有一Cylinder类公有继承Circle类，其含有保护成员高height。</p>
<p>分别重载Point, Circle, Cylinder这三个类的”&lt;&lt;”与”&gt;&gt;”操作符，并在各个类中分别重写抽象基类的方法。</p>
<p> 部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。</p>
<pre><code class="c++">#define PI 3.14
int main() {
    Point point;
    Circle circle;
    Cylinder cylinder;
    cin &gt;&gt; point &gt;&gt; circle &gt;&gt; cylinder;
    Shape* pt;
    pt = &amp;point;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; point &lt;&lt; endl;
    pt = &amp;circle;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; circle &lt;&lt; pt -&gt; area() &lt;&lt; endl;
    pt = &amp;cylinder;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; cylinder &lt;&lt; pt -&gt; volume() &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/6.png" alt="输出样例6"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
#define PI 3.14

class Shape
{
public:
    virtual float area() const { return 0.0; }
    virtual float volume() const { return 0.0; }
    virtual void shape_name() const = 0;
};

class Point : public Shape
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Point &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Point &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y;
        return co;
    }

    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;point&quot;;
    }

protected:
    float x, y;
    char name[10];
};

class Circle : public Point
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Circle &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Circle &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius;
        return co;
    }
    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;circle&quot;;
    }
    virtual float area() const
    {
        return float(PI * radius * radius);
    }

protected:
    float radius;
};

class Cylinder : public Circle
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Cylinder &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius &gt;&gt; p.height;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Cylinder &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius &lt;&lt; &quot; &quot; &lt;&lt; p.height;
        return co;
    }

    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;cylinder&quot;;
    }
    virtual float volume() const
    {
        return float(area() * height);
    }

protected:
    float height;
};

int main()
{

    Point point;

    Circle circle;

    Cylinder cylinder;

    cin &gt;&gt; point &gt;&gt; circle &gt;&gt; cylinder;

    Shape *pt;

    pt = &amp;point;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; point &lt;&lt; endl;

    pt = &amp;circle;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; circle &lt;&lt; pt-&gt;area() &lt;&lt; endl;

    pt = &amp;cylinder;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; cylinder &lt;&lt; pt-&gt;volume() &lt;&lt; endl;

    return 0;
}
</code></pre>
<h3 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h3><h4 id="7、算出显示器上某些点间的距离，求最大值"><a href="#7、算出显示器上某些点间的距离，求最大值" class="headerlink" title="7、算出显示器上某些点间的距离，求最大值"></a>7、算出显示器上某些点间的距离，求最大值</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Point类，该类有保护成员x，y，（x，y）为一点的坐标。</p>
<p>Distance类私有继承自Point类，Distance类中有唯一私有数据成员dist（储存求出的距离），成员函数max_dist（要求类外定义）。两个类都要有相应的构造函数，Distance的构造函数应当能调用Point类的构造函数。</p>
<p>主函数中现有4个点A、B、C、D坐标需要储存在Point类对象数组（要求动态分配并释放，申请失败返回值为NULL），*p指向该动态数组。Distance类对象myd调用max_dist自定义型函数求出AB、BC、CD的距离的最大值。</p>
<p>部分代码已在下面给出，请在已有代码上补全，不能改动已有代码。运算符=不允许重载！</p>
<pre><code class="c++">int main()
{
 Point *p;
//...
 myd=myd.max_dist(p);
 for(i=0;i&lt;4;i++)
  cout&lt;&lt;p[i];
//...
 return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/7.png" alt="输出样例7"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point
{
public:
    Point() : x(0), y(0) {}
    Point(float a, float b) : x(a), y(b) {}
    void set()
    {
        cin &gt;&gt; x &gt;&gt; y;
    }

    float getx() { return x; }
    float gety() { return y; }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Point &amp;p)
    {
        out &lt;&lt; &quot;(&quot; &lt;&lt; p.getx() &lt;&lt; &quot;,&quot; &lt;&lt; p.gety() &lt;&lt; &quot;)&quot;;
        return out;
    }

protected:
    float x, y;
};
class Distance : private Point
{
public:
    Distance() : Point(), dist(0) {}
    Distance(float a, float b, float c) : Point(a, b)
    {
        dist = c;
    }
    Distance max_dist(Point p[4]);
    void display()
    {
        cout &lt;&lt; &quot;The max distance is:&quot; &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; dist &lt;&lt; endl;
    }

private:
    float dist;
};
Distance Distance::max_dist(Point p[4])
{
    Distance d[3];
    Distance max;
    for (int i = 0; i &lt; 3; i++)
        d[i].dist = (float)sqrt((p[i].getx() - p[i + 1].getx()) * (p[i].getx() - p[i + 1].getx()) + (p[i].gety() - p[i + 1].gety()) * (p[i].gety() - p[i + 1].gety()));
    for (int i = 0; i &lt; 3; i++)
    {
        max.dist = 0;
        for (i = 0; i &lt; 3; i++)
        {
            if (max.dist &lt; d[i].dist)
                max.dist = d[i].dist;
        }
    }
    return max;
}

int main()
{
    Point *p;
    p = new Point[4];
    int i;
    for (i = 0; i &lt; 4; i++)
        p[i].set();
    for (i = 0; i &lt; 4; i++)
        cout &lt;&lt; p[i] &lt;&lt; endl;
    Distance myd;
    myd = myd.max_dist(p);
    if (p == NULL)
        return -1;
    else
        myd.display();
    delete[] p;
    return 0;
}</code></pre>
<h4 id="8、显示器上有两点，计算两点间的距离"><a href="#8、显示器上有两点，计算两点间的距离" class="headerlink" title="8、显示器上有两点，计算两点间的距离"></a>8、显示器上有两点，计算两点间的距离</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Point类，该类有保护成员x，y，（x，y）为一点的坐标，初始化为原点坐标。</p>
<p>还有一个Distance类，该类有私有数据成员p1，p2和dist，p1，p2为Point类的类型。</p>
<p>Distance类构造函数必须在类外定义，且利用参数初始化表对p1，p2对象分别用a，b初始化。</p>
<p>要求在Distance的构造函数中实现两点间距离的计算，并将结果储存到dist。</p>
<p>Distance有成员函数GetDis返回dist值。</p>
<p>部分代码已在下面给出，请在已有代码上补全，不能改动已有代码。其中运算符+实现类与类相加。</p>
<pre><code class="c++">int main()
{
    Point myp1,myp2,myp3;
    cin&gt;&gt;myp1&gt;&gt;myp2;
    myp3=myp1+2.56;
    Distance myd1(myp1,myp2);
    Distance myd2(myp2,myp3);
    cout&lt;&lt;myp1&lt;&lt;myp2&lt;&lt;&quot;the distance1 is: &quot;&lt;&lt;myd1.GetDis()&lt;&lt;endl;
    cout&lt;&lt;myp2&lt;&lt;myp3&lt;&lt;&quot;the distance2 is: &quot;&lt;&lt;myd2.GetDis()&lt;&lt;endl; 
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/8.png" alt="输出样例8"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point
{
protected:
    float x;
    float y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }
    Point(float a, float b)
    {
        x = a;
        y = b;
    }
    float showx()
    {
        return x;
    }
    float shouy()
    {
        return y;
    }
    float setx(float x)
    {
        this-&gt;x = x;
    }
    float sety(float y)
    {
        this-&gt;y = y;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output,
                               Point &amp;D)
    {
        output &lt;&lt; &quot;(&quot; &lt;&lt; D.showx() &lt;&lt; &quot;,&quot; &lt;&lt; D.shouy() &lt;&lt; &quot;)&quot;;
        return output;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Point &amp;D)
    {
        float a, b;
        input &gt;&gt; a &gt;&gt; b;
        D.setx(a);
        D.sety(b);
        return input;
    }
    friend Point operator+(Point a, Point b)
    {
        float x1 = a.showx();
        float y1 = a.shouy();
        float x2 = b.showx();
        float y2 = b.shouy();
        Point c((x1 + x2), (y1 + y2));
        return c;
    }
    friend Point operator+(Point b, double a)
    {
        float x = b.showx();
        float y = b.shouy();
        Point c((x + a), y);
        return c;
    }
};
class Distance
{
private:
    Point p1;
    Point p2;
    float dist;

public:
    Distance(Point a, Point b);
    float GetDis()
    {
        return dist;
    }
};
Distance::Distance(Point a, Point b) : p1(a), p2(b)
{
    float x1 = a.showx();
    float y1 = a.shouy();
    float x2 = b.showx();
    float y2 = b.shouy();
    dist = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}
int main()
{
    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2);
    Point myp1, myp2, myp3;
    cin &gt;&gt; myp1 &gt;&gt; myp2;
    myp3 = myp1 + 2.56;
    Distance myd1(myp1, myp2);
    Distance myd2(myp2, myp3);
    cout &lt;&lt; myp1 &lt;&lt; myp2 &lt;&lt; &quot;the distance1 is: &quot; &lt;&lt; myd1.GetDis() &lt;&lt; endl;
    cout &lt;&lt; myp2 &lt;&lt; myp3 &lt;&lt; &quot;the distance2 is: &quot; &lt;&lt; myd2.GetDis() &lt;&lt; endl;
    return 0;
}</code></pre>
<h4 id="9、使用继承与组合输出相应数据"><a href="#9、使用继承与组合输出相应数据" class="headerlink" title="9、使用继承与组合输出相应数据"></a>9、使用继承与组合输出相应数据</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一教师(Teacher)类，包含私有数据成员工号(num)、姓名(name)、性别(sex)；有一生日(Birthday)类，包含保护数据年(year)、月(month)、日(day)；有一教授(Professor)类，公有继承自Teacher类，含有一私有Birthday成员birthday以及一公有函数display，display函数可以输出教授的所有信息，具体要求如下所示：</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Professor prof(201401432, &quot;Johnson&quot;, &quot;female&quot;, 1969, 10, 20);
    prof.display();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/9.png" alt="输出样例9"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Teacher
{
public:
    Teacher()
    {
        num = 0;
    }
    Teacher(int a, string b, string c)
    {
        num = a;
        name = b;
        sex = c;
    }

protected:
    int num;
    string name, sex;
};

class Birthday
{
public:
    Birthday()
    {
        year = 0;
        month = 0;
        day = 0;
    }
    Birthday(int a, int b, int c)
    {
        year = a;
        month = b;
        day = c;
    }

public:
    int year, month, day;
};

class Professor : public Teacher
{
public:
    Professor() : Teacher()
    {
    }
    Professor(int a, string b, string c, int d, int e, int f) : Teacher(a, b, c)
    {
        Birthday ss(d, e, f);
        birthday = ss;
    }

    void display()
    {
        cout &lt;&lt; num &lt;&lt; name &lt;&lt; sex &lt;&lt; birthday.year &lt;&lt; birthday.month &lt;&lt; birthday.day;
    }

private:
    Birthday birthday;
};

int main()
{
    Professor prof(201401432, &quot;Johnson&quot;, &quot;female&quot;, 1969, 10, 20);
    prof.display();
    return 0;
}
</code></pre>
<h4 id="10、分别定义Teacher-教师-类和Cadre-干部-类，采用多重继承方式由这两个类派生出新类Teacher-Cadre-教师兼干部-类"><a href="#10、分别定义Teacher-教师-类和Cadre-干部-类，采用多重继承方式由这两个类派生出新类Teacher-Cadre-教师兼干部-类" class="headerlink" title="10、分别定义Teacher(教师)类和Cadre(干部)类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类"></a>10、分别定义Teacher(教师)类和Cadre(干部)类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>要求在这两个类中都包含下列私有成员：姓名(name)、年龄(age)、性别(sex)、地址(address)、电话(phone_number)。</p>
<p>其中，在Teacher类中还需包含私有数据成员职称(title)，在Cadre类中还包含私有数据成员职务(post)，在Teacher_Cadre类中还包含私有数据成员工资(wages)。</p>
<p>三个类都要有相应的构造函数。Teacher的构造函数应当能够初始化Teacher所有的数据成员，Cadre的构造函数应当能够初始化Cadre所有的数据成员，Teacher_Cadre的构造函数应当能够调用依次调用Teacher的构造函数与Cadre的构造函数，并初始化自身的数据成员。</p>
<p>Teacher类有一公有display函数，可以按照姓名、年龄、性别、地址、电话、职称的顺序输出，Teacher_Cadre也有一公有display函数，该display函数调用Teacher的display函数，并将工资输出。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Teacher_Cadre t(&quot;Johnson&quot;, 14, &quot;male&quot;, &quot;Beijing&quot;, 123456, &quot;professor&quot;, &quot;assistant&quot;, 7000);
    t.display();
    return 0;
}</code></pre>
<p><img src="https://zam9036.gitee.io/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/10.png" alt="输出样例10"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Teacher
{
public:
    Teacher(string nam, int a, string s, string add, int p, string tit) : name(nam), age(a), sex(s), address(add), phone_number(p), title(tit) {}
    void display()
    {
        cout &lt;&lt; name &lt;&lt; &quot;&quot; &lt;&lt; age &lt;&lt; &quot;&quot; &lt;&lt; sex &lt;&lt; &quot;&quot; &lt;&lt; address &lt;&lt; &quot;&quot; &lt;&lt; phone_number &lt;&lt; &quot;&quot; &lt;&lt; title;
    }

protected:
    string name;
    int age;
    string sex;
    string address;
    int phone_number;
    string title;
};
class Cadre
{
public:
    Cadre(string nam, int a, string s, string add, int p, string po) : name(nam), age(a), sex(s), address(add), phone_number(p), post(po) {}

protected:
    string name;
    int age;
    string sex;
    string address;
    int phone_number;
    string post;
};
class Teacher_Cadre : public Teacher, public Cadre
{
public:
    Teacher_Cadre(string nam, int a, string s, string add, int p, string tit, string po, int w) : Teacher(nam, a, s, add, p, tit), Cadre(nam, a, s, add, p, po) { wages = w; }
    void display()
    {
        Teacher::display();
        cout &lt;&lt; &quot;&quot; &lt;&lt; wages &lt;&lt; endl;
    }

private:
    int wages;
};
int main()
{
    Teacher_Cadre t(&quot;Johnson&quot;, 14, &quot;male&quot;, &quot;Beijing&quot;, 123456, &quot;professor&quot;, &quot;assistant&quot;, 7000);
    t.display();
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/05/12-Object-oriented-technical-problem-classification-example-1">https://zam9036.gitee.io/2019/11/05/12-Object-oriented-technical-problem-classification-example-1</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的rm删除指令|Zam9036博客</title>
    <url>/2019/11/04/11-Rm-delete-instruction-in-Linux/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h2><p>rm指令的作用：用于删除一个文件或者目录。 </p>
<h2 id="rm语法"><a href="#rm语法" class="headerlink" title="rm语法"></a>rm语法</h2><p><code>rm [选项] 目录</code></p>
<h3 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h3><pre><code class="选项说明">-f    //忽略不存在的文件，即使原文件属性是只读，也强制删除文件或目录，无任何提示
-i    //进行交互式地删除，删除已有文件或目录之前先询问用户
-r / -R    //递归处理，将目录下的所有文件与子目录一块处理
-v    //详细显示指令执行的步骤</code></pre>
<h3 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h3><p>目录可以是文件或目录的路径，如果需要删除的目录中含有子目录，则需要加上<code>-r 或 -R</code>选项</p>
<h2 id="指令实例"><a href="#指令实例" class="headerlink" title="指令实例"></a>指令实例</h2><pre><code class="指令实例">[root]# rm a.txt    //常规方法删除a.txt文件

[root]# rm -f b.lock    //强制删除b.lock文件

[root]# rm -r dir file    //删除file目录下所有文件（包括子文件和子目录）

[root]# rm  -r  *    //删除当前目录下的所有文件及目录</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/04/11-Rm-delete-instruction-in-Linux">https://zam9036.gitee.io/2019/11/04/11-Rm-delete-instruction-in-Linux</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的cd指令|Zam9036博客</title>
    <url>/2019/11/02/10-Cd-instruction-in-Linux/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h2><p>​    Linux cd命令用于切换当前工作目录至 dirName(目录参数)。<br>​    其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚登录时所在的目录)。<br>​    另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p>
<h2 id="cd语法"><a href="#cd语法" class="headerlink" title="cd语法"></a>cd语法</h2><pre><code class="Linux终端指令">cd [dirName]    //dirName：要切换的目标目录</code></pre>
<h2 id="指令实例"><a href="#指令实例" class="headerlink" title="指令实例"></a>指令实例</h2><pre><code class="Linux终端指令">cd /usr/bin      //跳转到/usr/bin/目录

cd ~      //跳转到自己的 home 目录

cd ../..      //跳转到目前目录的上上两层

cd ./path      //跳转到当前目录下的path目录中，“.”表示当前目录

cd ../path      //跳转到上层目录中的path目录中，“..”表示上一层目录</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/02/10-Cd-instruction-in-Linux">https://zam9036.gitee.io/2019/11/02/10-Cd-instruction-in-Linux</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>用栈实现简易计算器|Zam9036博客</title>
    <url>/2019/11/01/9-Implementing-a-simple-calculator-with-a-stack/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>​    C++</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>​    熟悉C++的语法，掌握栈的运算及应用，了解对算法的健壮性要求。</p>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul>
<li>实现计算器类中lp、rp和operate函数</li>
<li>完善计算器类evaluate函数，增加对输入的合法性检查，包括滤掉所有非法输入及处理左右括号不配对的输入</li>
<li>编制应用程序测试这个计算器</li>
</ul>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="程序要求"><a href="#程序要求" class="headerlink" title="程序要求"></a>程序要求</h3><p>​    利用栈原理，设计一个可以计算所输入表达式的程序，要求可以计算正数，负数，小数的加减乘除运算和括号运算，以#结束输入。</p>
<h3 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h3><p>​    对输入的式子进行判断式子格式是否正确。若正确，进行运算并输出最终结果；若错误，提示报错。</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>​    用栈实现计算器，主要思路就是设置一个符号栈和一个数字栈用于存储数字和字符。输入字符串时在字符串尾部加一个“#”以示输入结束。然后扫描字符串，如果扫描结果是数字就进入数字栈。如果是运算符号要判断符号优先级，若栈外符号优先级大于栈内符号优先级则进栈；若小于栈内优先级，则符号栈出栈一位，数字栈出栈两位进行计算，结果重新进入数字栈，直到栈外优先级大于栈内。</p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>用如下表达式进行测试：</p>
<p>(56-23)/8-4#   期望结果：0.125</p>
<p>34+p(u89-12.3)k/3#    期望结果：59.5667</p>
<p>89.5*749+25)#   期望结果：输入有误</p>
<p>(8*(7-4)#   期望结果：输入有误</p>
<p>65*(72+98)(70-45) #   期望结果：输入有误</p>
<p>6*#  期望结果：输入有误</p>
<p>)5+3(#   期望结果：输入有误 </p>
<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><h3 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h3><p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/1.png" alt="示例测试1"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/2.png" alt="示例测试2"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/3.png" alt="示例测试3"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/4.png" alt="示例测试4"></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/5.png" alt="示例测试5"></p>
<h3 id="已解决的问题"><a href="#已解决的问题" class="headerlink" title="已解决的问题"></a>已解决的问题</h3><h4 id="1-无法去除字符串中的乱入字母"><a href="#1-无法去除字符串中的乱入字母" class="headerlink" title="1.无法去除字符串中的乱入字母"></a>1.无法去除字符串中的乱入字母</h4><p>​    解决方法：定位test.cpp文件，在字符串输入栈之前先用循环剔除乱入字母，然后将整理过的字符串入栈。</p>
<h4 id="2-无法识别各类错误"><a href="#2-无法识别各类错误" class="headerlink" title="2.无法识别各类错误"></a>2.无法识别各类错误</h4><p>​    解决方法：思考各类错误触发条件，添加bool类型的Error的判断函数，利用左右优先级加入判断各类错误的代码。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/6.png" alt="识别错误代码"></p>
<h2 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h2><pre><code class="c++">//Stack.h

//用单链表实现堆栈操作
#ifndef STACK__H__
#define STACK__H__

//导入库文件
#include &lt;iostream&gt;

enum errorcode{ success, overflow, underflow ,wrong};
using namespace std; //使用标准命名空间

template&lt;class T&gt;
struct Node//构建节点类 
{
    Node(const T &amp;da, Node* p);
    T data;
    Node *next;
};

template&lt;class T&gt;
Node&lt;T&gt;::Node(const T &amp;da, Node* p)
{
    data = da;
    next = p;
}

template&lt;class T&gt;
class Stack
{
public:
    Stack();//初始化链表 
    ~Stack();//析构 
    void clean();//清空链表 
    errorcode push(const T da);//压栈 
    T pop();//弹出
    T top();//查看栈顶
    bool isempty();//判断单链表是否为空 
public:
    int len;
private:
    Node&lt;T&gt; *head;
};

template&lt;class T&gt;
Stack&lt;T&gt;::Stack()
{
    head = NULL;
    len = 0;
}

template&lt;class T&gt;
Stack&lt;T&gt;::~Stack()
{
    clean();
}

template&lt;class T&gt;
void Stack&lt;T&gt;::clean()//清空链表 
{
    Node&lt;T&gt;* p = head, *q;
    while (p)
    {
        q = p-&gt;next;
        delete p;
        p = q;
    }
    head = NULL;
    len = 0;
}

template&lt;class T&gt;
errorcode Stack&lt;T&gt;::push(const T da)
{
    Node&lt;T&gt;* p = head;
    Node&lt;T&gt;* q = new Node&lt;T&gt;(da, p);
    if (NULL == q)
        return overflow;
    head = q;
    len++;
    return success;
}

template&lt;class T&gt;
T Stack&lt;T&gt;::pop()
{
    if (0 == len || NULL == head)
        exit(1);//非正常结束
    T temp = head-&gt;data;
    head = head-&gt;next;
    len--;
    return temp;
}

template&lt;class T&gt;
T Stack&lt;T&gt;::top()
{
    if (0 == len || NULL == head)
        exit(1);//非正常结束
    return head-&gt;data;
}

template&lt;class T&gt;
bool Stack&lt;T&gt;::isempty()
{
    return (0 == len);
}

#endif
</code></pre>
<pre><code class="c++">//calculator.h

#ifndef CALCULATOR__H__
#define CALCULATOR__H__

//导入堆栈头文件
#include &quot;Stack.h&quot;
#include &lt;cstdlib&gt;

using namespace std;//使用标准命名空间

//计算器类
class Calculator
{
public:
    Calculator();
    ~Calculator();
    errorcode setnull();
    double show();
    errorcode run();//计算过程 
    double operate(char op,double a,double b); 
    bool error(char op,char ch);//识别各种错误
    double double_type(double a);
private:
    Stack&lt;double&gt; opnd;
    Stack&lt;char&gt; optr;
    double value;
    int lp(char op);//右优先度 
    int rp(char op);//左优先度 
};

#endif</code></pre>
<pre><code class="c++">//calculator.cpp

#include &quot;calculator.h&quot;

Calculator::Calculator() 
{
    optr.clean();
    opnd.clean(); 
    optr.push(&#39;#&#39;);
}


Calculator::~Calculator()
{
}

errorcode Calculator::setnull()
{
    optr.clean();
    opnd.clean();
    return optr.push(&#39;#&#39;);
}

double Calculator::show()
{
    return value;
}

errorcode Calculator::run()
{
    char ch,op,ope;
    double val,a,b;
    bool lastisdig = false;
    bool lastisdot = false;
    op = &#39;#&#39;;
    cin &gt;&gt; ch;
    while (ch!=&#39;#&#39;||op!=&#39;#&#39;)
    {
        if (error(op, ch))
            return wrong;    
        if (&#39;.&#39;==ch)
        {
            lastisdot = true;
            cin &gt;&gt; ch;
            continue;
        }
        else if (isdigit(ch))
        {
            cin.putback(ch);
            cin &gt;&gt; val;
            if (true == lastisdig)//两部分数字组合为一个
            {
                if (true == lastisdot)
                {
                    double integer = opnd.pop();
                    val = integer + double_type(val);
                }
                else
                {
                }
            }
            opnd.push(val);
            lastisdig = true;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else if (lp(op)&lt;rp(ch))
        {
            optr.push(ch);
            op = ch;
            lastisdig = false;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else if (lp(op)==rp(ch))
        {
            optr.pop();
            op = optr.top();
            lastisdig = false;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else
        {
            ope = optr.pop();
            b = opnd.pop();
            a = opnd.pop();
            opnd.push(operate(ope, a, b));
            op = optr.top();
            lastisdig = false;
            lastisdot = false;
        }
    }
    value = opnd.top();
    return success;
}

double Calculator::operate(char op, double a, double b)
{
    switch (op)
    {
    case &#39;+&#39;:return a + b; break;
    case &#39;-&#39;:return a - b; break;
    case &#39;*&#39;:return a * b; break;
    case &#39;/&#39;:if (b == 0){
        cout &lt;&lt; &quot;分母不能为0&quot; &lt;&lt; endl; 
        exit(1);
    } 
    else return (a / b); break;
    default:exit(1); break;
    }
}

int Calculator::lp(char op)
{
    switch (op)
    {
    case &#39;+&#39;:return 2; break;
    case &#39;-&#39;:return 3; break;
    case &#39;*&#39;:return 4; break;
    case &#39;/&#39;:return 5; break;
    case &#39;(&#39;:return 1; break;
    case &#39;)&#39;:return 6; break;
    case &#39;#&#39;:return 0; break;
    default:return -1; break;
    }
}

int Calculator::rp(char op)
{
    switch (op)
    {
    case &#39;+&#39;:return 3; break;
    case &#39;-&#39;:return 2; break;
    case &#39;*&#39;:return 5; break;
    case &#39;/&#39;:return 4; break;
    case &#39;(&#39;:return 6; break;
    case &#39;)&#39;:return 1; break;
    case &#39;#&#39;:return 0; break;
    default:return -1; break;
    }
}

bool Calculator::error(char op, char ch)
{
    if (1 == lp(op) &amp;&amp; 0 == rp(ch))
        return true;
    if (6 == lp(op) &amp;&amp; 6 == rp(ch))
        return true;
    if (0 == lp(op) &amp;&amp; 1 == rp(ch))
        return true;
    if (4 == lp(op) &amp;&amp; 0 == rp(ch))
        return true;
    return false;
}

double Calculator::double_type(double a)
{
    while (a &gt;= 1)
        a /= 10;
    return a;
}</code></pre>
<pre><code class="c++">//test.cpp

#include &lt;iostream&gt;

#include &quot;calculator.h&quot;
using namespace std;

int main()
{
    char str[100];
    char c;
    int i;
    int c1 = 0, c2 = 0;
    Calculator test;
    cout &lt;&lt; &quot;欢迎使用计算器，请输入等式：\n&quot;;
     while (true) 
    {
        i = 0;
        cin &gt;&gt; c;
        while (c != &#39;#&#39;)
        {
            if (!((c &gt;= &#39;a&#39;&amp;&amp;c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39;&amp;&amp;c &lt;= &#39;Z&#39;)))//排除无效字符
            {
                str[i] = c;
                i++;
            }
            cin &gt;&gt; c; 
        }
        cin.putback(c);
        for (i--; i &gt;= 0; i--)
        {
            cin.putback(str[i]);
            if (str[i] == &#39;(&#39;) {
                c1++;
            }
            if (str[i] == &#39;)&#39;) {
                c2++;
            }
        }
        if (c1 != c2) {
            cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;
            break;
        }
         else if (success == test.run())
            cout &lt;&lt; test.show() &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;
        cin.sync();//清空缓存
     }
        system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/01/9-Implementing-a-simple-calculator-with-a-stack">https://zam9036.gitee.io/2019/11/01/9-Implementing-a-simple-calculator-with-a-stack</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>项目</tag>
        <tag>课程:数据结构英文C</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Ubuntu上安装GD图片支持库遇到的问题|Zam9036博客</title>
    <url>/2019/10/30/8-Record-problems-encountered-in-installing-GD-image-support-library-on-Ubuntu/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>​    配置Ubuntu对php-gd的支持，网上大多是都是通过逐一配置freetype、libpng、libjpeg…..这样的方法过于繁琐，且出错率过高。CentOS中的yum指令<code>yum install php-gd</code>，可以一条指令配置对php-gd的支持，但是Ubuntu默认软件包管理器不是yum，这就导致了配置的时候会出现</p>
<pre><code class="提示">没有已启用的仓库。
执行 &amp;quot;yum repolist all&amp;quot; 查看您拥有的仓库。
您可以用 yum-config-manager --enable &amp;amp;lt;仓库名&amp;amp;gt; 来启用仓库</code></pre>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>​    CentOS的默认软件包管理器是yum，而Ubuntu默认软件包管理器是dpkp，可以尝试<code>apt-get</code>的方法进行安装。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>​    输入命令代码<code>sudo apt-get install php-gd</code>，发现可以安装了。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/30/8-Record-problems-encountered-in-installing-GD-image-support-library-on-Ubuntu">https://zam9036.gitee.io/2019/10/30/8-Record-problems-encountered-in-installing-GD-image-support-library-on-Ubuntu</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows与Linux服务器间快速上传、下载文件（SCP指令）|Zam9036博客</title>
    <url>/2019/10/28/7-Quickly-upload-and-download-files-between-Windows-and-Linux-servers-SCP-instructions/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="SCP指令"><a href="#SCP指令" class="headerlink" title="SCP指令"></a>SCP指令</h2><p>​    scp的指令的作用是可以将本地的文件上传到一台远端服务器，或将远端服务器的文件下载到本地，其格式如下：</p>
<p>​    <code>scp 本地文件地址 远端Liunx用户名@远端IP地址:远端文件存储地址    //上传指令</code></p>
<p>​    <code>scp 远端Liunx用户名@远端IP地址:远端文件地址 本地文件存储地址    //下载指令</code></p>
<h2 id="利用SCP指令从Windows上传文件到Linux服务器"><a href="#利用SCP指令从Windows上传文件到Linux服务器" class="headerlink" title="利用SCP指令从Windows上传文件到Linux服务器"></a>利用SCP指令从Windows上传文件到Linux服务器</h2><p>​    现有一个本地的BBS-Forum.zip文件需要上传到Linux服务器。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/1.png" alt="本地文件"></p>
<p>​    首先打开命令提示符cmd，按SCP指令格式输入<code>scp F:\GitHub\BBS-Forum.zip root@211.68.46.235:/var/www/html</code>，其中root是远端Liunx用户名，然后输入密码（密码不显示），开始上传。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/2.png" alt="命令提示符"></p>
<p>​    然后去云服务器端查看文件，成功上传！</p>
<p><img src="https://zam9036.gitee.io/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/3.png" alt="云服务器端"></p>
<h2 id="利用SCP指令从Linux服务器下载文件到Windows"><a href="#利用SCP指令从Linux服务器下载文件到Windows" class="headerlink" title="利用SCP指令从Linux服务器下载文件到Windows"></a>利用SCP指令从Linux服务器下载文件到Windows</h2><p>​    原理同上传，执行<code>scp root@211.68.46.235:/var/www/html/BBS-Forum.zip F:\GitHub</code>，输入密码，开始下载。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>在cmd中输入密码时，考虑安全性问题，密码默认不显示，但实际已经成功输入。</li>
<li>请注意用 \ 作为Windows端文件目录，用 / 作为Linux端文件目录。</li>
</ul>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/28/7-Quickly-upload-and-download-files-between-Windows-and-Linux-servers-SCP-instructions">https://zam9036.gitee.io/2019/10/28/7-Quickly-upload-and-download-files-between-Windows-and-Linux-servers-SCP-instructions</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo在博客中插入本地图片（无需外链）|Zam9036博客</title>
    <url>/2019/10/27/6-Use-Hexo-to-insert-local-pictures-in-your-blog-no-external-link-required/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在用Hexo写博客的过程中我们往往需要在博客中插入图片。MarkDown中插入图片有两种方式：一种是使用外链，一种是使用本地图片。而如果使用外链图片，我们需要找好用的图床，以防图片链接不定时挂掉，这大大增加了写博客的时间成本。本地图片如果使用绝对路径会导致上传到Github上时链接不到，所以本文提供了一种利用本地图片的相对路径的方式来插入图片。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>​    我们在启用博客主题时会发现，博客主题中的内置图片，会随<code>hexo g</code>指令一起部署到public文件夹，上传时也会一同上传到Github上，这就为我们保存博客中的图片提供了一种思路。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/1.png" alt="public文件夹中的img文件夹"></p>
<h2 id="新建本地图片库"><a href="#新建本地图片库" class="headerlink" title="新建本地图片库"></a>新建本地图片库</h2><p>​    查看<code>Hexo-themes</code>中的文件我们可以知道，主题文件的图片存在了<code>source-img</code>文件夹中，所以我们在这个文件夹中新建一个postimg文件夹，用于存放博客中需要保存的图片。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/2.png" alt="新建postimg文件夹"></p>
<p>​    然后我们把图片存进去，执行<code>hexo g</code>，会发现在<code>public-img</code>文件夹中也多了一个postimg文件夹，里面有我们刚刚存进去的图片。这说明Hexo在部署博客时，也将postimg部署到了博客里。同理，上传时也会将postimg一起上传到Github上，这说明利用相对路径保存图片的方法可行。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/3.png" alt="postimg文件夹"></p>
<h2 id="图片的相对路径"><a href="#图片的相对路径" class="headerlink" title="图片的相对路径"></a>图片的相对路径</h2><p>​    我们查看主题的配置文件，发现图片的相对路径是<code>/img/XXXXX.jpg</code>，所以可以推算出我们刚刚保存的图片的相对路径是<code>https://zam9036.gitee.io/img/postimg/XXXXX.jpg</code>（其中XXXXX为文件名，<code>.jpg</code>为文件后缀，均可修改）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/4.png" alt="图片的相对路径"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    所以我们只需要在MarkDown中插入图片时，填写图片的相对路径，然后将图片保存到主题文件夹下的<code>source-img-postimg</code>就可以实现利用本地图片的相对路径的方式来插入图片。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>​    在插入图片时，本地的MarkDown编辑器会找不到图片，这忽略这个问题。因为图片的相对路径在部署博客时会自动更新到public文件夹，自动更新后的相对路径才是正确的，才是可以被服务器访问的。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/5.png" alt="本地的MarkDown编辑器会找不到图片"></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/27/6-Use-Hexo-to-insert-local-pictures-in-your-blog-no-external-link-required">https://zam9036.gitee.io/2019/10/27/6-Use-Hexo-to-insert-local-pictures-in-your-blog-no-external-link-required</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown简易语法快速入门|Zam9036博客</title>
    <url>/2019/10/26/5-MarkDown-Easy-Grammar-Quick-Start/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 <code>*</code> 表示斜体 ，<code>**</code> 表示粗体。</p>
<p>示例：</p>
<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>
<hr>
<h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><pre><code># 这是一级标题
## 这是二级标题
### 这是三级标题
#### 这是四级标题
##### 这是五级标题
###### 这是六级标题</code></pre><p>上方代码效果：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><blockquote>
<p>Tips：部分软件及网页对标题层级支持有限</p>
</blockquote>
<hr>
<h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p>
<p>示例：</p>
<p><code>[百度一下，你就知道](https://www.baidu.com)</code></p>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下，你就知道</a></p>
<hr>
<h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>在句首使用<code>*</code> 或<code>+</code>或 <code>-</code> 表示无序列表。</p>
<p>示例：</p>
<ul>
<li>无序列表项 一</li>
</ul>
<ul>
<li>无序列表项 二</li>
</ul>
<ul>
<li>无序列表项 三</li>
</ul>
<hr>
<h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>在句首使用数字和<code>.</code>表示有序列表。</p>
<p>示例：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<hr>
<h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 <code>&gt;</code> 表示文字引用。</p>
<p>示例：</p>
<blockquote>
<p>野火烧不尽，春风吹又生。</p>
</blockquote>
<hr>
<h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p>
<p>示例：</p>
<p>让我们聊聊 <code>Java</code>。</p>
<hr>
<h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>以```开头并结尾表示代码块，在开头注明所用编程语言即可高亮语法。</p>
<p>示例：</p>
<pre><code class="c">include staio.h

void main()
{
    print(&quot;Hello World&quot;);
}</code></pre>
<pre><code class="java">public class Main
{
    public void main(String[] args)
    {
        System.out.print(&quot;Hello World&quot;);
    }
}</code></pre>
<hr>
<h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p>
<p>示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0cb6750a04553993453b54ef72e8b62d_r.jpg" alt="我的知乎背景图"></p>
<hr>
<h3 id="10-内容目录"><a href="#10-内容目录" class="headerlink" title="10. 内容目录"></a>10. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>
<p>[TOC]</p>
<hr>
<h3 id="11-删除线"><a href="#11-删除线" class="headerlink" title="11. 删除线"></a>11. 删除线</h3><p>使用 ~~ 于文字两端表示删除线。</p>
<p><del>删除</del></p>
<hr>
<h3 id="12-LaTeX-公式"><a href="#12-LaTeX-公式" class="headerlink" title="12. LaTeX 公式"></a>12. LaTeX 公式</h3><p>$ 表示行内公式： </p>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<p>$$ 表示整行公式：</p>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p>
<p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<p>详见LaTeX语法</p>
<hr>
<h3 id="13-流程图"><a href="#13-流程图" class="headerlink" title="13. 流程图"></a>13. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="flow">st=&gt;start: Start
io=&gt;inputoutput: verification
op=&gt;operation: Your Operation
cond=&gt;condition: Yes or No?
sub=&gt;subroutine: Your Subroutine
e=&gt;end

st-&gt;io-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;sub-&gt;io</code></pre>
<p>详见流程图语法</p>
<hr>
<h3 id="14-表格支持"><a href="#14-表格支持" class="headerlink" title="14. 表格支持"></a>14. 表格支持</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<hr>
<h3 id="15-HTML标签"><a href="#15-HTML标签" class="headerlink" title="15. HTML标签"></a>15. HTML标签</h3><p>支持在 Markdown 语法中嵌套HTML标签，譬如，你可以用HTML写一个纵跨两行的表格：</p>
<pre><code class="html">&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>
---

<h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>
<pre><code> [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>Cmd Markdown 开发</strong><ul>
<li><input disabled="" type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li><input disabled="" type="checkbox"> 支持以 PDF 格式导出文稿</li>
<li><input checked="" disabled="" type="checkbox"> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li>
<li><input checked="" disabled="" type="checkbox"> 改进 LaTex 功能<ul>
<li><input checked="" disabled="" type="checkbox"> 修复 LaTex 公式渲染问题</li>
<li><input checked="" disabled="" type="checkbox"> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> <strong>七月旅行准备</strong><ul>
<li><input disabled="" type="checkbox"> 准备邮轮上需要携带的物品</li>
<li><input disabled="" type="checkbox"> 浏览日本免税店的物品</li>
<li><input checked="" disabled="" type="checkbox"> 购买蓝宝石公主号七月一日的船票</li>
</ul>
</li>
</ul>
<h2 id="转载声明"><a href="#转载声明" class="headerlink" title="转载声明"></a>转载声明</h2><p>​    原文作者：Cmd Markdown 开发</p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo写一篇博客|Zam9036博客</title>
    <url>/2019/10/25/4-Write-a-blog-with-Hexo/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="文章布局（Layout）"><a href="#文章布局（Layout）" class="headerlink" title="文章布局（Layout）"></a>文章布局（Layout）</h2><p>​    在写博客之前，先了解一下Hexo的文章布局。 Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；大家自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。 </p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody></table>
<h2 id="文章模板（Scaffold）"><a href="#文章模板（Scaffold）" class="headerlink" title="文章模板（Scaffold）"></a>文章模板（Scaffold）</h2><p>​    在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>
<pre><code>$ hexo new photo &quot;My Gallery&quot;</code></pre><p>​    在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章。所以大家可以在 <code>source/_posts</code> 文件夹中自定义文章模板，来节省重复操作的时间。</p>
<h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><p>​    你可以执行下列命令来创建一篇新文章或者新的页面。</p>
<pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>​    你可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>
<p>​    新建文章后，可以在 <code>source</code> 中找到新建的文章（.md文件），然后使用Typora或其他md编辑器编写博客。MarkDown的语法请关注我后续的博客！</p>
<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>​    文章保存后，在<code>Hexo工作区</code>利用Git bash输入<code>hexo g</code>来发布博客，<code>hexo s</code>本地预览博客，没有问题以后用<code>hexo d</code>或者Github Desktop来上传代码。至此，一篇博客已经生成。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/25/4-Write-a-blog-with-Hexo">https://zam9036.gitee.io/2019/10/25/4-Write-a-blog-with-Hexo</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>更改Hexo博客的主题|Zam9036博客</title>
    <url>/2019/10/24/3-Change-the-theme-of-the-Hexo-blog/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><h3 id="从网上选择主题"><a href="#从网上选择主题" class="headerlink" title="从网上选择主题"></a>从网上选择主题</h3><p>​    互联网资源丰富，大家可以在网上（如GitHub）查找自己喜欢的Hexo的模板主题并下载。一般情况下，Hexo的模板主题下载后会有以下文件（当然每个主题包含的文件也是不一样的），如果文件内容出入比较大，大家就需要进一步确认一下下载的主题是不是一个Hexo的主题。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/1.png" alt="主题文件参考"></p>
<h3 id="从Hexo官方主题库选择主题"><a href="#从Hexo官方主题库选择主题" class="headerlink" title="从Hexo官方主题库选择主题"></a>从Hexo官方主题库选择主题</h3><p>​    访问<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官方主题库</a>，选择并下载自己所需的主题。不得不说，官方的主题库还是有很多好用的模板的。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/2.png" alt="官方主题页"></p>
<h3 id="自创主题"><a href="#自创主题" class="headerlink" title="自创主题"></a>自创主题</h3><p>​    如果你是大神，你还可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a>自己写主题模板！</p>
<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>​    一般情况下，主题文件内会含有README.md文件供大家参考，大家可以查看README.md文件查看主题的启用方式和注意事项。</p>
<p>​    来说说通用启用主题的方式：打开 <code>Hexo</code> 配置文件 <code>_config.yml</code>, 设置主题为你所下载主题的主题名。注意是Hexo工作区的<code>_config.yml</code>，不是主题文件夹内的<code>_config.yml</code>。Hexo工作区的<code>_config.yml</code>是修改整个博客的基础配置文件，而主题文件夹内的<code>_config.yml</code>是主题的配置文件。</p>
<p>例：</p>
<pre><code>...
theme: obsidian
...</code></pre><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>​    不同的主题配置方法不同，大家需要查看主题的README.md文件来了解自己主题的配置方式和注意事项。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/3.png" alt="配置主题"></p>
<h2 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h2><p>​    主题启用配置好后，在<code>Hexo工作区</code>利用Git bash输入<code>hexo g</code>来部署主题，<code>hexo s</code>本地预览主题，没有问题以后用<code>hexo d</code>或者Github Desktop来上传代码。至此，博客的主题更改完成。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/24/3-Change-the-theme-of-the-Hexo-blog">https://zam9036.gitee.io/2019/10/24/3-Change-the-theme-of-the-Hexo-blog</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用GitHub+Hexo搭建个人博客详细教程|Zam9036博客</title>
    <url>/2019/10/23/2-A-detailed-tutorial-on-building-a-personal-blog-with-GitHub-Hexo/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是GitHub"><a href="#什么是GitHub" class="headerlink" title="什么是GitHub"></a>什么是GitHub</h3><p>​    GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。<br>​    GitHub于2008年4月10日正式上线，除了Git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。</p>
<h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><p>​    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><p>Windows</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>创建github账号</li>
<li>安装Node.js、npm，并了解相关基础知识</li>
<li>安装git for windows 或 GitHub Desktop（或者其它git客户端）</li>
</ul>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="创建GitHub博客仓库"><a href="#创建GitHub博客仓库" class="headerlink" title="创建GitHub博客仓库"></a>创建GitHub博客仓库</h3><p>​    如没有GitHub账号请自行百度并注册。在GitHub上新建一个名为<code>username.github.io</code>的仓库，其中username为GitHub的用户名（注意而非昵称！），那么最终生成的博客链接就为<code>https://username.github.io</code></p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.png" alt="创建仓库"></p>
<p><strong>例</strong>：如果你的github用户名是jack，那么你应该新建jack.github.io的仓库（其他名称无效）</p>
<p><strong>注</strong>：</p>
<ul>
<li><p>每一个GitHub账户最多只能创建一个可以直接使用域名访问的仓库。</p>
</li>
<li><p>GitHub账号需要验证邮箱，否则无效。</p>
</li>
<li><p>仓库创建成功后需要等待一定时间后才能生效。</p>
</li>
</ul>
<p>​    如在上图中勾选自动创建ReadMe，创建成功后尝试访问<code>https://username.github.io</code>查看ReadMe.md文件（如未勾选影响也不大）。</p>
<h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>​    在很多地方都会用到SSH Key来解决直接使用账号密码不安全的问题。打开Git for Windows</p>
<p>​    <code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></p>
<p>​    然后按提示进行并点击回车，最终会在电脑的<code>C:\Users\XXX\.ssh</code>目录下（XXX为电脑当前登录的用户名）生成 <code>.ssh\id_rsa.pub</code> 文件，用记事本打开并将里面的内容全部复制。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2.png" alt="生成SSH Key"></p>
<p>​    打开你的GitHub主页，进入<code>个人设置— SSH and GPG keys — New SSH key</code>，将刚刚复制的文本复制到Key方框内，Title可随意填写。</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/3.png" alt="配置SSH Key"></p>
<p>​    下面来检测一下是否通过SSH连接成功</p>
<p>​    <code>$ ssh -T git@github.com # 无需更改git@github.com</code></p>
<p>​    应该会提示 <code>Are you sure you want to continue connecting (yes/no)?</code> 输入yes，提示<code>Hi Zam90! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>说明SSH配置成功，然后输入以下指令</p>
<pre><code>$ git config --global user.name &quot;Username&quot;// 你的github用户名，注意不是昵称
$ git config --global user.email  &quot;xxx@xxx.com&quot;// 填写已经验证过的github注册邮箱</code></pre><h3 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h3><p>​    在电脑中新建一个文件夹（名字随意），但创建好之后无法随意更改，所以考虑好建在一个合适的位置。以我的<code>F:\Hexo</code>为例来做说明。</p>
<pre><code>$ cd /f/Hexo/  #跳转到文件夹位置
$ hexo init  #在此文件内创建Hexo工作区</code></pre><p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/4.png" alt="创建Hexo工作区"></p>
<p>​    创建完成后文件夹内应该有以上内容（除了public）</p>
<p>​    然后执行以下指令</p>
<p>​    <code>$ hexo g # 生成Hexo博客文件</code></p>
<p>​    此时Hexo会自动在public文件夹内生成博客文件</p>
<p>​    <code>$ hexo s # 启动本地预览服务</code></p>
<p>​    此时打开浏览器访问<code>localhost:4000</code>，可以看到默认生成的博客主页</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/5.png" alt="默认博客主页"></p>
<h3 id="上传博客至GitHub"><a href="#上传博客至GitHub" class="headerlink" title="上传博客至GitHub"></a>上传博客至GitHub</h3><h4 id="Git-bash上传"><a href="#Git-bash上传" class="headerlink" title="Git bash上传"></a>Git bash上传</h4><p>​    首先，验证你的SSH成功配置</p>
<p>​    然后用记事本打开Hexo工作区内的配置文件 <code>_config.yml</code> ，修改<code>deploy</code>部分：</p>
<pre><code>deploy:
  type: git
  repository: git@github.com:zam90/zam90.github.io.git
  branch: master</code></pre><p>​    然后在Git bash中输入</p>
<p>​    <code>hexo d</code></p>
<p>​    如报错： <code>Deployer not found: github 或者 Deployer not found: git</code> </p>
<p>​    输入以下指令安装插件解决：</p>
<p>​    <code>npm install hexo-deployer-git --save</code></p>
<p>​    然后再次<code>Hexo d</code>就可以了。</p>
<h4 id="GitHub-Desktop上传"><a href="#GitHub-Desktop上传" class="headerlink" title="GitHub Desktop上传"></a>GitHub Desktop上传</h4><p>​    自从GitHub Desktop上线后，上传代码就有了更方便的选择。</p>
<p>​    安装GitHub Desktop后，clone你的username.github.io仓库到Hexo工作区内的public文件夹，这样<code>Hexo g</code>后public文件夹内的新文件就会被GitHub Desktop检测到：</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/6.png" alt="GitHub Desktop端"></p>
<p>​    然后输入Summary，点击Fetch origin就可以直接上传。</p>
<p>​    当然你也可以选择不把仓库clone到public文件夹内。clone时选择其他文件夹，然后把public内的文件复制到那个clone的文件夹，然后依然可以用GitHub Desktop上传。</p>
<h3 id="检测连接"><a href="#检测连接" class="headerlink" title="检测连接"></a>检测连接</h3><p>​    尝试访问<a href="https://username.github.io，如果成功显示和本地预览相同的界面说明博客搭建成功！" target="_blank" rel="noopener">https://username.github.io，如果成功显示和本地预览相同的界面说明博客搭建成功！</a></p>
<h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><h3 id="在启动本地预览界面后访问localhost-4000显示空白界面"><a href="#在启动本地预览界面后访问localhost-4000显示空白界面" class="headerlink" title="在启动本地预览界面后访问localhost:4000显示空白界面"></a>在启动本地预览界面后访问localhost:4000显示空白界面</h3><p>​    如打开页面显示为空白界面，大概率因为4000端口被占用，执行<code>$ hexo server -p 5000</code>，然后访问localhost:5000。</p>
<h3 id="Git上传失败"><a href="#Git上传失败" class="headerlink" title="Git上传失败"></a>Git上传失败</h3><p>​    请检查SSH Key的配置是否生效。同时注意修改Hexo工作区内的配置文件 <code>_config.yml</code> 。</p>
<p>​    修改<code>deploy</code>部分时：</p>
<pre><code>deploy:
  type: git
  repository: git@github.com:zam90/zam90.github.io.git
  branch: master</code></pre><p>​    注意<code>repository:</code>处不要写成 <code>repository: https:</code>（我遇过的坑）</p>
<h3 id="博客上传成功后访问时收到GitHub的Error邮件"><a href="#博客上传成功后访问时收到GitHub的Error邮件" class="headerlink" title="博客上传成功后访问时收到GitHub的Error邮件"></a>博客上传成功后访问时收到GitHub的Error邮件</h3><p>​    如收到GitHub的以下邮件：（我遇过的坑）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/7.jpg" alt="Error邮件"></p>
<p>​    请到<code>Hexo工作区—themes/landscape</code>下删除README.md文件后尝试重新上传，此问题可能是index.html与README.md文件冲突导致。</p>
<h3 id="博客上传成功后访问时收到GitHub的Warning邮件"><a href="#博客上传成功后访问时收到GitHub的Warning邮件" class="headerlink" title="博客上传成功后访问时收到GitHub的Warning邮件"></a>博客上传成功后访问时收到GitHub的Warning邮件</h3><p>​    如收到GitHub的以下邮件：（我遇过的坑）</p>
<p><img src="https://zam9036.gitee.io/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/8.jpg" alt="Warning邮件"></p>
<p>​    请尝试重新配置SSH Key文件，并使用Git for Windows上传博客。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>​    如有其他问题，请参考<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">官方文档</a>，逐一排查尝试解决。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    至此个人博客已经搭建完成，在后续的文章中我会详细讲解如何更换博客主题、写博客、创建新页面、不使用外链插入图片……感谢您的持续关注！</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/23/2-A-detailed-tutorial-on-building-a-personal-blog-with-GitHub-Hexo">https://zam9036.gitee.io/2019/10/23/2-A-detailed-tutorial-on-building-a-personal-blog-with-GitHub-Hexo</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客|Zam9036博客</title>
    <url>/2019/10/23/1-First-blog/</url>
    <content><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>​    这是第一篇博客，网站已经能够稳定运行，博客系统可以使用。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/23/1-First-blog">https://zam9036.gitee.io/2019/10/23/1-First-blog</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>文章随笔</category>
      </categories>
  </entry>
  <entry>
    <title>关于About|Zam9036博客</title>
    <url>/about/index.html</url>
    <content><![CDATA[<img src="https://zam9036.gitee.io/img/avatar.png" style="height: 100px; width: 100px; border-radius: 50%; margin-bottom: 15px" />

<h3 id="欢迎Welcome"><a href="#欢迎Welcome" class="headerlink" title="欢迎Welcome"></a><code>欢迎Welcome</code></h3><p>​    欢迎来到<b style="color: #42d2ca"> <strong>Zam9036的博客</strong> </b>，在这里记录了一些生活的点滴和技术Demo。</p>
<p>​    Welcome to the <b style="color: #42d2ca"> <strong>Zam9036’s Blog</strong> </b>, where you’ll find something for life and some demo.</p>
<h3 id="个人介绍Introduction"><a href="#个人介绍Introduction" class="headerlink" title="个人介绍Introduction"></a><code>个人介绍Introduction</code></h3><p>​    我是Zam9036，是一个主修计算机科学与技术专业的学生</p>
<p>​    我的微信公众号：<b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>；</p>
<img src="https://zam9036.gitee.io/img/OfficialAccountQRCode.png" style="height: 150px; width: 525px; margin-bottom: 15px" />

<p>​    微信小程序：<b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>，欢迎大家关注！</p>
<img src="https://zam9036.gitee.io/img/MiniProgramQRCode.png" style="height: 150px; width: 525px; margin-bottom: 15px" />

<p>​    I am Zam9036, and I am a student majoring in computer science and technology.</p>
<p>​    My WeChat  Official Accounts : <b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>; </p>
<p>​    WeChat mini program : <b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>, welcome everyone to follow and pay attention!</p>
<h3 id="移动端APP-for-Android"><a href="#移动端APP-for-Android" class="headerlink" title="移动端APP for Android"></a><code>移动端APP for Android</code></h3><p>​    2019.11.3日，Zam9036正式推出了<b style="color: #42d2ca"> <strong>博客的Android端</strong> </b>，欢迎大家下载~</p>
<p>​    On 2019.11.3, Zam9036 officially launched <b style="color: #42d2ca"> <strong>the Android APP of the blog</strong> </b>, welcome everyone to download ~</p>
<p>​    <a href="https://pan.baidu.com/s/1wT_aJCdWudE73XFQL5FtwQ" target="_blank" rel="noopener"><code>下载地址Download</code></a></p>
<h3 id="PC端Program-for-Windows"><a href="#PC端Program-for-Windows" class="headerlink" title="PC端Program for Windows"></a><code>PC端Program for Windows</code></h3><p>​    2020.2.26日，Zam9036正式推出了<b style="color: #42d2ca"> <strong>博客的Windows端应用程序</strong> </b>，欢迎大家下载~</p>
<p>​    On 2020.2.26, Zam9036 officially launched <b style="color: #42d2ca"> <strong>the program for Windows of the blog</strong> </b>, welcome everyone to download ~</p>
<p>​    <a href="https://pan.baidu.com/s/1Xu6RipR8s7ulec3GHSWQ3w" target="_blank" rel="noopener"><code>下载地址Download</code></a> 提取码：ynuq</p>
<h3 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a><code>原创声明</code></h3><p>​    博客作者：<b style="color: #42d2ca"> <strong>Zam9036</strong> </b></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam90.github.io/" target="_blank" rel="noopener">Zam9036的博客</a>！</p>
]]></content>
  </entry>
  <entry>
    <title>分类Categories|Zam9036博客</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>时间轴Archives|Zam9036博客</title>
    <url>/archives/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签Tags|Zam9036的博客</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
