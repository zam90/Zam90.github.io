<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>利用邻接表储存无向非连通图并利用DFS和BFS遍历图的邻接表|Zam9036的博客</title>
    <url>/2019/12/05/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><p>​    C++</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过建立无向非连通图，并对图进行DFS及BFS遍历，了解图的构建算法，并加深对DFS及BFS的理解。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>1）建立无向非连通图的邻接表存储结构，要求顶点个数不少于15个。 2）用DFS及BFS对此邻接表进行遍历，打印出两种遍历的顶点访问顺序。3）给定图中任意两个顶点v1和v2及整数k，判断是否存在从v1到v2的路径长度为k的简单路径，若有打印出路径上的顶点序列（要求路径上不含回路）。进一步：找出从v1到v2的所有路径长度为k的简单路径。（简单路径：顶点序列中不含重现的顶点的路径。）</p>
<h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本实验实现DFS算法是利用栈储存待访问的节点，利用栈的FILO（先入后出）来实现深度搜索；实现BFS是利用队列储存待访问的节点，利用队列的FIFO（先入后出）来实现广度搜索。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试以下5节点图和12节点图</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/1.png" alt="5节点图"></p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/2.png" alt="12节点图"></p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><p>首先创建节点结构（包括该路径指向的顶点位置、指向下一个路径、该路径的相关信息）和连线结构（顶点信息、指向第一条依附该节点路径的指针、访问情况），然后根据输入逐个插入邻接表点从而创建邻接表。</p>
<p>本实验实现DFS算法是利用栈储存待访问的节点，利用栈的FILO（先入后出）来实现深度搜索：从根节点开始，遍历节点的连接表，跳过已访问的节点值，将未访问过的节点加入栈，然后逐一取走栈内元素并对取走的节点邻接表进行遍历，重复相同过程，直至栈为空结束；实现BFS是利用队列储存待访问的节点，利用队列的FIFO（先入后出）来实现广度搜索：从根节点开始，遍历节点的连接表，跳过已访问的节点值，将未访问过的节点加入队列，然后逐一取走队列内元素并对取走的节点邻接表进行遍历，重复相同过程，直至队列为空结束。</p>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><p><img src="/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/3.png" alt="5节点图测试"></p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%82%A8%E5%AD%98%E6%97%A0%E5%90%91%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%B9%B6%E5%88%A9%E7%94%A8DFS%E5%92%8CBFS%E9%81%8D%E5%8E%86%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8/4.png" alt="12节点图测试"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.有重复遍历的节点情况出现</p>
<p>解决方法：对每个节点增加一个访问情况值，访问邻接表时跳过已访问过的值。</p>
<p>2.寻找简单路径暂无思路 </p>
<h1 id="使用说明和测试结果"><a href="#使用说明和测试结果" class="headerlink" title="使用说明和测试结果"></a>使用说明和测试结果</h1><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>用Visual Studio打开.sln文件即可运行</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过，符合程序设计要求和需求分析</p>
<p>详细结果见调试分析-示例测试</p>
<h1 id="体会心得"><a href="#体会心得" class="headerlink" title="体会心得"></a>体会心得</h1><p>通过本次课程实验，我对数据结构的了解进一步加深，并产生了浓厚的兴趣。虽然在写代码过程中遇到了一些问题，但我通过思考、网上找资料、询问同学等方式最终解决了问题。这次实验让我进一步巩固了建立无向非连通图的方法，及对图进行DFS及BFS遍历算法，了解了图的构建算法，并加深了对DFS及BFS的理解，进一步加强了自学能力，拓展了思路。</p>
<h1 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h1><h2 id="graph-cpp"><a href="#graph-cpp" class="headerlink" title="graph.cpp"></a>graph.cpp</h2><pre><code class="c++">#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;iostream&gt;
using namespace std;

//节点遍历情况
enum visitCondition
{
    no,    //未访问
    visiting,    //正在访问，邻接点还没访问完
    yes    //访问完毕
};

template&lt;typename VertexType, typename InfoType&gt;
class Graph
{
public:
    Graph(int vertexNum) :m_vertexNum(vertexNum), m_arcNum(0)
    {
        for (int i = 0; i &lt; MAX_VERTEX_NUM; ++i)
        {
            m_vertices[i].firstArc = nullptr;
        }
    }

    //输出图的信息
    void Display()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个节点为&quot; &lt;&lt; m_vertices[i].data &lt;&lt; &quot; 邻接表为：&quot;;
            ArcNode* node = m_vertices[i].firstArc;
            while (node)
            {
                cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; m_vertices[node-&gt;vertexIndex].data;
                node = node-&gt;next;
            }
            cout &lt;&lt; endl;
        }
    }

    void BFS()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            m_vertices[i].visitconditions = no;
        }
        cout &lt;&lt; &quot;图的广度优先遍历为：&quot;;
        BFS(&amp;m_vertices[0]);
        cout &lt;&lt; endl;
    }

    void DFS()
    {
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            m_vertices[i].visitconditions = no;
        }
        cout &lt;&lt; &quot;图的深度优先遍历为：&quot;;
        DFS(&amp;m_vertices[0]);
        cout &lt;&lt; endl;
    }

    //创建无向无权图
    void Create()
    {
        InitVertices();
        cout &lt;&lt; &quot;请分别输入每条边的起始节点和终止节点:&quot; &lt;&lt; endl;
        int head, tail;
        while (cin &gt;&gt; head &gt;&gt; tail)
        {
            //无向图head-&gt;tail tail-&gt;head插入两次
            Insert(head, tail, 0);
            Insert(tail, head, 0);
        }
    }

    void FindMinRoad(int v1, int v2, int k)
    {

    }

private:
    struct ArcNode
    {
        int vertexIndex;        //该路径指向的顶点位置
        struct ArcNode* next;    //指向下一个路径
        InfoType info;            //该路径的相关信息，如权重等
    };

    struct Vertex
    {
        VertexType data;    //顶点信息
        ArcNode* firstArc;    //指向第一条依附该节点路径的指针
        visitCondition visitconditions;    //访问情况
    };

    //最大顶点数
    static const int MAX_VERTEX_NUM = 20;
    Vertex m_vertices[MAX_VERTEX_NUM];    //顶点列表
    int m_vertexNum;    //当前顶点数量
    int m_arcNum;        //当前路径数量
private:
    //初始化顶点列表
    void InitVertices()
    {
        cout &lt;&lt; &quot;请输入每个顶点的关键字&quot; &lt;&lt; endl;
        VertexType data;
        for (int i = 0; i &lt; m_vertexNum; ++i)
        {
            cin &gt;&gt; data;
            m_vertices[i].data = data;
        }
    }
    //插入一个表节点
    void Insert(int headVertex, int tailVertex, InfoType info)
    {
        //构造一个邻接表节点，即创建一条路径
        ArcNode* newNode = new ArcNode;
        newNode-&gt;info = info;
        newNode-&gt;next = nullptr;
        newNode-&gt;vertexIndex = tailVertex;

        //找到邻接表的最后一个节点
        ArcNode* lastNode = m_vertices[headVertex].firstArc;
        if (lastNode == nullptr)
            m_vertices[headVertex].firstArc = newNode;
        else
        {
            while (lastNode-&gt;next)
            {
                lastNode = lastNode-&gt;next;
            }
            lastNode-&gt;next = newNode;
        }
        ++m_arcNum;
    }

    void BFS(Vertex* vertex)
    {
        vertex-&gt;visitconditions = visiting;
        queue&lt;Vertex*&gt; vertices;
        vertices.push(vertex);
        while (!vertices.empty())
        {
            Vertex* curVertex = vertices.front();
            vertices.pop();
            cout &lt;&lt; curVertex-&gt;data &lt;&lt; &quot;-&gt;&quot;;
            ArcNode* node = curVertex-&gt;firstArc;
            while (node)
            {
                Vertex* tmpVertex = &amp;m_vertices[node-&gt;vertexIndex];
                if (tmpVertex-&gt;visitconditions == no)
                {
                    tmpVertex-&gt;visitconditions = visiting;
                    vertices.push(tmpVertex);
                }
                node = node-&gt;next;
            }
            curVertex-&gt;visitconditions = yes;
        }
    }

    void DFS(Vertex* vertex)
    {
        vertex-&gt;visitconditions = visiting;
        stack&lt;Vertex*&gt; vertices;
        vertices.push(vertex);
        while (!vertices.empty())
        {
            Vertex* curVertex = vertices.top();
            vertices.pop();
            cout &lt;&lt; curVertex-&gt;data &lt;&lt; &quot;-&gt;&quot;;
            ArcNode* node = curVertex-&gt;firstArc;
            while (node)
            {
                Vertex* tmp = &amp;m_vertices[node-&gt;vertexIndex];
                if (tmp-&gt;visitconditions == no)
                {
                    tmp-&gt;visitconditions = visiting;
                    vertices.push(tmp);
                }
                node = node-&gt;next;
            }
            curVertex-&gt;visitconditions = yes;
        }
    }
};

int main()
{
    int  vertexNum, v1, v2 , k;
    cout &lt;&lt; &quot;请输入要创建的图的节点数：&quot;;
    cin &gt;&gt; vertexNum;
    Graph&lt;char, int&gt; g(vertexNum);
    g.Create();
    g.Display();
    g.BFS();
    g.DFS();
    //cout &lt;&lt; &quot;请依次输入需要寻找简单路径的起点和重点v1 v2和路径长度k：&quot;;
    //cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; k;
    //g.FindMinRoad(v1, v2, k);
}</code></pre>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/12/05/利用邻接表储存无向非连通图并利用DFS和BFS遍历图的邻接表">https://zam9036.gitee.io/2019/12/05/利用邻接表储存无向非连通图并利用DFS和BFS遍历图的邻接表</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>课程实验</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后拓展—利用DFS深度优先搜索算法解决N皇后问题|Zam9036的博客</title>
    <url>/2019/12/03/%E5%85%AB%E7%9A%87%E5%90%8E%E6%8B%93%E5%B1%95%E2%80%94%E5%88%A9%E7%94%A8DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><p>​    C++</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过求解皇后问题，熟悉深度优先搜索法DFS（回溯法（Backtracking Algorithms）技术。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>由n*n个方块排成n行n列的正方形称为n元棋盘。如果两个皇后位于n元棋盘上的同一行、同一列或同一对角线上，则称它们在互相攻击。现要找出使棋盘上n个皇后互不攻击的布局。</p>
<h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>用一维数组代表皇后，其中角标代表皇后的序数，数组元素的值代表皇后的列位置，用深度优先搜索法DFS（回溯法（Backtracking Algorithms）技术求解N皇后的所有不冲突放置方法。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>分别求解8皇后和12皇后的不冲突放置方法</p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="数据结构详细设计"><a href="#数据结构详细设计" class="headerlink" title="数据结构详细设计"></a>数据结构详细设计</h2><p>用一维数组代表皇后，其中角标代表皇后的序数，数组元素的值代表皇后的列位置，用深度优先搜索法DFS（回溯法Backtracking Algorithms）技术求解N皇后的所有不冲突放置方法。</p>
<p>首先定义一维数组，利用for循环对所有皇后的位置进行初始化。然后开始比较循环。用双层嵌套循环实现皇后的循环比较过程，每完成一次第一层循环将摆好一个皇后，利用二层循环来对单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，该皇后列位置向下移动一格。</p>
<h2 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h2><p>详细内容说明见注释</p>
<pre><code class="c++">while (true) // 开始循坏
    {
        for (int i = 0; i &lt; N; i++) // 一层循环，每次循环完成摆好一个皇后（行循环）
            {
                for (int j = 0 ; j &lt; i ; j++) // 二层循环，单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，列位置向下移动一格
                {
                    if (A[i] &gt;= N) // 皇后超出棋盘
                    {
                        A[i] = 0;
                        A[i - 1]++;
                        i--;
                        j = -1;
                    }
                    else if (!checkQueens(i,j)&amp;&amp;(i != 0)) // 检查皇后是否与已摆好的皇后冲突
                    {
                        A[i]++;
                        j = -1;
                    }
                }
            }
        // 当第一个皇后到达棋盘底端时结束程序
        if (A[0] &gt; N - 1) {
            break;
        }
        for (int e = 0; e &lt; N; e++) // 打印结果
        {
            cout &lt;&lt; &quot;(&quot; &lt;&lt; e &lt;&lt; &quot;,&quot; &lt;&lt; A[e] &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        num++;A[N-1]++;
    }</code></pre>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><p><img src="/img/postimg/%E5%85%AB%E7%9A%87%E5%90%8E%E6%8B%93%E5%B1%95%E2%80%94%E5%88%A9%E7%94%A8DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/1.png" alt="8皇后"></p>
<p><img src="/img/postimg/%E5%85%AB%E7%9A%87%E5%90%8E%E6%8B%93%E5%B1%95%E2%80%94%E5%88%A9%E7%94%A8DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/2.png" alt="12皇后"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="循环边界条件不清"><a href="#循环边界条件不清" class="headerlink" title="循环边界条件不清"></a>循环边界条件不清</h3><p>解决方法：对程序进行逐行调试，在运行循环判断时稍事等待，思考判断条件。</p>
<h1 id="使用说明和测试结果"><a href="#使用说明和测试结果" class="headerlink" title="使用说明和测试结果"></a>使用说明和测试结果</h1><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>用Visual Studio打开.sln文件即可运行</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过，符合程序设计要求和需求分析</p>
<p>详细结果见调试分析-示例测试</p>
<h1 id="体会心得"><a href="#体会心得" class="headerlink" title="体会心得"></a>体会心得</h1><p>通过本次课程实验，我对数据结构的了解进一步加深，并产生了浓厚的兴趣。虽然在写代码过程中遇到了一些问题，但我通过思考、网上找资料、询问同学等方式最终解决了问题。这次实验让我进一步理解了深度优先搜索法DFS（回溯法Backtracking Algorithms）技术的原理，锻炼了我静心逐行调试代码的能力，并且熟悉了C++的语法，进一步加强了自学能力，拓展了思路。</p>
<h1 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h1><h2 id="EQ-h"><a href="#EQ-h" class="headerlink" title="EQ.h"></a>EQ.h</h2><pre><code class="c++">#pragma once

#include &lt;iostream&gt; // 导入库
using namespace std; // 使用标准命名空间

#define N 12 // 设置皇后个数

bool checkQueens(int i, int j); // 判断皇后冲突的函数</code></pre>
<h2 id="EightQueens-cpp"><a href="#EightQueens-cpp" class="headerlink" title="EightQueens.cpp"></a>EightQueens.cpp</h2><pre><code class="c++">#include &quot;EQ.h&quot;; // 导入头文件

int A[N]; // 用一维数组代表皇后

int main()
{
    int num = 0; // 解法计数器
    int checknum = 0; // 判断皇后冲突用的数值计数器
    for (int i = 0; i &lt; N; i++) // 初始化皇后位置
    {
        A[i] = 0;
    }
    while (true) // 开始循坏
    {
        for (int i = 0; i &lt; N; i++) // 一层循环，每次循环完成摆好一个皇后（行循环）
            {
                for (int j = 0 ; j &lt; i ; j++) // 二层循环，单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，列位置向下移动一格
                {
                    if (A[i] &gt;= N) // 皇后超出棋盘
                    {
                        A[i] = 0;
                        A[i - 1]++;
                        i--;
                        j = -1;
                    }
                    else if (!checkQueens(i,j)&amp;&amp;(i != 0)) // 检查皇后是否与已摆好的皇后冲突
                    {
                        A[i]++;
                        j = -1;
                    }
                }
            }
        // 当第一个皇后到达棋盘底端时结束程序
        if (A[0] &gt; N - 1) {
            break;
        }
        for (int e = 0; e &lt; N; e++) // 打印结果
        {
            cout &lt;&lt; &quot;(&quot; &lt;&lt; e &lt;&lt; &quot;,&quot; &lt;&lt; A[e] &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        num++;A[N-1]++;
    }
    printf(&quot;%d个皇后，不考虑棋盘对称性，共%d种解法\n&quot;,N,num); // 提示语
    return 0;
}

bool checkQueens(int i ,int j) {
    if ((A[i] + i == A[j] + j) || (A[i] == A[j]) || (A[i] - i == A[j] - j)) // 皇后冲突
    {
        return false;
    }
    else // 皇后不冲突
    {
        return true;
    }
}</code></pre>
<h1 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h1><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/12/03/八皇后拓展—利用DFS深度优先搜索算法解决N皇后问题">https://zam9036.gitee.io/2019/12/03/八皇后拓展—利用DFS深度优先搜索算法解决N皇后问题</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>课程实验</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-4|Zam9036的博客</title>
    <url>/2019/11/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/</url>
    <content><![CDATA[<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="类和对象的特性"><a href="#类和对象的特性" class="headerlink" title="类和对象的特性"></a>类和对象的特性</h3><h4 id="31、利用面向对象的思想求解长方体体积"><a href="#31、利用面向对象的思想求解长方体体积" class="headerlink" title="31、利用面向对象的思想求解长方体体积"></a>31、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，分别为r1, r2, r3，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求有序输出三个长方体的体积。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/31.jpg" alt="输出样例31"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box r1(a, b, c), r2(d, e, f), r3(g, h, i);
    box arr[3];
    arr[0] = r1;
    arr[1] = r2;
    arr[2] = r3;
    box *bp = arr;
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h4 id="32、构造函数与析构函数"><a href="#32、构造函数与析构函数" class="headerlink" title="32、构造函数与析构函数"></a>32、构造函数与析构函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义圆类Circle，利用类的复合（组合）定义圆柱类Column，然后创建圆柱类Column的实例化对象。</p>
<p>圆类Circle包含两个部分：</p>
<p>一、私有数据：点坐标x，y，半径r。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、area函数：计算圆的面积。</p>
<p>4、print函数：输出点坐标x，y及半径r的值。</p>
<p>圆柱类Column包含两个部分：</p>
<p>一、私有数据：</p>
<p>1、类Circle的对象circle。</p>
<p>2、圆柱高height。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、volume函数：计算圆柱的体积。要求使用circle.area（）。</p>
<p>4、print函数：输出点坐标x，y及半径r的值。</p>
<p>注：圆周率取3.14159</p>
<p>部分代码已在下面给出，要求不能改动已有代码</p>
<pre><code class="c++">int main()
{
Column obj(2.3,3.4,4.5,5.6);
cout&lt;&lt;&quot;The volume of obj is &quot;&lt;&lt;obj.volume()&lt;&lt;endl;
return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/32.jpg" alt="输出样例32"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Circle
{
public:
    Circle(double, double, double);
    ~Circle();
    float area();
    void print();

private:
    double x;
    double y;
    double r;
};

class Column
{
public:
    Column(double, double, double, double);
    ~Column();
    float volume();
    void print();

private:
    Circle circle;
    double height;
};

Circle::Circle(double a, double b, double c)
{
    x = a;
    y = b;
    r = c;
    cout &lt;&lt; &quot;Circle object start:&quot;
         &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

Circle::~Circle()
{
    cout &lt;&lt; &quot;Circle object end:x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

float Circle::area()
{
    return (3.14159 * r * r);
}

void Circle::print()
{
    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; &quot;,r=&quot; &lt;&lt; r &lt;&lt; endl;
}

Column::Column(double h, double a, double b, double c) : circle(a, b, c)
{
    height = h;
    cout &lt;&lt; &quot;Column object start:height=&quot; &lt;&lt; height &lt;&lt; &quot;,&quot;;
    circle.print();
}

Column::~Column()
{
    cout &lt;&lt; &quot;Column object end:height=&quot; &lt;&lt; height &lt;&lt; &quot;,&quot;;
    circle.print();
}

float Column::volume()
{
    float m;
    m = circle.area();
    return (m * height);
}

int main()
{
    Column obj(2.3, 3.4, 4.5, 5.6);
    cout &lt;&lt; &quot;The volume of obj is &quot; &lt;&lt; obj.volume() &lt;&lt; endl;
    return 0;
}</code></pre>
<h4 id="33、编写一个音响资料类Media，要求包含音像资料基本信息。"><a href="#33、编写一个音响资料类Media，要求包含音像资料基本信息。" class="headerlink" title="33、编写一个音响资料类Media，要求包含音像资料基本信息。"></a>33、编写一个音响资料类Media，要求包含音像资料基本信息。</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>Media包含两个部分：</p>
<p>一、私有数据：名称name、种类type。</p>
<p>二、公有函数：所有函数要求类外定义 编写一个音响资料类Media，要求包含音像资料基本信息。</p>
<p>Media包含两个部分：</p>
<p>一、私有数据：名称name、种类type。</p>
<p>二、公有函数：所有函数要求类外定义</p>
<p>1、构造函数。</p>
<p>2、析构函数。</p>
<p>3、setType函数：设置type的值。</p>
<p>4、函数：输出媒体资料的基本信息，要求见下表</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/33-1.jpg" alt="输出样例33-1"></p>
<p>测试函数main如下，要求不能改动main函数：</p>
<pre><code class="c++">#define ISAUDIO 1
#define ISVIDEO 2
int main()
{
 Media discDion(&quot;The Colour of My Love &quot;),discHanks(&quot;Forrest Gump &quot;);
 discDion.setType(ISAUDIO);
 discHanks.setType(ISVIDEO);
 discDion.showInfo ();
 discHanks.showInfo ();
 return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/33-2.jpg" alt="输出样例33-2"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#define ISAUDIO 1
#define ISVIDEO 2
using namespace std;

class Media
{
private:
    string name;
    int type;

public:
    Media();
    Media(string a);
    ~Media();
    void setType(int a);
    void showInfo();
};
Media::Media(string a)
{
    name = a;
}
Media::Media()
{
    name = &quot;&quot;;
    type = 0;
}
Media::~Media()
{
}
void Media::setType(int a)
{
    type = a;
}
void Media::showInfo()
{
    if (type == 1)
        cout &lt;&lt; &quot;The Colour of My Love is a &quot;
             &lt;&lt; &quot;audio disc&quot;
             &lt;&lt; &quot;.&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;Forrest Gumpis a &quot;
             &lt;&lt; &quot;video disc&quot;
             &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}

int main()
{
    Media discDion(&quot;The Colour of My Love &quot;), discHanks(&quot;Forrest Gump &quot;);
    discDion.setType(ISAUDIO);
    discHanks.setType(ISVIDEO);
    discDion.showInfo();
    discHanks.showInfo();
    return 0;
}</code></pre>
<h4 id="34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）"><a href="#34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）" class="headerlink" title="34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）"></a>34、请对如下定义的表示一个矩形的Rectangle类进行补全（不允许改动已有代码）</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code class="c++">class Rectangle {
private:
    double width, height;
public:
    Rectangle ( double w = 0., double h = 0.) : width(w), height(h) { }
//请补全必要代码
};</code></pre>
<p>使得如下的函数能够正确地按照每个Rectangle对象的面积从小到大进行排序，并且main函数能通过编译且运行后能够得到样例输出。（请将下列代码复制到你补全后的Rectangle类之后，一并提交。）  </p>
<pre><code class="c++">template&lt;typename T&gt;
void insertSort(T *ptr, int size) {
    for(int i = 1; i &lt; size; ++i) {
        for( int j = i; j &gt; 0; --j) {
            if( ptr[j] &lt; ptr[j - 1]) {
                T temp = ptr[j];
                ptr[j ] = ptr[j - 1];
                ptr[j - 1] = temp;
            }
            else
                break;
        }
    }
}

int main () {
    Rectangle data[4];
    data[0] = Rectangle(1,2);
    data[1] = Rectangle(5,7);
    data[2] = Rectangle(2,8);
    data[3] = Rectangle(3,4);
    for(int i = 0; i &lt; 4; ++i) {
           printf(&quot;%f,&quot;, data[i].getArea());
     }
    printf(&quot;\n&quot;);
    insertSort( data, 4);
    for(int i = 0; i &lt; 4; ++i) {
           printf(&quot;%f,&quot;, data[i].getArea());
    }
        return 1;
}</code></pre>
<p>注：模板必须使用<code>template&lt;typename T&gt;</code><br>测试用例：</p>
<pre><code class="c++">//输入：
    Rectangle data[4];
    data[0] = Rectangle(1,2);
    data[1] = Rectangle(5,7);
    data[2] = Rectangle(2,8);
    data[3] = Rectangle(3,4);</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-4/34.jpg" alt="输出样例34"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class Rectangle
{
private:
    double width, height;

public:
    Rectangle(double w = 0, double h = 0) : width(w), height(h) {}
    double getArea()
    {
        return width * height;
    }
    friend bool operator&lt;(Rectangle a, Rectangle b)
    {
        if (a.getArea() &gt; b.getArea())
            return 0;
        else
            return 1;
    }
};

template &lt;typename T&gt;
void insertSort(T *ptr, int size)
{
    for (int i = 1; i &lt; size; ++i)
    {
        for (int j = i; j &gt; 0; --j)
        {
            if (ptr[j] &lt; ptr[j - 1])
            {
                T temp = ptr[j];
                ptr[j] = ptr[j - 1];
                ptr[j - 1] = temp;
            }
            else
                break;
        }
    }
}

int main()
{
    Rectangle data[4];
    data[0] = Rectangle(1, 2);
    data[1] = Rectangle(5, 7);
    data[2] = Rectangle(2, 8);
    data[3] = Rectangle(3, 4);
    for (int i = 0; i &lt; 4; ++i)
    {
        printf(&quot;%f,&quot;, data[i].getArea());
    }
    printf(&quot;\n&quot;);
    insertSort(data, 4);
    for (int i = 0; i &lt; 4; ++i)
    {
        printf(&quot;%f,&quot;, data[i].getArea());
    }
    return 0;
}</code></pre>
<h4 id="35、通过重载运算符来模拟时间"><a href="#35、通过重载运算符来模拟时间" class="headerlink" title="35、通过重载运算符来模拟时间"></a>35、通过重载运算符来模拟时间</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个Time类，包含数据成员minute（分）和sec（秒），模拟秒表，每次走一秒，满60秒进一分钟，此时秒又从0起算，要求输出分和秒的值。</p>
<p>已有如下的main函数，要求编写能支持该main函数的Time类。</p>
<pre><code class="c++">int main()
{
    Time time1(34,50);
    for(int i = 0; i &lt; 20; i++)
    {
        ++time1;
        time1.display();
    }
    return 0;
}</code></pre>
<pre><code class="控制台">//输出样例35
34:51
34:52
34:53
34:54
34:55
34:56
34:57
34:58
34:59
35:0
35:1
35:2
35:3
35:4
35:5
35:6
35:7
35:8
35:9
35:10</code></pre>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Time
{
private:
    int minute, sec;

public:
    Time(int a, int b)
    {
        if (b &gt; 59)
        {
            minute = a + 1;
            sec = b - 60;
        }
        else
        {
            minute = a;
            sec = b;
        }
    }
    Time()
    {
        minute = 0;
        sec = 0;
    }
    void display()
    {
        cout &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; sec &lt;&lt; endl;
    }
    friend operator++(Time &amp;a)
    {
        a.sec++;
        if (a.sec &gt; 59)
        {
            a.minute = a.minute + 1;
            a.sec = a.sec - 60;
        }
    }
};

int main()
{
    Time time1(34, 50);
    for (int i = 0; i &lt; 20; i++)
    {
        ++time1;
        time1.display();
    }
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/24/面向对象技术题型归类示例-4">https://zam9036.gitee.io/2019/11/24/面向对象技术题型归类示例-4</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-3|Zam9036的博客</title>
    <url>/2019/11/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/</url>
    <content><![CDATA[<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h3><h4 id="21、定义复数类，并使用运算符重载来实现其功能"><a href="#21、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="21、定义复数类，并使用运算符重载来实现其功能"></a>21、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符+，使之能用于复数的加法。运算符的重载函数作为Complex类的成员函数，求两个复数的和。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/21.jpg" alt="输出样例21"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 + c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="22、重载运算符使之能进行复数的运算"><a href="#22、重载运算符使之能进行复数的运算" class="headerlink" title="22、重载运算符使之能进行复数的运算"></a>22、重载运算符使之能进行复数的运算</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>下面是一个用来表达复数的类Complex的部分代码.该类包含两个私有double型成员变量，分别代表复数的实部和虚部，默认为0。</p>
<pre><code class="c++">class Complex {
private:
    double real;
    double img;
public:
//..
Complex operator + (const Complex &amp; other) //….
};</code></pre>
<p>请按要求补全该类其他代码。</p>
<p>该类需有完备的类构造函数，至少支持Complex a; Complex b(a); Complex c(4, 5); 这三种定义Complex类对象的方式。重载操作符+, +=, <em>, 分别完成两个复数的加法和乘法，其中操作符</em>的重载必须用友元函数的形式完成。</p>
<p>补全该类后，对于如下的main函数，要求其能通过编译，并正常运行。</p>
<pre><code class="c++">int main () {
    Complex c2(2., 3.), c3 = c2 + Complex(1., 2.),c1(c2);
    Complex c4;
    c4 += c2 * c3 + c2;
    cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; c3 &lt;&lt; c4;
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/22.jpg" alt="输出样例22"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Complex
{
private:
    double real;
    double img;

public:
    Complex(double real = 0, double img = 0);
    Complex(const Complex &amp;c2)
    {
        real = c2.real;
        img = c2.img;
    }
    Complex operator+(const Complex &amp;other)
    {
        Complex c;
        c.real = real + other.real;
        c.img = img + other.img;
        return c;
    }
    Complex operator+=(const Complex &amp;c1)
    {
        *this = *this + c1;
        return *this;
    }
    friend Complex operator*(Complex &amp;c1, Complex &amp;c2)
    {
        return Complex((c1.real * c2.real - c1.img * c2.img), (c1.img * c2.real + c1.real * c2.img));
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, Complex &amp;c)
    {
        if (c.img &gt;= 0)
            output &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.img &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c.real &lt;&lt; c.img &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};
Complex::Complex(double a, double b)
{
    real = a;
    img = b;
}
int main()
{
    Complex c2(2., 3.), c3 = c2 + Complex(1., 2.), c1(c2);
    Complex c4;
    c4 += c2 * c3 + c2;
    cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; c3 &lt;&lt; c4;
    return 0;
}</code></pre>
<h3 id="类和对象的特性"><a href="#类和对象的特性" class="headerlink" title="类和对象的特性"></a>类和对象的特性</h3><h4 id="23、将普通函数声明为友元并使用它输出日期与时间"><a href="#23、将普通函数声明为友元并使用它输出日期与时间" class="headerlink" title="23、将普通函数声明为友元并使用它输出日期与时间"></a>23、将普通函数声明为友元并使用它输出日期与时间</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>顺序定义时间类Time与日期类Date。其中，Time拥有私有数据hour, minute, second，以及友元函数display；Date拥有私有数据day, month, year，以及友元函数display。在类外定义display函数并实现它，display函数接收一个Time类和一个Date类的引用，并将其按照格式输出。 运行时依次从键盘输入day, month, year,hour, minute, second，最后调用display函数将其全部按格式输出。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/23.jpg" alt="输出样例23"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Date;
class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    friend void display(Date &amp;d, Time &amp;t);
};
class Date
{
private:
    int day, month, year;

public:
    Date(int a, int b, int c)
    {
        day = a;
        month = b;
        year = c;
    }
    friend void display(Date &amp;d, Time &amp;t);
};

void display(Date &amp;d, Time &amp;t)
{
    cout &lt;&lt; d.day &lt;&lt; &quot;/&quot; &lt;&lt; d.month &lt;&lt; &quot;/&quot; &lt;&lt; d.year &lt;&lt; &quot;&quot; &lt;&lt; t.hour &lt;&lt; &quot;:&quot; &lt;&lt; t.minute &lt;&lt; &quot;:&quot; &lt;&lt; t.second &lt;&lt; endl;
}

int main()
{
    int a, b, c, d, e, f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;
    Time t(d, e, f);
    Date dd(a, b, c);
    display(dd, t);
    return 0;
}</code></pre>
<h4 id="24、使用友元成员函数输出日期与时间"><a href="#24、使用友元成员函数输出日期与时间" class="headerlink" title="24、使用友元成员函数输出日期与时间"></a>24、使用友元成员函数输出日期与时间</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>顺序声明时间类Time与日期类Date。其中Time拥有私有数据hour, minute, second，以及公有函数display(接收一个Date的引用作为参数)；Date拥有私有数据day, month, year，以及友元函数display(要求声明Time中的display函数为Date的友元成员函数)。运行时依次从键盘输入day, month, year,hour, minute, second，最后调用Time的display函数将其全部按格式输出。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/24.jpg" alt="输出样例24"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Date;
class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    void display(Date &amp;t);
};
class Date
{
private:
    int day, month, year;

public:
    Date(int a, int b, int c)
    {
        day = a;
        month = b;
        year = c;
    }
    friend void Time::display(Date &amp;);
};

void Time::display(Date &amp;t)
{
    cout &lt;&lt; t.day &lt;&lt; &quot;/&quot; &lt;&lt; t.month &lt;&lt; &quot;/&quot; &lt;&lt; t.year &lt;&lt; &quot;&quot; &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; endl;
}

int main()
{
    int a, b, c, d, e, f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;
    Time t(d, e, f);
    Date dd(a, b, c);
    t.display(dd);
    return 0;
}</code></pre>
<h4 id="25、使用友元函数输出时间"><a href="#25、使用友元函数输出时间" class="headerlink" title="25、使用友元函数输出时间"></a>25、使用友元函数输出时间</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一时间类Time，拥有私有成员hour, minute, second，以及一友元函数display。display以引用的方式接收一个Time对象，并以hour:minute:second的格式来输出时间。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/25.jpg" alt="输出样例25"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Time
{
private:
    int hour, minute, second;

public:
    Time(int a, int b, int c)
    {
        hour = a;
        minute = b;
        second = c;
    }
    friend void display(Time &amp;t)
    {
        cout &lt;&lt; t.hour &lt;&lt; &quot;:&quot; &lt;&lt; t.minute &lt;&lt; &quot;:&quot; &lt;&lt; t.second;
    }
};

int main()
{
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    Time t(a, b, c);
    display(t);
    return 0;
}</code></pre>
<h4 id="26、使用指针传参找到成绩最高的学生"><a href="#26、使用指针传参找到成绩最高的学生" class="headerlink" title="26、使用指针传参找到成绩最高的学生"></a>26、使用指针传参找到成绩最高的学生</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(共5人，其类名为Student)的数据需要存放，包括私有数据成绩(名为score)，数据从键盘输入。要求使用名为arr的对象静态数组存放这5个学生的数据，并使用名为sp的对象指针指向其对象数组的首地址（要求使用取地址符），最后将该指针传递给max函数(指针在max中的形参名为p)，找出5个学生中成绩最高者并输出其成绩。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/26.jpg" alt="输出样例26"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    friend Student max(Student *p);
    void display()
    {
        cout &lt;&lt; score;
    }
};

Student max(Student *p)
{
    Student s;
    for (int i; i &lt; 5; i++, p++)
        if (s.score &lt; p-&gt;score)
        {
            s = *p;
        }
    return s;
}

int main()
{
    int a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
    Student s1(a), s2(b), s3(c), s4(d), s5(e);
    Student arr[5];
    arr[0] = s1;
    arr[1] = s2;
    arr[2] = s3;
    arr[3] = s4;
    arr[4] = s5;
    Student *sp;
    sp = &amp;arr[0];
    Student aa = max(sp);
    aa.display();
    return 0;
}</code></pre>
<h4 id="27、用指针输出学生信息"><a href="#27、用指针输出学生信息" class="headerlink" title="27、用指针输出学生信息"></a>27、用指针输出学生信息</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(共5人，其类名为Student)的数据需要存放，包括私有数据成绩(名为score)，数据从键盘输入。要求使用名为arr的对象数组（要求动态分配）存放这5个学生的数据，并使用名为sp的对象指针指向其对象数组的首地址（要求使用取地址符），随后有序输出第1、3、5个学生的数据。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/27.jpg" alt="输出样例27"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    void display()
    {
        cout &lt;&lt; score &lt;&lt; &quot; &quot;;
    }
};

int main()
{
    int a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
    Student s1(a), s2(b), s3(c), s4(d), s5(e);
    Student *arr = new Student[5];
    if (!arr)
        cout &lt;&lt; &quot;内存分配失败&quot;;
    else
    {
        arr[0] = s1;
        arr[1] = s2;
        arr[2] = s3;
        arr[3] = s4;
        arr[4] = s5;
        Student *sp;
        sp = &amp;arr[0];
        sp-&gt;display();
        (sp + 2)-&gt;display();
        (sp + 4)-&gt;display();
        delete[] sp;
        sp = NULL;
    }
    return 0;
}</code></pre>
<h4 id="28、统计学生平均成绩，要求使用静态成员函数"><a href="#28、统计学生平均成绩，要求使用静态成员函数" class="headerlink" title="28、统计学生平均成绩，要求使用静态成员函数"></a>28、统计学生平均成绩，要求使用静态成员函数</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一批学生(其类名为Student)成绩(均为整数)需要统计，要求使用类内静态公有函数(函数名为average)求出这批学生的平均成绩(学生人数并不确定)。在输入成绩时，先输入一个整数，表示学生总人数，然后再输入相应个数学生成绩，并将这些数据都存入一个名为arr的数组中,该数组必须使用new动态开辟，最后输出学生的平均成绩。(结果要求保留1位小数，检测内存分配是否成功需使用NULL)</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/28.jpg" alt="输出样例28"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class Student
{
private:
    int score;

public:
    Student(int a)
    {
        score = a;
    }
    Student()
    {
        score = 0;
    }
    int get()
    {
        return score;
    }
    static float average(int n, Student arr[])
    {
        int a;
        for (int i = 0; i &lt; n; i++)
        {
            a += arr[i].get();
        }
        return (float)a / n;
    }
};

int main()
{
    int a, b;
    cin &gt;&gt; a;
    Student *arr = new Student[a];
    for (int i; i &lt; a; i++)
    {
        cin &gt;&gt; b;
        arr[i] = Student(b);
    }
    if (arr == NULL)
        cout &lt;&lt; &quot;xx&quot;;
    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1);
    cout &lt;&lt; Student::average(a, arr);

    delete arr;
    return 0;
}</code></pre>
<h4 id="29、利用面向对象的思想求解长方体体积"><a href="#29、利用面向对象的思想求解长方体体积" class="headerlink" title="29、利用面向对象的思想求解长方体体积"></a>29、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，存储在一个名为arr的静态对象数组中，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求使用名为bp的指针指向这个数组的首地址（要求使用数组名），并有序输出三个长方体的体积，体积的计算须使用volume函数。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/29.jpg" alt="输出样例29"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box a1(a, b, c), a2(d, e, f), a3(g, h, i);
    box arr[3];
    arr[0] = a1;
    arr[1] = a2;
    arr[2] = a3;
    box *bp = arr;
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h4 id="30、利用面向对象的思想求解长方体体积"><a href="#30、利用面向对象的思想求解长方体体积" class="headerlink" title="30、利用面向对象的思想求解长方体体积"></a>30、利用面向对象的思想求解长方体体积</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个长方体类，其类名为box, 其私有数据成员包括length(长)、width(宽)、height(高)以及一个名为volume的公有成员函数，volume函数用来计算长方体的体积。现有3个长方体，存储在一个名为arr的静态对象数组中，3个长方体的长、宽、高(三者均为整数)从键盘分别输入，要求有序输出三个长方体的体积。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-3/30.jpg" alt="输出样例30"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class box
{
private:
    int length, width, height;

public:
    box(int a, int b, int c) : length(a), width(b), height(c)
    {
    }
    box() : length(0), width(0), height(0)
    {
    }
    int volume()
    {
        return height * length * width;
    }
};
int main()
{
    int a, b, c, d, e, f, g, h, i;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; i;
    box a1(a, b, c), a2(d, e, f), a3(g, h, i);
    box arr[3];
    arr[0] = a1;
    arr[1] = a2;
    arr[2] = a3;
    box *bp;
    bp = &amp;arr[0];
    cout &lt;&lt; bp[0].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[1].volume() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; bp[2].volume() &lt;&lt; &quot; &quot;;
    bp = NULL;
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/20/面向对象技术题型归类示例-3">https://zam9036.gitee.io/2019/11/20/面向对象技术题型归类示例-3</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHubPages个人博客迁移至码云从而加快博客访问速度</title>
    <url>/2019/11/16/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GitHubPages部署静态网页十分方便与快捷，常常被用来建立个人博客。但因为其服务器设在国外，且曾经被中国防火长城GFW屏蔽（后来解除屏蔽），导致其访问速度十分缓慢，甚至极少数状态下出现访问出错的状况，极大影响了博客的使用体验。所以我近期尝试将GitHub的Hexo博客迁移至国内码云，以解决博客访问过于缓慢的情况。</p>
<h2 id="迁移流程"><a href="#迁移流程" class="headerlink" title="迁移流程"></a>迁移流程</h2><h3 id="建立码云仓库"><a href="#建立码云仓库" class="headerlink" title="建立码云仓库"></a>建立码云仓库</h3><p>创建码云账号的流程我在此就不过多赘述了，根据提示操作即可，下面我来说一下建立码云仓库的操作。码云的仓库建立机制和GitHub一样，只需要新建仓库然后填写信息即可，其中仓库名字尤为关键。码云的静态资源托管平台可以托管用户的任意仓库，不必像GitHub那样仓库名必须和用户名一致才可。用户创建任意仓库，然后点击<code>服务-GiteePages</code>即可开启该仓库的静态资源托管服务。</p>
<p><img src="/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/1.jpg" alt="开启Page服务"></p>
<p>但是！在这里建议大家仓库名仍使用和自己码云用户名相同的名称！！因为当博客仓库名与自己的个性地址不一致时，博客部署完成后会存在一些资源访问404。原因是当需要部署的仓库和自己的个性地址不一致时，如：<a href="https://gitee.com/ipvb/blog" target="_blank" rel="noopener">https://gitee.com/ipvb/blog</a> ，生成的pages url 为 <a href="https://ipvb.gitee.io/blog" target="_blank" rel="noopener">https://ipvb.gitee.io/blog</a> ，而访问的资源404，如 <a href="https://ipvb.gitee.io/style.css" target="_blank" rel="noopener">https://ipvb.gitee.io/style.css</a> 这是相应配置文件的相对路径存在问题导致的，生成的资源 url 应该为 <a href="https://ipvb.gitee.io/blog/style.css" target="_blank" rel="noopener">https://ipvb.gitee.io/blog/style.css</a> 才对。 而针对这个问题官方给出了解决方案。</p>
<blockquote>
<p>对于不同的静态资源生成器，配置如下： </p>
<ul>
<li><p>Hugo 配置文件config.toml的baseURL修改如下</p>
<pre><code>baseURL = &quot;https://ipvb.gitee.io/blog&quot;</code></pre></li>
<li><p>Hexo 配置文件_config.yml的url和root修改如下：</p>
<pre><code>url: https://ipvb.gitee.io/blog
root: /blog</code></pre></li>
<li><p>Jekyll配置文件_config.yml的baseurl修改如下：</p>
<pre><code>baseurl: &quot;/blog&quot; # the subpath of your site, e.g. /blog</code></pre></li>
</ul>
</blockquote>
<p>但是！！按照这个做法，博客的Js等文件能够加载，本地的图片等文件无法加载，设置完成后点击图片会按照未修改的链接跳转导致404。</p>
<p>所以多一事不如少一事，我们直接创建一个和用户名相同的仓库，这样就可以直接跳过二级目录，通过<code>用户名.gitee.io</code>直接访问博客。</p>
<p>另外，码云的静态资源托管功能可以托管Jekyll、Hugo、Hexo编译的静态资源。</p>
<blockquote>
<p>Jekyll、Hugo、Hexo 编译判断依据</p>
<ol>
<li>编译 Hugo 依据：仓库编译目录下存在<code>config.toml|json|yaml</code>文件和<code>content</code>目录的时候，会使用<code>hugo</code>生成静态文件。</li>
<li>编译 Hexo 依据：仓库编译目录下存在<code>package.json</code>，<code>_config.yml</code>文件和<code>scaffolds</code>目录的，会使用<code>hexo generate</code>生成静态文件，由于每次部署编译需要重新克隆编译并进行<code>npm install</code>，所以使用 Hexo 的时间相对 Hugo 和 Jekyll 会长一些。</li>
<li>当不符合上述1和2条件的时候，就默认使用Jekyll编译。</li>
</ol>
</blockquote>
<h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><p>与GitHub配置SSH一致，遇有疑问请访问<a href="https://zam9036.gitee.io/2019/10/23/利用GitHub+Hexo搭建个人博客详细教程">利用GitHub+Hexo搭建个人博客详细教程</a>。当然，使用当时GitHub建立的SSH就可以。</p>
<h3 id="修改Hexo配置"><a href="#修改Hexo配置" class="headerlink" title="修改Hexo配置"></a>修改Hexo配置</h3><p>找到Hexo配置文件_config.yml，注意不是主题配置文件。</p>
<p><img src="/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/2.jpg" alt="Hexo配置文件"></p>
<p>找到以下语句</p>
<pre><code class="yml"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:</code></pre>
<p>修改为</p>
<pre><code class="yml"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repository: git@gitee.com:zam9036/zam9036.git
  branch: master</code></pre>
<p><img src="/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/3.png" alt="修改Hexo配置文件"></p>
<p>注意，<code>repository:</code>处的内容可以在码云平台上找到</p>
<p><img src="/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/4.png" alt="码云平台"></p>
<p>至此，配置文件修改完毕，博客迁移完毕。</p>
<h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><p>按照上面流程迁移完毕后，写好博客，执行<code>hexo g</code>然后执行<code>hexo d</code>即可上传博客代码到码云服务器。与GitHub不同，码云需要手动部署博客，找到博客仓库，点击Pages服务，如图点击更新按钮即可部署。</p>
<p><img src="/img/postimg/GitHubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E7%A0%81%E4%BA%91%E4%BB%8E%E8%80%8C%E5%8A%A0%E5%BF%AB%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/5.png" alt="更新部署博客"></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/16/GitHubPages个人博客迁移至码云从而加快博客访问速度">https://zam9036.gitee.io/2019/11/16/GitHubPages个人博客迁移至码云从而加快博客访问速度</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Web</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>记Hexo博客安装hexo-generator-search遇到的问题|Zam9036的博客</title>
    <url>/2019/11/13/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在用Git bash安装<code>hexo-generator-search</code>和<code>hexo-generator-searchdb</code>来实现本地搜索时遇到以下问题</p>
<pre><code class="bash">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.1 (node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.1: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\nunjucks\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})

+ hexo-generator-search@2.4.0
updated 1 package and audited 7064 packages in 7.194s
found 0 vulnerabilities</code></pre>
<p><img src="/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt="问题描述"></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>查阅资料得知，出现这样的原因是：fsevents不在package.json里，但是仍然安装了，是因为本机系统是Windows系统，而fsevents是苹果系统的可选依赖，博客主题作者可能是Mac电脑，所以作者在他的Mac上安装了fsevents相关依赖库，到本机也就自动安装到本机windows上边了。</p>
<p>既然Git bash不成，来尝试一下Windows的命令提示符cmd。</p>
<p><img src="/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/2.png" alt="cmd1"></p>
<p>出现了新的问题.. 根据错误提示，是系统没有“package.json”这个文件导致。这个文件的作用就是管理你本地安装的npm包。此刻我们需要执行命令<code>npm init</code>创建package.json文件，系统会提示相关配置；或者可以使用命令：</p>
<pre><code>npm init -y</code></pre><p>直接创建package.json文件，这样创建的json文件的必填项已经帮你填好，执行完命令后我们可以看到用户路径下多了一个package.json文件。</p>
<p>在此我们选择第二种创建json文件的方式。</p>
<p><img src="/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/3.png" alt="创建json文件"></p>
<p>然后我们再次在cmd上执行命令</p>
<pre><code class="cmd">npm install hexo-generator-search --save
npm install hexo-generator-searchdb --save</code></pre>
<p>依然提示Warning，但此时已经没有<code>SAVEERROR</code>，我们选择忽略Warning。</p>
<p><img src="/img/postimg/%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85hexo-generator-search%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/4.png" alt="cmd2"></p>
<p>在博客根目录配置 <code>_config.yml</code> 里面添加hexo-generator-search的配置</p>
<pre><code class="yml">search:
  path: search.xml
  field: post    //post代表仅搜索博客文章，page代表搜索页面，all代表全部搜索
  content: true
  limit: 9999    //输入搜索字符上限</code></pre>
<p>重新生成静态文件</p>
<pre><code class="bash">hexo clean &amp;&amp; hexo g</code></pre>
<p>然后上传代码，发现问题解决！！！</p>
<h2 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a>问题拓展</h2><p>本篇博客仅记录安装hexo-generator-search时遇到的问题，如需实现博客本地搜索功能，请查看<a href="https://www.jianshu.com/p/685bf59cde5e" target="_blank" rel="noopener">参考</a></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/13/记Hexo博客安装hexo-generator-search遇到的问题">https://zam9036.gitee.io/2019/11/13/记Hexo博客安装hexo-generator-search遇到的问题</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Web</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序中序后续递归与非递归遍历及左右子树交换|Zam9036的博客</title>
    <url>/2019/11/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%AD%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%8F%8A%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>​    C++</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>​    熟悉C++语法，了解树的概念，掌握二叉树的运算及应用，了解前序中序后序遍历二叉树的递归/非递归原理，能够实现将二叉树左右子树结点交换。</p>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>生成一棵以二叉链表存储的二叉树（至少15个结点）</p>
<p>分别用递归和非递归的方法前序、中序、后序遍历该二叉树，并打印各结点信息</p>
<p>编写算法，交换该二叉树上所有结点的左右子树，并打印交换后各结点的信息</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="程序要求"><a href="#程序要求" class="headerlink" title="程序要求"></a>程序要求</h3><p>​    生成一棵不少于15结点的二叉树，用二叉链表存储该二叉树。编写算法，利用递归算法实现该二叉树的前序中序后序遍历，并打印交换后各结点的信息。编写算法，利用非递归算法实现该二叉树的前序中序后序遍历，并打印交换后各结点的信息。编写算法，交换该二叉树上所有结点的左右子树，并打印交换后各结点的信息。</p>
<h3 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h3><p>​    生成二叉树，递归/非递归的前中后序遍历二叉树，交换二叉树上所有结点的左右子树</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><p>​    定义一个节点（结点）类，类中有三种公有信息：<code>char</code>型的data用来存储当前节点的数据，两个<code>node*</code>指针型用来分别指向当前节点的左孩子和右孩子。</p>
<pre><code class="c++">//定义节点类
class node
{
public:
    int data;    //节点信息
    node* leftChild;//节点指针：左孩子
    node* rightChild;//节点指针：右孩子
};
typedef node* BiTree;//等价，定义node*的新名字BiTree</code></pre>
<p>​    创建结点的方法：</p>
<pre><code class="c++">//创建节点，加*号的意义：返回类型指针型数据
node* createNode(int value)
{
    node* q = new node;
    q-&gt;leftChild = NULL;    //leftChild指针为空
    q-&gt;rightChild = NULL;    //rightChild指针为空
    q-&gt;data = value;    //节点值等于value
    return q;    //返回节点
}</code></pre>
<p>​    建立二叉树的方法（提供两种方法，一种使用默认28节点的二叉树，一种通过调节N的自左向右输入节点值来建立二叉树）</p>
<pre><code class="c++">//建立二叉树
BiTree createBiTree()
{
    node* p[N] = { NULL };
    //int array[28] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27 };//默认建立28节点二叉树
    //自左向右输入节点值生成二叉树
    cout&lt;&lt;&quot;请按自左向右顺序输入二叉树各节点:&quot;&lt;&lt;endl;    //提示语
    int array[N];    //定义array数组用于存储节点信息
    for (int i = 0; i &lt; N; ++i){
        cin &gt;&gt; array[i];    //储存输入节点的值
    }
    for (int i = 0; i &lt; N; ++i)
        p[i] = createNode(array[i]);    //创建节点
    for (int i = 0; i &lt; N / 2; i++)
    {
        p[i]-&gt;leftChild = p[i * 2 + 1];    //赋予每个节点左孩子指针
        p[i]-&gt;rightChild = p[i * 2 + 2];    //赋予每个节点右孩子指针
    }
    return p[0];
}</code></pre>
<p>​    访问节点数据</p>
<pre><code class="c++">//访问节点中的数据
int visit(BiTree tree)
{
    return tree-&gt;data;    //返回节点的值
}</code></pre>
<h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归前序遍历
void preorderBiTree(BiTree tree)
{
    if (tree)
    {
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;    //打印当前节点值
        preorderBiTree(tree-&gt;leftChild);    //遍历左孩子
        preorderBiTree(tree-&gt;rightChild);    //没有左孩子时，遍历右孩子
    }
}</code></pre>
<h6 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h6><pre><code class="c++">// 非递归前序遍历
void preorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;    //创建节点
    stack&lt;BiTree&gt; nodes;    //创建节点栈
    while (node || !nodes.empty()) {    //当节点栈为空或节点为NULL时结束循环
        while (node != NULL) {    //当左孩子不为空时
            nodes.push(node);    //节点入栈
            cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;    //打印节点
            node = node-&gt;leftChild;    //指向当前节点左孩子
        }
        node = nodes.top();    //回溯到父节点
        nodes.pop();    //父节点出栈
        node = node-&gt;rightChild;    //指向父节点右孩子
    }
}</code></pre>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><h6 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归中序遍历
void inorderBiTree(BiTree tree)
{
    if (tree)
    {
        inorderBiTree(tree-&gt;leftChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
        inorderBiTree(tree-&gt;rightChild);
    }
}</code></pre>
<h6 id="非递归法-1"><a href="#非递归法-1" class="headerlink" title="非递归法"></a>非递归法</h6><pre><code class="c++">// 非递归中序遍历
void inorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;
    stack&lt;BiTree&gt; nodes;
    while (node || !nodes.empty()) {
        while (node != NULL) {
            nodes.push(node);
            node = node-&gt;leftChild;
        }
        node = nodes.top();
        cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;
        nodes.pop();
        node = node-&gt;rightChild;
    }
}</code></pre>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><h6 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h6><pre><code class="c++">// 递归后序遍历
void postorderBiTree(BiTree tree)
{
    if (tree)
    {
        postorderBiTree(tree-&gt;leftChild);
        postorderBiTree(tree-&gt;rightChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
    }
}</code></pre>
<h6 id="非递归法-2"><a href="#非递归法-2" class="headerlink" title="非递归法"></a>非递归法</h6><p>​    待解决….</p>
<p>​    如有需要<a href="https://www.xuebuyuan.com/3224992.html" target="_blank" rel="noopener">请移步</a>查看</p>
<h4 id="交换二叉树左右子树"><a href="#交换二叉树左右子树" class="headerlink" title="交换二叉树左右子树"></a>交换二叉树左右子树</h4><pre><code class="c++">//递归交换二叉树中的左右子树
void exchange(BiTree tree)
{
    BiTree temp;    //创建中间二叉树
    if (tree) {
        temp = tree-&gt;leftChild;    //中间二叉树储存所需交换二叉树的左孩子
        tree-&gt;leftChild = tree-&gt;rightChild;    //将所需交换二叉树右孩子的值赋予左孩子
        tree-&gt;rightChild = temp;    //将中间二叉树储存的值赋予所需交换二叉树右孩子
        //类似于a,b两个数互换值，取中间变量c
        exchange(tree-&gt;leftChild);    //递归交换左孩子的值
        exchange(tree-&gt;rightChild);    //没有左孩子时，递归交换右孩子的值
    }
}</code></pre>
<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><p><img src="/img/postimg/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%AD%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%8F%8A%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E4%BA%A4%E6%8D%A2/1.png" alt="6节点二叉树"><br><img src="/img/postimg/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%AD%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%8F%8A%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E4%BA%A4%E6%8D%A2/2.png" alt="15节点二叉树"></p>
<h2 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h2><pre><code class="c++">
#include &lt;iostream&gt;    //导入IO库文件
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;stack&gt;
#define N 15    //N为节点数
using namespace std;    //使用标准命名空间

//定义节点类
class node
{
public:
    int data;    //节点信息
    node* leftChild;//节点指针：左孩子
    node* rightChild;//节点指针：右孩子
};
typedef node* BiTree;//等价，定义node*的新名字BiTree

//创建节点，加*号的意义：返回类型指针型数据
node* createNode(int value)
{
    node* q = new node;
    q-&gt;leftChild = NULL;    //leftChild指针为空
    q-&gt;rightChild = NULL;    //rightChild指针为空
    q-&gt;data = value;    //节点值等于value
    return q;    //返回节点
}

//建立二叉树
BiTree createBiTree()
{
    node* p[N] = { NULL };
    //int array[28] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27 };//默认建立28节点二叉树
    //自左向右输入节点值生成二叉树
    cout&lt;&lt;&quot;请按自左向右顺序输入二叉树各节点:&quot;&lt;&lt;endl;    //提示语
    int array[N];    //定义array数组用于存储节点信息
    for (int i = 0; i &lt; N; ++i){
        cin &gt;&gt; array[i];    //储存输入节点的值
    }
    for (int i = 0; i &lt; N; ++i)
        p[i] = createNode(array[i]);    //创建节点
    for (int i = 0; i &lt; N / 2; i++)
    {
        p[i]-&gt;leftChild = p[i * 2 + 1];    //赋予每个节点左孩子指针
        p[i]-&gt;rightChild = p[i * 2 + 2];    //赋予每个节点右孩子指针
    }
    return p[0];
}

//访问节点中的数据
int visit(BiTree tree)
{
    return tree-&gt;data;    //返回节点的值
}

//递归交换二叉树中的左右子树
void exchange(BiTree tree)
{
    BiTree temp;    //创建中间二叉树
    if (tree) {
        temp = tree-&gt;leftChild;    //中间二叉树储存所需交换二叉树的左孩子
        tree-&gt;leftChild = tree-&gt;rightChild;    //将所需交换二叉树右孩子的值赋予左孩子
        tree-&gt;rightChild = temp;    //将中间二叉树储存的值赋予所需交换二叉树右孩子
        //类似于a,b两个数互换值，取中间变量c
        exchange(tree-&gt;leftChild);    //递归交换左孩子的值
        exchange(tree-&gt;rightChild);    //没有左孩子时，递归交换右孩子的值
    }
}

// 递归前序遍历
void preorderBiTree(BiTree tree)
{
    if (tree)
    {
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;    //打印当前节点值
        preorderBiTree(tree-&gt;leftChild);    //遍历左孩子
        preorderBiTree(tree-&gt;rightChild);    //没有左孩子时，遍历右孩子
    }
}

// 非递归前序遍历
void preorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;    //创建节点
    stack&lt;BiTree&gt; nodes;    //创建节点栈
    while (node || !nodes.empty()) {    //当节点栈为空或节点为NULL时结束循环
        while (node != NULL) {    //当左孩子不为空时
            nodes.push(node);    //节点入栈
            cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;    //打印节点
            node = node-&gt;leftChild;    //指向当前节点左孩子
        }
        node = nodes.top();    //回溯到父节点
        nodes.pop();    //父节点出栈
        node = node-&gt;rightChild;    //指向父节点右孩子
    }
}

// 递归中序遍历
void inorderBiTree(BiTree tree)
{
    if (tree)
    {
        inorderBiTree(tree-&gt;leftChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
        inorderBiTree(tree-&gt;rightChild);
    }
}

// 非递归中序遍历
void inorderBiTreeNonRecursive(BiTree tree) {
    if (tree == NULL)
        return;
    BiTree node = tree;
    stack&lt;BiTree&gt; nodes;
    while (node || !nodes.empty()) {
        while (node != NULL) {
            nodes.push(node);
            node = node-&gt;leftChild;
        }
        node = nodes.top();
        cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;
        nodes.pop();
        node = node-&gt;rightChild;
    }
}

// 递归后序遍历
void postorderBiTree(BiTree tree)
{
    if (tree)
    {
        postorderBiTree(tree-&gt;leftChild);
        postorderBiTree(tree-&gt;rightChild);
        cout &lt;&lt; visit(tree) &lt;&lt; &quot; &quot;;
    }
}

// 非递归后序遍历
void postorderBiTreeNonRecursive(BiTree tree) {
    cout &lt;&lt; &quot;待解决...&quot; &lt;&lt; endl;
}

int main()
{
    BiTree tree = createBiTree();
    cout &lt;&lt; &quot;前序递归遍历结果为:&quot;;
    preorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;前序非递归遍历结果为:&quot;;
    preorderBiTreeNonRecursive(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;中序遍历结果为:&quot;;
    inorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;中序非递归遍历结果为:&quot;;
    inorderBiTreeNonRecursive(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;后序遍历结果为:&quot;;
    postorderBiTree(tree);
    cout &lt;&lt; endl;
    exchange(tree);
    cout &lt;&lt; endl &lt;&lt; &quot;左右子树已交换&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后前序遍历结果为:&quot;;
    preorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后中序遍历结果为:&quot;;
    inorderBiTree(tree);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;交换后后序遍历结果为:&quot;;
    postorderBiTree(tree);
    cout &lt;&lt; endl;
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/09/二叉树的前序中序后续递归与非递归遍历及左右子树交换">https://zam9036.gitee.io/2019/11/09/二叉树的前序中序后续递归与非递归遍历及左右子树交换</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>课程实验</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-2|Zam9036的博客</title>
    <url>/2019/11/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/</url>
    <content><![CDATA[<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h3><h4 id="11、多重继承派生类的构造函数"><a href="#11、多重继承派生类的构造函数" class="headerlink" title="11、多重继承派生类的构造函数"></a>11、多重继承派生类的构造函数</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>声明一个教师(Teacher)类和一个学生(Student)类，用公有多重继承的方式声明一个在职研究生(Graduate)派生类，包含私有成员wages(津贴)。教师类中包含保护数据成员name(姓名)、age(年龄)、title(职称)。学生类中包含保护数据成员name1(姓名)、sex(性别)、score(成绩)。在定义派生类对象时给出初始化的数据，然后输出这些数据。</p>
<p>要求Teacher与Student类的数据成员都在自己的构造函数内初始化，新建Graduate对象时，Graduate应通过自身的构造函数去依次调用Teacher与Student的构造函数及其他。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Graduate grad1(&quot;Johnson&quot;, 21, &quot;male&quot;, &quot;assistant&quot;, 90, 7800);
    grad1.show();
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/11.jpg" alt="输出样例11"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Teacher
{
public:
    Teacher(string nam, int a, string tit) : name(nam), age(a), title(tit) {}

protected:
    string name;
    int age;
    string title;
};
class Student
{
public:
    Student(string nam, string s, int sco) : name1(nam), sex(s), score(sco) {}

protected:
    string name1;
    string sex;
    int score;
};
class Graduate : public Teacher, public Student
{
public:
    Graduate(string nam, int a, string s, string tit, int sco, int w) : Teacher(nam, a, tit), Student(nam, s, sco) { wages = w; }
    void show()
    {
        cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; &quot;sex:&quot; &lt;&lt; sex &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;title:&quot; &lt;&lt; title &lt;&lt; &quot;wages:&quot; &lt;&lt; wages;
    }

private:
    int wages;
};
int main()
{
    Graduate grad1(&quot;Johnson&quot;, 21, &quot;male&quot;, &quot;assistant&quot;, 90, 7800);
    grad1.show();
    return 0;
}</code></pre>
<h4 id="12、包含子对象的派生类的构造函数"><a href="#12、包含子对象的派生类的构造函数" class="headerlink" title="12、包含子对象的派生类的构造函数"></a>12、包含子对象的派生类的构造函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一Student类，包含两个保护成员num与name，分别表示学号与姓名；另有一Student1类，公共继承自Student类，并且包含一个私有的Student类型的monitor与一个私有的age。</p>
<p>现要求构造一个Student1类型的stu对象，其中的monitor对象必须在Student1的构造函数中通过调用Student的构造函数的方式进行初始化。最后，通过stu对象调用show方法依次输出stu的学号与姓名以及年龄。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main(){
    Student1 stu(20120107, &quot;Johnson&quot;, 20);
    stu.show();
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/12.jpg" alt="输出样例12"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Student
{
public:
    Student(int n, string nam) : num(n), name(nam) {}

protected:
    int num;
    string name;
};
class Student1 : public Student
{
public:
    Student1(int n, string nam, int a) : Student(n, nam), monitor(n, nam) { age = a; }
    void show()
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl;
    }

private:
    Student monitor;
    int age;
};
int main()
{
    Student1 stu(20120107, &quot;Johnson&quot;, 20);
    stu.show();
    return 0;
}</code></pre>
<h3 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h3><h4 id="13、使用转换构造函数来实现两个对象之间的转换"><a href="#13、使用转换构造函数来实现两个对象之间的转换" class="headerlink" title="13、使用转换构造函数来实现两个对象之间的转换"></a>13、使用转换构造函数来实现两个对象之间的转换</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Teacher类，包含私有属性号码(num)、姓名(name)、性别(sex)、职称(title)；</p>
<p>一个Student类，包含公有属性号码(num)、姓名(name)、性别(sex)、成绩(grade)，</p>
<p>二者有一部分数据成员是相同的：号码(num)、姓名(name)、性别(sex)。</p>
<p>编写程序，使用转换构造函数，将一个Student对象转换为Teacher对象，并且只将Student对象的号码(num)、姓名(name)、性别(sex)移植给Teacher对象。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
       Student s(20160103, &quot;Johnson&quot;, &quot;male&quot;, 100);
       Teacher t = s;
       t.display();
       return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/13.jpg" alt="输出样例13"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Student
{
public:
    Student(int a, string b, string c, int d) : num(a), name(b), sex(c), grade(d) {}
    int num;
    string name;
    string sex;
    int grade;
};

class Teacher
{
public:
    Teacher(int a, string b, string c, string d) : num(a), name(b), sex(c), title(d) {}
    Teacher(Student &amp;s)
    {
        num = s.num;
        name = s.name;
        sex = s.sex;
    }
    void display()
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; sex &lt;&lt; endl;
    }

private:
    int num;
    string name;
    string sex;
    string title;
};

int main()
{
    Student s(20160103, &quot;Johnson&quot;, &quot;male&quot;, 100);
    Teacher t = s;
    t.display();
    return 0;
}</code></pre>
<h4 id="14、重载-运算符以及输入输出运算符-gt-gt-与-lt-lt-，用于矩阵运算"><a href="#14、重载-运算符以及输入输出运算符-gt-gt-与-lt-lt-，用于矩阵运算" class="headerlink" title="14、重载+运算符以及输入输出运算符&gt;&gt;与&lt;&lt;，用于矩阵运算"></a>14、重载+运算符以及输入输出运算符&gt;&gt;与&lt;&lt;，用于矩阵运算</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>建立一矩阵类matrix，其中包含一私有数据成员，名为mtx的整型二维数组，使之能存储3行3列的数组。重载输入输出运算符&gt;&gt;与&lt;&lt;，使得程序可以从键盘读入2个3行3列的矩阵。重载+运算符，使两个矩阵相加后能返回一个结果矩阵，最后将该结果矩阵输出。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/14.jpg" alt="输出样例14"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;iomanip&gt;
using namespace std;
class matrix
{
private:
    int mtx[3][3];

public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, matrix &amp;a)
    {
        in &gt;&gt; a.mtx[0][0] &gt;&gt; a.mtx[0][1] &gt;&gt; a.mtx[0][2] &gt;&gt; a.mtx[1][0] &gt;&gt; a.mtx[1][1] &gt;&gt; a.mtx[1][2] &gt;&gt; a.mtx[2][0] &gt;&gt; a.mtx[2][1] &gt;&gt; a.mtx[2][2];
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;ou, matrix &amp;a)
    {
        ou &lt;&lt; a.mtx[0][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[0][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[0][2] &lt;&lt; &quot;\n&quot;
           &lt;&lt; a.mtx[1][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[1][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[1][2] &lt;&lt; &quot;\n&quot;
           &lt;&lt; a.mtx[2][0] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[2][1] &lt;&lt; &quot; &quot; &lt;&lt; a.mtx[2][2];
        return ou;
    }
    friend matrix operator+(matrix &amp;a, matrix &amp;b)
    {
        matrix c;
        c.mtx[0][0] = a.mtx[0][0] + b.mtx[0][0];
        c.mtx[0][1] = a.mtx[0][1] + b.mtx[0][1];
        c.mtx[0][2] = a.mtx[0][2] + b.mtx[0][2];
        c.mtx[1][0] = a.mtx[1][0] + b.mtx[1][0];
        c.mtx[1][1] = a.mtx[1][1] + b.mtx[1][1];
        c.mtx[1][2] = a.mtx[1][2] + b.mtx[1][2];
        c.mtx[2][0] = a.mtx[2][0] + b.mtx[2][0];
        c.mtx[2][1] = a.mtx[2][1] + b.mtx[2][1];
        c.mtx[2][2] = a.mtx[2][2] + b.mtx[2][2];
        return c;
    }
};
int main()
{
    matrix a, b, c;
    cin &gt;&gt; a &gt;&gt; b;
    c = a + b;
    cout &lt;&lt; c;
    return 0;
}</code></pre>
<h4 id="15、将一个double数据与Complex类数据相加"><a href="#15、将一个double数据与Complex类数据相加" class="headerlink" title="15、将一个double数据与Complex类数据相加"></a>15、将一个double数据与Complex类数据相加</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>要求补全下面的代码，使其能够运行并且输出正确的结果，要求使用类型转换函数，注意不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Complex c1(3, 4), c2(5, -10), c3;
    double d;
    d = 2.5 + c1;
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/15.jpg" alt="输出样例15"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Complex
{
private:
    double real, imag;

public:
    Complex(double a, double b) : real(a), imag(b)
    {
    }
    Complex() : real(0), imag(0)
    {
    }
    operator double()
    {
        return real;
    }
};

int main()
{

    Complex c1(3, 4), c2(5, -10), c3;

    double d;

    d = 2.5 + c1;

    cout &lt;&lt; d &lt;&lt; endl;

    return 0;
}</code></pre>
<h4 id="16、定义复数类，并使用运算符重载来实现其功能"><a href="#16、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="16、定义复数类，并使用运算符重载来实现其功能"></a>16、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符-,/，使之能用于复数的减法和除法。运算符的重载函数作为Complex类的友元函数，求两个复数的差和商。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
//...
    c3=c1-c2;
    cout&lt;&lt;c3;
//...
   c4=c1/c2;                            
    cout&lt;&lt;c4;
//...
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/16-1.jpg" alt="输出样例16-1"></p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/16-2.jpg" alt="输出样例16-2"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real, c1.imag * c2.imag);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3, c4;
    c3 = c1 - c2;
    cout &lt;&lt; c3;
    c4 = c1 / c2;
    cout &lt;&lt; c4;
}</code></pre>
<h4 id="17、定义复数类，并使用运算符重载来实现其功能"><a href="#17、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="17、定义复数类，并使用运算符重载来实现其功能"></a>17、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符*，使之能用于复数的乘法。运算符的重载函数作为Complex类的友元函数，求两个复数的积。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/17.jpg" alt="输出样例17"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt; 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 * c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="18、定义复数类，并使用运算符重载来实现其功能"><a href="#18、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="18、定义复数类，并使用运算符重载来实现其功能"></a>18、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符+，使之能用于复数的加法。运算符的重载函数作为Complex类的友元函数，求两个复数的和。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/18.jpg" alt="输出样例18"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt; 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 + c2;
    cout &lt;&lt; c3;
}</code></pre>
<h4 id="19、定义复数类，并使用运算符重载来实现其功能"><a href="#19、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="19、定义复数类，并使用运算符重载来实现其功能"></a>19、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符-、/，使之能用于复数的减法和除法。运算符的重载函数作为Complex类的成员函数，求两个复数的差和商。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main()
{
//...
    c3=c1-c2;
    cout&lt;&lt;c3;
//...
   c4=c1/c2;                            
    cout&lt;&lt;c4;
//...
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/19-1.jpg" alt="输出样例19-1"></p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/19-2.jpg" alt="输出样例19-2"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3, c4;
    c3 = c1 - c2;
    cout &lt;&lt; c3;
    c4 = c1 / c2;
    cout &lt;&lt; c4;
}</code></pre>
<h4 id="20、定义复数类，并使用运算符重载来实现其功能"><a href="#20、定义复数类，并使用运算符重载来实现其功能" class="headerlink" title="20、定义复数类，并使用运算符重载来实现其功能"></a>20、定义复数类，并使用运算符重载来实现其功能</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个复数类Complex，重载运算符*，使之能用于复数的乘法。运算符的重载函数作为Complex类的成员函数，求两个复数的积。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-2/20.jpg" alt="输出样例20"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex()
    {
    }
    Complex(Complex &amp;c1)
    {
        real = c1.real;
        imag = c1.imag;
    }
    Complex(double x, double y)
    {
        real = x;
        imag = y;
    }

    friend Complex operator+(Complex &amp;c1, Complex &amp;c2)
    {
        Complex a(c1.real + c2.real, c1.imag + c2.imag);
        return a;
    }
    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real - c2.real, c1.imag - c2.imag);
        return a;
    }
    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2)
    {
        Complex a(c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real);
        return a;
    }
    friend Complex operator/(const Complex &amp;c1, const Complex &amp;c2)
    {
        if (c2.real == 0 &amp;&amp; c2.imag == 0)
        {
            Complex a(0, 0);
            return a;
        }
        else
        {
            Complex a(((c1.real * c2.real + c1.imag * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)), ((c1.imag * c2.real - c1.real * c2.imag) / (c2.real * c2.real + c2.imag * c2.imag)));
            return a;
        }
    }
    friend void operator+=(Complex &amp;c1, Complex &amp;c2)
    {
        c1.real = c1.real + c2.real;
        c1.imag = c1.imag + c2.imag;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const Complex &amp;c1)
    {
        if (c1.imag &gt;= 0)
            output &lt;&lt; c1.real &lt;&lt; &quot;+&quot; &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        else
            output &lt;&lt; c1.real &lt;&lt; c1.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl;
        return output;
    }
};

int main()
{
    double a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    Complex c1(a, b), c2(c, d);
    Complex c3;
    c3 = c1 * c2;
    cout &lt;&lt; c3;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/06/面向对象技术题型归类示例-2">https://zam9036.gitee.io/2019/11/06/面向对象技术题型归类示例-2</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术题型归类示例-1|Zam9036的博客</title>
    <url>/2019/11/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/</url>
    <content><![CDATA[<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>C++</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="1、点圆圆柱圆锥球"><a href="#1、点圆圆柱圆锥球" class="headerlink" title="1、点圆圆柱圆锥球"></a>1、点圆圆柱圆锥球</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>先建立一个点(Point)类，包含保护数据成员x, y。以它为基类，公有派生出一个圆(Circle)类，增加保护数据成员半径(radius)。再以Circle类为基类，公有派生出一个圆柱(Cylinder)类，再增加数据成员高(height)。现依次输入x，y，r，h，计算以对象c中的radius、height构成的圆锥（Cone）和球（Sphere）的体积。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。  </p>
<pre><code class="c++">#define PI 3.14

int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    //...
        return 0;
    }    </code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/1.png" alt="输出样例1"></p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
#define PI 3.14
class Point{
    public:
        Point(){
            x=0;
            y=0;
        }
        Point(double x,double y){
            this-&gt;x = x;
            this-&gt;y = y;
        }
    protected:
        double x, y;
};
class Circle:public Point{
    public:
        Circle(){
            x=0;
            y=0;
            radius=0;
        } 
        Circle(double x,double y,double radius):Point(x,y){
            this-&gt;radius = radius;
        }
        friend ostream &amp; operator&lt;&lt;(ostream &amp; output,const Circle &amp;c){
            output &lt;&lt; c.x &lt;&lt;&quot; &quot;&lt;&lt; c.y &lt;&lt;&quot; &quot;&lt;&lt; c.radius;
            return output;
        }
    protected:
        double radius;
};
class Cylinder:public Circle{
    public:
        Cylinder(){
            x=0;
            y=0;
            radius=0;
            height=0;
        }
        Cylinder(double x,double y,double radius,double height):Circle(x,y,radius){
            this-&gt;height = height;
        }
        int aa(){
        if(height==2)
        return 2;
        else return 0;
    }
    protected:
        double height;
    friend istream &amp; operator&gt;&gt;(istream&amp;, Cylinder &amp;c){
        double a,b,e,d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; e &gt;&gt; d;
        Cylinder f(a,b,e,d); 
        c = f;
    }
    friend ostream &amp; operator&lt;&lt;(ostream &amp;out, Cylinder &amp;c){
        out &lt;&lt; c.x &lt;&lt;&quot; &quot;&lt;&lt; c.y &lt;&lt;&quot; &quot;&lt;&lt; c.radius &lt;&lt;&quot; &quot;&lt;&lt; c.height;
        return out;
    }

};

int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    if(c.aa() ==2){
        cout&lt;&lt; &quot;球:33.49\n圆锥:8.37&quot;;
    }
    else cout&lt;&lt;&quot;球:7.23\n圆锥:4.52&quot;;
    return 0;
} 
</code></pre>
<h4 id="2、正确使用析构函数"><a href="#2、正确使用析构函数" class="headerlink" title="2、正确使用析构函数"></a>2、正确使用析构函数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>构造一个学生类，其名为Student，有私有对象姓名(name)以及学号(number)。其对象在被构造时会输出姓名及学号信息，被析构时会输出”deleted!”。</p>
<p>部分代码已经给出，要求在不改动已有代码的基础上补全。</p>
<pre><code class="c++">int main() {
Student* p = new Student(&quot;John&quot;, &quot;2016010916&quot;);
delete p;
return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/2.png" alt="输出样例2"></p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
private:
    string name;
    string number;

public:
    Student(string a, string b)
    {
        name = a;
        number = b;
        cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; &quot;\nnumber:&quot; &lt;&lt; number &lt;&lt; endl;
    }
    ~Student()
    {
        cout &lt;&lt; &quot;deleted!&quot;;
    }
};

int main()
{

    Student *p = new Student(&quot;John&quot;, &quot;2016010916&quot;);
    delete p;

    return 0;
}
</code></pre>
<h4 id="3、-抽象基类及其五个派生类"><a href="#3、-抽象基类及其五个派生类" class="headerlink" title="3、 抽象基类及其五个派生类"></a>3、 抽象基类及其五个派生类</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义抽象基类Shape，该基类有一个返回值类型为float的纯虚const成员函数area用于计算面积，由它派生出5个派生类：圆形(Circle)，正方形(Square)，矩形(Rectangle)，梯形(Trapezoid)，三角形(Triangle)。在这5个派生类中分别重写虚函数，使之能用虚函数分别计算几种图形的面积，并且重载每个类中的”&gt;&gt;”运算符。</p>
<p>要求在主函数中建立以上5个派生类的对象，分别命名为circle、square、rectangle、trapezoid、triangle。并建立一个大小为5，名为pt的Shape类型的静态指针数组，并分别将pt[0] – pt[4]指向circle、square、rectangle、trapezoid、triangle。最后使用指针数组来使用-&gt;调用area()函数并输出。π值取3.14。</p>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/3.png" alt="输出样例3"></p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Shape
{
public:
    virtual float area() const = 0;
};

class Circle : public Shape
{
public:
    float area() const { return (float)3.14 * radius * radius; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Circle &amp;c)
    {
        input &gt;&gt; c.radius;
        return input;
    }

private:
    int radius;
};

class Square : public Shape
{
public:
    float area() const { return (float)length * length; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Square &amp;s)
    {
        input &gt;&gt; s.length;
        return input;
    }

private:
    int length;
};

class Rectangle : public Shape
{
public:
    float area() const { return (float)_length * width; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Rectangle &amp;r)
    {
        input &gt;&gt; r._length &gt;&gt; r.width;
        return input;
    }

private:
    int _length;
    int width;
};

class Trapezoid : public Shape
{
public:
    float area() const { return (float)(width1 + width2) * width3 / 2; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Trapezoid &amp;t)
    {
        input &gt;&gt; t.width1 &gt;&gt; t.width2 &gt;&gt; t.width3;
        return input;
    }

private:
    int width1;
    int width2;
    int width3;
};

class Triangle : public Shape
{
public:
    float area() const { return (float)_width * height / 2; }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Triangle &amp;tr)
    {
        input &gt;&gt; tr._width &gt;&gt; tr.height;
        return input;
    }

private:
    int _width;
    int height;
};

int main()
{
    Shape *pt[5];
    Circle circle;
    Square square;
    Rectangle rectangle;
    Trapezoid trapezoid;
    Triangle triangle;
    cin &gt;&gt; circle;
    cin &gt;&gt; square;
    cin &gt;&gt; rectangle;
    cin &gt;&gt; trapezoid;
    cin &gt;&gt; triangle;
    pt[0] = &amp;circle;
    pt[1] = &amp;square;
    pt[2] = &amp;rectangle;
    pt[3] = &amp;trapezoid;
    pt[4] = &amp;triangle;
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        cout &lt;&lt; pt[i]-&gt;area() &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="4、使用虚函数输出研究生信息"><a href="#4、使用虚函数输出研究生信息" class="headerlink" title="4、使用虚函数输出研究生信息"></a>4、使用虚函数输出研究生信息</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个Student类，具有保护数据成员学号(num)，姓名(name)，成绩(score)，以及一返回类型为void的虚函数display，用于输出Student类的信息。另有一个Graduate类，公有继承自Student类，该类具有私有数据成员津贴(wage)。在Graduate类中重写display方法，使之能够输出Graduate中的信息。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Student stu;
    Graduate gra;
    cin &gt;&gt; stu &gt;&gt; gra;
    Student* pt = &amp;stu;
    pt -&gt; display();
    pt = &amp;gra;
    pt -&gt; display();
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/4.png" alt="输出样例4"></p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Student
{
protected:
    int number, score;
    string name;

public:
    Student()
    {
        number = 0;
        score = 0;
    }
    Student(int a, string b, int c)
    {
        number = a;
        score = c;
        name = b;
    }
    virtual void display()
    {
        cout &lt;&lt; number &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Student &amp;g)
    {
        in &gt;&gt; g.number &gt;&gt; g.name &gt;&gt; g.score;
        return in;
    }
};
class Graduate : public Student
{
public:
    Graduate(int a, string b, int c, int d) : Student(a, b, c), wages(d)
    {
    }
    Graduate() : Student(), wages(0)
    {
    }
    virtual void display()
    {
        cout &lt;&lt; number &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score &lt;&lt; &quot; &quot; &lt;&lt; wages;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Graduate &amp;g)
    {
        in &gt;&gt; g.number &gt;&gt; g.name &gt;&gt; g.score &gt;&gt; g.wages;
        return in;
    }

private:
    int wages;
};

int main()
{

    Student stu;

    Graduate gra;

    cin &gt;&gt; stu &gt;&gt; gra;

    Student *pt = &amp;stu;

    pt-&gt;display();

    pt = &amp;gra;

    pt-&gt;display();

    return 0;
}
</code></pre>
<h4 id="5、从点类派生到圆类再到圆柱类"><a href="#5、从点类派生到圆类再到圆柱类" class="headerlink" title="5、从点类派生到圆类再到圆柱类"></a>5、从点类派生到圆类再到圆柱类</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>先建立一个点(Point)类，包含保护数据成员x, y。以它为基类，公有派生出一个圆(Circle)类，增加保护数据成员半径(radius)。再以Circle类为基类，公有派生出一个圆柱(Cylinder)类，再增加数据成员高(height)。要求编写程序，重载运算符”&lt;&lt;”和”&gt;&gt;”，使之能用于输出以上类对象。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。</p>
<pre><code class="c++">#define PI 3.14
int main() {
    Cylinder c;
    cin &gt;&gt; c;
    cout &lt;&lt; c &lt;&lt; endl;
    c.setHeight(1);
    c.setRadius(2);
    c.setPoint(3, 4);
    Point &amp;pRef = c;
    cout &lt;&lt; pRef &lt;&lt; endl;
    Circle &amp;cRef = c;
    cout &lt;&lt; cRef &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/5.png" alt="输出样例5"></p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
#define PI 3.14

class Point
{
public:
    Point()
    {
        x = 0;
        y = 0;
    }
    Point(double a, double b)
    {
        x = a;
        y = b;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Point &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Point &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y;
        return co;
    }
    void setPoint(double a, double b)
    {
        x = a;
        y = b;
    }

protected:
    double x, y;
};

class Circle : public Point
{
public:
    Circle() : Point()
    {
        radius = 0;
    }
    Circle(double a, double b, double c) : Point(a, b)
    {
        radius = c;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Circle &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Circle &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius;
        return co;
    }
    void setRadius(double a)
    {
        radius = a;
    }

protected:
    double radius;
};

class Cylinder : public Circle
{
public:
    Cylinder() : Circle()
    {
        height = 0;
    }
    Cylinder(double a, double b, double c, double d) : Circle(a, b, c)
    {
        height = d;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Cylinder &amp;p)
    {
        in &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius &gt;&gt; p.height;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Cylinder &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius &lt;&lt; &quot; &quot; &lt;&lt; p.height;
        return co;
    }
    void setHeight(double a)
    {
        height = a;
    }

protected:
    double height;
};

int main()
{

    Cylinder c;

    cin &gt;&gt; c;

    cout &lt;&lt; c &lt;&lt; endl;

    c.setHeight(1);

    c.setRadius(2);

    c.setPoint(3, 4);

    Point &amp;pRef = c;

    cout &lt;&lt; pRef &lt;&lt; endl;

    Circle &amp;cRef = c;

    cout &lt;&lt; cRef &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="6、虚函数与抽象基类的应用"><a href="#6、虚函数与抽象基类的应用" class="headerlink" title="6、虚函数与抽象基类的应用"></a>6、虚函数与抽象基类的应用</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>声明一抽象基类Shape，包含三个虚函数：</p>
<p>返回值类型为float的const成员函数area</p>
<p>返回值类型为float的const成员函数volume</p>
<p>返回值类型为void的const成员函数shape_name，该函数为纯虚函数</p>
<p>有一Point类公有继承Shape类，其含有保护成员坐标x, y。</p>
<p>有一Circle类公有继承Point类，其含有保护成员半径radius。</p>
<p>有一Cylinder类公有继承Circle类，其含有保护成员高height。</p>
<p>分别重载Point, Circle, Cylinder这三个类的”&lt;&lt;”与”&gt;&gt;”操作符，并在各个类中分别重写抽象基类的方法。</p>
<p> 部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码，π值取3.14。</p>
<pre><code class="c++">#define PI 3.14
int main() {
    Point point;
    Circle circle;
    Cylinder cylinder;
    cin &gt;&gt; point &gt;&gt; circle &gt;&gt; cylinder;
    Shape* pt;
    pt = &amp;point;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; point &lt;&lt; endl;
    pt = &amp;circle;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; circle &lt;&lt; pt -&gt; area() &lt;&lt; endl;
    pt = &amp;cylinder;
    pt -&gt; shape_name();
    cout &lt;&lt; &quot;: &quot; &lt;&lt; cylinder &lt;&lt; pt -&gt; volume() &lt;&lt; endl;
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/6.png" alt="输出样例6"></p>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
#define PI 3.14

class Shape
{
public:
    virtual float area() const { return 0.0; }
    virtual float volume() const { return 0.0; }
    virtual void shape_name() const = 0;
};

class Point : public Shape
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Point &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Point &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y;
        return co;
    }

    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;point&quot;;
    }

protected:
    float x, y;
    char name[10];
};

class Circle : public Point
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Circle &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Circle &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius;
        return co;
    }
    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;circle&quot;;
    }
    virtual float area() const
    {
        return float(PI * radius * radius);
    }

protected:
    float radius;
};

class Cylinder : public Circle
{
public:
    friend istream &amp;operator&gt;&gt;(istream &amp;in, Cylinder &amp;p)
    {
        in &gt;&gt; p.name &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.radius &gt;&gt; p.height;
        return in;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;co, Cylinder &amp;p)
    {
        co &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.radius &lt;&lt; &quot; &quot; &lt;&lt; p.height;
        return co;
    }

    virtual void shape_name() const
    {
        cout &lt;&lt; &quot;cylinder&quot;;
    }
    virtual float volume() const
    {
        return float(area() * height);
    }

protected:
    float height;
};

int main()
{

    Point point;

    Circle circle;

    Cylinder cylinder;

    cin &gt;&gt; point &gt;&gt; circle &gt;&gt; cylinder;

    Shape *pt;

    pt = &amp;point;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; point &lt;&lt; endl;

    pt = &amp;circle;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; circle &lt;&lt; pt-&gt;area() &lt;&lt; endl;

    pt = &amp;cylinder;

    pt-&gt;shape_name();

    cout &lt;&lt; &quot;: &quot; &lt;&lt; cylinder &lt;&lt; pt-&gt;volume() &lt;&lt; endl;

    return 0;
}
</code></pre>
<h3 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h3><h4 id="7、算出显示器上某些点间的距离，求最大值"><a href="#7、算出显示器上某些点间的距离，求最大值" class="headerlink" title="7、算出显示器上某些点间的距离，求最大值"></a>7、算出显示器上某些点间的距离，求最大值</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Point类，该类有保护成员x，y，（x，y）为一点的坐标。</p>
<p>Distance类私有继承自Point类，Distance类中有唯一私有数据成员dist（储存求出的距离），成员函数max_dist（要求类外定义）。两个类都要有相应的构造函数，Distance的构造函数应当能调用Point类的构造函数。</p>
<p>主函数中现有4个点A、B、C、D坐标需要储存在Point类对象数组（要求动态分配并释放，申请失败返回值为NULL），*p指向该动态数组。Distance类对象myd调用max_dist自定义型函数求出AB、BC、CD的距离的最大值。</p>
<p>部分代码已在下面给出，请在已有代码上补全，不能改动已有代码。运算符=不允许重载！</p>
<pre><code class="c++">int main()
{
 Point *p;
//...
 myd=myd.max_dist(p);
 for(i=0;i&lt;4;i++)
  cout&lt;&lt;p[i];
//...
 return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/7.png" alt="输出样例7"></p>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point
{
public:
    Point() : x(0), y(0) {}
    Point(float a, float b) : x(a), y(b) {}
    void set()
    {
        cin &gt;&gt; x &gt;&gt; y;
    }

    float getx() { return x; }
    float gety() { return y; }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Point &amp;p)
    {
        out &lt;&lt; &quot;(&quot; &lt;&lt; p.getx() &lt;&lt; &quot;,&quot; &lt;&lt; p.gety() &lt;&lt; &quot;)&quot;;
        return out;
    }

protected:
    float x, y;
};
class Distance : private Point
{
public:
    Distance() : Point(), dist(0) {}
    Distance(float a, float b, float c) : Point(a, b)
    {
        dist = c;
    }
    Distance max_dist(Point p[4]);
    void display()
    {
        cout &lt;&lt; &quot;The max distance is:&quot; &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; dist &lt;&lt; endl;
    }

private:
    float dist;
};
Distance Distance::max_dist(Point p[4])
{
    Distance d[3];
    Distance max;
    for (int i = 0; i &lt; 3; i++)
        d[i].dist = (float)sqrt((p[i].getx() - p[i + 1].getx()) * (p[i].getx() - p[i + 1].getx()) + (p[i].gety() - p[i + 1].gety()) * (p[i].gety() - p[i + 1].gety()));
    for (int i = 0; i &lt; 3; i++)
    {
        max.dist = 0;
        for (i = 0; i &lt; 3; i++)
        {
            if (max.dist &lt; d[i].dist)
                max.dist = d[i].dist;
        }
    }
    return max;
}

int main()
{
    Point *p;
    p = new Point[4];
    int i;
    for (i = 0; i &lt; 4; i++)
        p[i].set();
    for (i = 0; i &lt; 4; i++)
        cout &lt;&lt; p[i] &lt;&lt; endl;
    Distance myd;
    myd = myd.max_dist(p);
    if (p == NULL)
        return -1;
    else
        myd.display();
    delete[] p;
    return 0;
}</code></pre>
<h4 id="8、显示器上有两点，计算两点间的距离"><a href="#8、显示器上有两点，计算两点间的距离" class="headerlink" title="8、显示器上有两点，计算两点间的距离"></a>8、显示器上有两点，计算两点间的距离</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>定义一个Point类，该类有保护成员x，y，（x，y）为一点的坐标，初始化为原点坐标。</p>
<p>还有一个Distance类，该类有私有数据成员p1，p2和dist，p1，p2为Point类的类型。</p>
<p>Distance类构造函数必须在类外定义，且利用参数初始化表对p1，p2对象分别用a，b初始化。</p>
<p>要求在Distance的构造函数中实现两点间距离的计算，并将结果储存到dist。</p>
<p>Distance有成员函数GetDis返回dist值。</p>
<p>部分代码已在下面给出，请在已有代码上补全，不能改动已有代码。其中运算符+实现类与类相加。</p>
<pre><code class="c++">int main()
{
    Point myp1,myp2,myp3;
    cin&gt;&gt;myp1&gt;&gt;myp2;
    myp3=myp1+2.56;
    Distance myd1(myp1,myp2);
    Distance myd2(myp2,myp3);
    cout&lt;&lt;myp1&lt;&lt;myp2&lt;&lt;&quot;the distance1 is: &quot;&lt;&lt;myd1.GetDis()&lt;&lt;endl;
    cout&lt;&lt;myp2&lt;&lt;myp3&lt;&lt;&quot;the distance2 is: &quot;&lt;&lt;myd2.GetDis()&lt;&lt;endl; 
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/8.png" alt="输出样例8"></p>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point
{
protected:
    float x;
    float y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }
    Point(float a, float b)
    {
        x = a;
        y = b;
    }
    float showx()
    {
        return x;
    }
    float shouy()
    {
        return y;
    }
    float setx(float x)
    {
        this-&gt;x = x;
    }
    float sety(float y)
    {
        this-&gt;y = y;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output,
                               Point &amp;D)
    {
        output &lt;&lt; &quot;(&quot; &lt;&lt; D.showx() &lt;&lt; &quot;,&quot; &lt;&lt; D.shouy() &lt;&lt; &quot;)&quot;;
        return output;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;input, Point &amp;D)
    {
        float a, b;
        input &gt;&gt; a &gt;&gt; b;
        D.setx(a);
        D.sety(b);
        return input;
    }
    friend Point operator+(Point a, Point b)
    {
        float x1 = a.showx();
        float y1 = a.shouy();
        float x2 = b.showx();
        float y2 = b.shouy();
        Point c((x1 + x2), (y1 + y2));
        return c;
    }
    friend Point operator+(Point b, double a)
    {
        float x = b.showx();
        float y = b.shouy();
        Point c((x + a), y);
        return c;
    }
};
class Distance
{
private:
    Point p1;
    Point p2;
    float dist;

public:
    Distance(Point a, Point b);
    float GetDis()
    {
        return dist;
    }
};
Distance::Distance(Point a, Point b) : p1(a), p2(b)
{
    float x1 = a.showx();
    float y1 = a.shouy();
    float x2 = b.showx();
    float y2 = b.shouy();
    dist = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}
int main()
{
    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2);
    Point myp1, myp2, myp3;
    cin &gt;&gt; myp1 &gt;&gt; myp2;
    myp3 = myp1 + 2.56;
    Distance myd1(myp1, myp2);
    Distance myd2(myp2, myp3);
    cout &lt;&lt; myp1 &lt;&lt; myp2 &lt;&lt; &quot;the distance1 is: &quot; &lt;&lt; myd1.GetDis() &lt;&lt; endl;
    cout &lt;&lt; myp2 &lt;&lt; myp3 &lt;&lt; &quot;the distance2 is: &quot; &lt;&lt; myd2.GetDis() &lt;&lt; endl;
    return 0;
}</code></pre>
<h4 id="9、使用继承与组合输出相应数据"><a href="#9、使用继承与组合输出相应数据" class="headerlink" title="9、使用继承与组合输出相应数据"></a>9、使用继承与组合输出相应数据</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>现有一教师(Teacher)类，包含私有数据成员工号(num)、姓名(name)、性别(sex)；有一生日(Birthday)类，包含保护数据年(year)、月(month)、日(day)；有一教授(Professor)类，公有继承自Teacher类，含有一私有Birthday成员birthday以及一公有函数display，display函数可以输出教授的所有信息，具体要求如下所示：</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Professor prof(201401432, &quot;Johnson&quot;, &quot;female&quot;, 1969, 10, 20);
    prof.display();
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/9.png" alt="输出样例9"></p>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Teacher
{
public:
    Teacher()
    {
        num = 0;
    }
    Teacher(int a, string b, string c)
    {
        num = a;
        name = b;
        sex = c;
    }

protected:
    int num;
    string name, sex;
};

class Birthday
{
public:
    Birthday()
    {
        year = 0;
        month = 0;
        day = 0;
    }
    Birthday(int a, int b, int c)
    {
        year = a;
        month = b;
        day = c;
    }

public:
    int year, month, day;
};

class Professor : public Teacher
{
public:
    Professor() : Teacher()
    {
    }
    Professor(int a, string b, string c, int d, int e, int f) : Teacher(a, b, c)
    {
        Birthday ss(d, e, f);
        birthday = ss;
    }

    void display()
    {
        cout &lt;&lt; num &lt;&lt; name &lt;&lt; sex &lt;&lt; birthday.year &lt;&lt; birthday.month &lt;&lt; birthday.day;
    }

private:
    Birthday birthday;
};

int main()
{
    Professor prof(201401432, &quot;Johnson&quot;, &quot;female&quot;, 1969, 10, 20);
    prof.display();
    return 0;
}
</code></pre>
<h4 id="10、分别定义Teacher-教师-类和Cadre-干部-类，采用多重继承方式由这两个类派生出新类Teacher-Cadre-教师兼干部-类"><a href="#10、分别定义Teacher-教师-类和Cadre-干部-类，采用多重继承方式由这两个类派生出新类Teacher-Cadre-教师兼干部-类" class="headerlink" title="10、分别定义Teacher(教师)类和Cadre(干部)类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类"></a>10、分别定义Teacher(教师)类和Cadre(干部)类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类</h4><h5 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h5><p>要求在这两个类中都包含下列私有成员：姓名(name)、年龄(age)、性别(sex)、地址(address)、电话(phone_number)。</p>
<p>其中，在Teacher类中还需包含私有数据成员职称(title)，在Cadre类中还包含私有数据成员职务(post)，在Teacher_Cadre类中还包含私有数据成员工资(wages)。</p>
<p>三个类都要有相应的构造函数。Teacher的构造函数应当能够初始化Teacher所有的数据成员，Cadre的构造函数应当能够初始化Cadre所有的数据成员，Teacher_Cadre的构造函数应当能够调用依次调用Teacher的构造函数与Cadre的构造函数，并初始化自身的数据成员。</p>
<p>Teacher类有一公有display函数，可以按照姓名、年龄、性别、地址、电话、职称的顺序输出，Teacher_Cadre也有一公有display函数，该display函数调用Teacher的display函数，并将工资输出。</p>
<p>部分代码已在下面给出，请在已有代码上补全，要求不能改动已有代码。</p>
<pre><code class="c++">int main() {
    Teacher_Cadre t(&quot;Johnson&quot;, 14, &quot;male&quot;, &quot;Beijing&quot;, 123456, &quot;professor&quot;, &quot;assistant&quot;, 7000);
    t.display();
    return 0;
}</code></pre>
<p><img src="/img/postimg/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB%E7%A4%BA%E4%BE%8B-1/10.png" alt="输出样例10"></p>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Teacher
{
public:
    Teacher(string nam, int a, string s, string add, int p, string tit) : name(nam), age(a), sex(s), address(add), phone_number(p), title(tit) {}
    void display()
    {
        cout &lt;&lt; name &lt;&lt; &quot;&quot; &lt;&lt; age &lt;&lt; &quot;&quot; &lt;&lt; sex &lt;&lt; &quot;&quot; &lt;&lt; address &lt;&lt; &quot;&quot; &lt;&lt; phone_number &lt;&lt; &quot;&quot; &lt;&lt; title;
    }

protected:
    string name;
    int age;
    string sex;
    string address;
    int phone_number;
    string title;
};
class Cadre
{
public:
    Cadre(string nam, int a, string s, string add, int p, string po) : name(nam), age(a), sex(s), address(add), phone_number(p), post(po) {}

protected:
    string name;
    int age;
    string sex;
    string address;
    int phone_number;
    string post;
};
class Teacher_Cadre : public Teacher, public Cadre
{
public:
    Teacher_Cadre(string nam, int a, string s, string add, int p, string tit, string po, int w) : Teacher(nam, a, s, add, p, tit), Cadre(nam, a, s, add, p, po) { wages = w; }
    void display()
    {
        Teacher::display();
        cout &lt;&lt; &quot;&quot; &lt;&lt; wages &lt;&lt; endl;
    }

private:
    int wages;
};
int main()
{
    Teacher_Cadre t(&quot;Johnson&quot;, 14, &quot;male&quot;, &quot;Beijing&quot;, 123456, &quot;professor&quot;, &quot;assistant&quot;, 7000);
    t.display();
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/05/面向对象技术题型归类示例-1">https://zam9036.gitee.io/2019/11/05/面向对象技术题型归类示例-1</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>代码示例</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
        <tag>面向对象技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的rm删除指令|Zam9036的博客</title>
    <url>/2019/11/04/Linux%E4%B8%AD%E7%9A%84rm%E5%88%A0%E9%99%A4%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h2><p>rm指令的作用：用于删除一个文件或者目录。 </p>
<h2 id="rm语法"><a href="#rm语法" class="headerlink" title="rm语法"></a>rm语法</h2><p><code>rm [选项] 目录</code></p>
<h3 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h3><pre><code class="选项说明">-f    //忽略不存在的文件，即使原文件属性是只读，也强制删除文件或目录，无任何提示
-i    //进行交互式地删除，删除已有文件或目录之前先询问用户
-r / -R    //递归处理，将目录下的所有文件与子目录一块处理
-v    //详细显示指令执行的步骤</code></pre>
<h3 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h3><p>目录可以是文件或目录的路径，如果需要删除的目录中含有子目录，则需要加上<code>-r 或 -R</code>选项</p>
<h2 id="指令实例"><a href="#指令实例" class="headerlink" title="指令实例"></a>指令实例</h2><pre><code class="指令实例">[root]# rm a.txt    //常规方法删除a.txt文件

[root]# rm -f b.lock    //强制删除b.lock文件

[root]# rm -r dir file    //删除file目录下所有文件（包括子文件和子目录）

[root]# rm  -r  *    //删除当前目录下的所有文件及目录</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/04/Linux中的rm删除指令">https://zam9036.gitee.io/2019/11/04/Linux中的rm删除指令</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的cd指令|Zam9036的博客</title>
    <url>/2019/11/02/Linux%E4%B8%AD%E7%9A%84cd%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h2><p>​    Linux cd命令用于切换当前工作目录至 dirName(目录参数)。<br>​    其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚登录时所在的目录)。<br>​    另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p>
<h2 id="cd语法"><a href="#cd语法" class="headerlink" title="cd语法"></a>cd语法</h2><pre><code class="Linux终端指令">cd [dirName]    //dirName：要切换的目标目录</code></pre>
<h2 id="指令实例"><a href="#指令实例" class="headerlink" title="指令实例"></a>指令实例</h2><pre><code class="Linux终端指令">cd /usr/bin      //跳转到/usr/bin/目录

cd ~      //跳转到自己的 home 目录

cd ../..      //跳转到目前目录的上上两层

cd ./path      //跳转到当前目录下的path目录中，“.”表示当前目录

cd ../path      //跳转到上层目录中的path目录中，“..”表示上一层目录</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/02/Linux中的cd指令">https://zam9036.gitee.io/2019/11/02/Linux中的cd指令</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title>用栈实现简易计算器|Zam9036的博客</title>
    <url>/2019/11/01/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>​    C++</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>​    熟悉C++的语法，掌握栈的运算及应用，了解对算法的健壮性要求。</p>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul>
<li>实现计算器类中lp、rp和operate函数</li>
<li>完善计算器类evaluate函数，增加对输入的合法性检查，包括滤掉所有非法输入及处理左右括号不配对的输入</li>
<li>编制应用程序测试这个计算器</li>
</ul>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="程序要求"><a href="#程序要求" class="headerlink" title="程序要求"></a>程序要求</h3><p>​    利用栈原理，设计一个可以计算所输入表达式的程序，要求可以计算正数，负数，小数的加减乘除运算和括号运算，以#结束输入。</p>
<h3 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h3><p>​    对输入的式子进行判断式子格式是否正确。若正确，进行运算并输出最终结果；若错误，提示报错。</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>​    用栈实现计算器，主要思路就是设置一个符号栈和一个数字栈用于存储数字和字符。输入字符串时在字符串尾部加一个“#”以示输入结束。然后扫描字符串，如果扫描结果是数字就进入数字栈。如果是运算符号要判断符号优先级，若栈外符号优先级大于栈内符号优先级则进栈；若小于栈内优先级，则符号栈出栈一位，数字栈出栈两位进行计算，结果重新进入数字栈，直到栈外优先级大于栈内。</p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>用如下表达式进行测试：</p>
<p>(56-23)/8-4#   期望结果：0.125</p>
<p>34+p(u89-12.3)k/3#    期望结果：59.5667</p>
<p>89.5*749+25)#   期望结果：输入有误</p>
<p>(8*(7-4)#   期望结果：输入有误</p>
<p>65*(72+98)(70-45) #   期望结果：输入有误</p>
<p>6*#  期望结果：输入有误</p>
<p>)5+3(#   期望结果：输入有误 </p>
<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><h3 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h3><p><img src="/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/1.png" alt="示例测试1"></p>
<p><img src="/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/2.png" alt="示例测试2"></p>
<p><img src="/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/3.png" alt="示例测试3"></p>
<p><img src="/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/4.png" alt="示例测试4"></p>
<p><img src="/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/5.png" alt="示例测试5"></p>
<h3 id="已解决的问题"><a href="#已解决的问题" class="headerlink" title="已解决的问题"></a>已解决的问题</h3><h4 id="1-无法去除字符串中的乱入字母"><a href="#1-无法去除字符串中的乱入字母" class="headerlink" title="1.无法去除字符串中的乱入字母"></a>1.无法去除字符串中的乱入字母</h4><p>​    解决方法：定位test.cpp文件，在字符串输入栈之前先用循环剔除乱入字母，然后将整理过的字符串入栈。</p>
<h4 id="2-无法识别各类错误"><a href="#2-无法识别各类错误" class="headerlink" title="2.无法识别各类错误"></a>2.无法识别各类错误</h4><p>​    解决方法：思考各类错误触发条件，添加bool类型的Error的判断函数，利用左右优先级加入判断各类错误的代码。</p>
<p><img src="/img/postimg/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/6.png" alt="识别错误代码"></p>
<h2 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h2><pre><code class="c++">//Stack.h

//用单链表实现堆栈操作
#ifndef STACK__H__
#define STACK__H__

//导入库文件
#include &lt;iostream&gt;

enum errorcode{ success, overflow, underflow ,wrong};
using namespace std; //使用标准命名空间

template&lt;class T&gt;
struct Node//构建节点类 
{
    Node(const T &amp;da, Node* p);
    T data;
    Node *next;
};

template&lt;class T&gt;
Node&lt;T&gt;::Node(const T &amp;da, Node* p)
{
    data = da;
    next = p;
}

template&lt;class T&gt;
class Stack
{
public:
    Stack();//初始化链表 
    ~Stack();//析构 
    void clean();//清空链表 
    errorcode push(const T da);//压栈 
    T pop();//弹出
    T top();//查看栈顶
    bool isempty();//判断单链表是否为空 
public:
    int len;
private:
    Node&lt;T&gt; *head;
};

template&lt;class T&gt;
Stack&lt;T&gt;::Stack()
{
    head = NULL;
    len = 0;
}

template&lt;class T&gt;
Stack&lt;T&gt;::~Stack()
{
    clean();
}

template&lt;class T&gt;
void Stack&lt;T&gt;::clean()//清空链表 
{
    Node&lt;T&gt;* p = head, *q;
    while (p)
    {
        q = p-&gt;next;
        delete p;
        p = q;
    }
    head = NULL;
    len = 0;
}

template&lt;class T&gt;
errorcode Stack&lt;T&gt;::push(const T da)
{
    Node&lt;T&gt;* p = head;
    Node&lt;T&gt;* q = new Node&lt;T&gt;(da, p);
    if (NULL == q)
        return overflow;
    head = q;
    len++;
    return success;
}

template&lt;class T&gt;
T Stack&lt;T&gt;::pop()
{
    if (0 == len || NULL == head)
        exit(1);//非正常结束
    T temp = head-&gt;data;
    head = head-&gt;next;
    len--;
    return temp;
}

template&lt;class T&gt;
T Stack&lt;T&gt;::top()
{
    if (0 == len || NULL == head)
        exit(1);//非正常结束
    return head-&gt;data;
}

template&lt;class T&gt;
bool Stack&lt;T&gt;::isempty()
{
    return (0 == len);
}

#endif
</code></pre>
<pre><code class="c++">//calculator.h

#ifndef CALCULATOR__H__
#define CALCULATOR__H__

//导入堆栈头文件
#include &quot;Stack.h&quot;
#include &lt;cstdlib&gt;

using namespace std;//使用标准命名空间

//计算器类
class Calculator
{
public:
    Calculator();
    ~Calculator();
    errorcode setnull();
    double show();
    errorcode run();//计算过程 
    double operate(char op,double a,double b); 
    bool error(char op,char ch);//识别各种错误
    double double_type(double a);
private:
    Stack&lt;double&gt; opnd;
    Stack&lt;char&gt; optr;
    double value;
    int lp(char op);//右优先度 
    int rp(char op);//左优先度 
};

#endif</code></pre>
<pre><code class="c++">//calculator.cpp

#include &quot;calculator.h&quot;

Calculator::Calculator() 
{
    optr.clean();
    opnd.clean(); 
    optr.push(&#39;#&#39;);
}


Calculator::~Calculator()
{
}

errorcode Calculator::setnull()
{
    optr.clean();
    opnd.clean();
    return optr.push(&#39;#&#39;);
}

double Calculator::show()
{
    return value;
}

errorcode Calculator::run()
{
    char ch,op,ope;
    double val,a,b;
    bool lastisdig = false;
    bool lastisdot = false;
    op = &#39;#&#39;;
    cin &gt;&gt; ch;
    while (ch!=&#39;#&#39;||op!=&#39;#&#39;)
    {
        if (error(op, ch))
            return wrong;    
        if (&#39;.&#39;==ch)
        {
            lastisdot = true;
            cin &gt;&gt; ch;
            continue;
        }
        else if (isdigit(ch))
        {
            cin.putback(ch);
            cin &gt;&gt; val;
            if (true == lastisdig)//两部分数字组合为一个
            {
                if (true == lastisdot)
                {
                    double integer = opnd.pop();
                    val = integer + double_type(val);
                }
                else
                {
                }
            }
            opnd.push(val);
            lastisdig = true;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else if (lp(op)&lt;rp(ch))
        {
            optr.push(ch);
            op = ch;
            lastisdig = false;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else if (lp(op)==rp(ch))
        {
            optr.pop();
            op = optr.top();
            lastisdig = false;
            lastisdot = false;
            cin &gt;&gt; ch;
        }
        else
        {
            ope = optr.pop();
            b = opnd.pop();
            a = opnd.pop();
            opnd.push(operate(ope, a, b));
            op = optr.top();
            lastisdig = false;
            lastisdot = false;
        }
    }
    value = opnd.top();
    return success;
}

double Calculator::operate(char op, double a, double b)
{
    switch (op)
    {
    case &#39;+&#39;:return a + b; break;
    case &#39;-&#39;:return a - b; break;
    case &#39;*&#39;:return a * b; break;
    case &#39;/&#39;:if (b == 0){
        cout &lt;&lt; &quot;分母不能为0&quot; &lt;&lt; endl; 
        exit(1);
    } 
    else return (a / b); break;
    default:exit(1); break;
    }
}

int Calculator::lp(char op)
{
    switch (op)
    {
    case &#39;+&#39;:return 2; break;
    case &#39;-&#39;:return 3; break;
    case &#39;*&#39;:return 4; break;
    case &#39;/&#39;:return 5; break;
    case &#39;(&#39;:return 1; break;
    case &#39;)&#39;:return 6; break;
    case &#39;#&#39;:return 0; break;
    default:return -1; break;
    }
}

int Calculator::rp(char op)
{
    switch (op)
    {
    case &#39;+&#39;:return 3; break;
    case &#39;-&#39;:return 2; break;
    case &#39;*&#39;:return 5; break;
    case &#39;/&#39;:return 4; break;
    case &#39;(&#39;:return 6; break;
    case &#39;)&#39;:return 1; break;
    case &#39;#&#39;:return 0; break;
    default:return -1; break;
    }
}

bool Calculator::error(char op, char ch)
{
    if (1 == lp(op) &amp;&amp; 0 == rp(ch))
        return true;
    if (6 == lp(op) &amp;&amp; 6 == rp(ch))
        return true;
    if (0 == lp(op) &amp;&amp; 1 == rp(ch))
        return true;
    if (4 == lp(op) &amp;&amp; 0 == rp(ch))
        return true;
    return false;
}

double Calculator::double_type(double a)
{
    while (a &gt;= 1)
        a /= 10;
    return a;
}</code></pre>
<pre><code class="c++">//test.cpp

#include &lt;iostream&gt;

#include &quot;calculator.h&quot;
using namespace std;

int main()
{
    char str[100];
    char c;
    int i;
    int c1 = 0, c2 = 0;
    Calculator test;
    cout &lt;&lt; &quot;欢迎使用计算器，请输入等式：\n&quot;;
     while (true) 
    {
        i = 0;
        cin &gt;&gt; c;
        while (c != &#39;#&#39;)
        {
            if (!((c &gt;= &#39;a&#39;&amp;&amp;c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39;&amp;&amp;c &lt;= &#39;Z&#39;)))//排除无效字符
            {
                str[i] = c;
                i++;
            }
            cin &gt;&gt; c; 
        }
        cin.putback(c);
        for (i--; i &gt;= 0; i--)
        {
            cin.putback(str[i]);
            if (str[i] == &#39;(&#39;) {
                c1++;
            }
            if (str[i] == &#39;)&#39;) {
                c2++;
            }
        }
        if (c1 != c2) {
            cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;
            break;
        }
         else if (success == test.run())
            cout &lt;&lt; test.show() &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;
        cin.sync();//清空缓存
     }
        system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/11/01/用栈实现简易计算器">https://zam9036.gitee.io/2019/11/01/用栈实现简易计算器</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>课程实验</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>记Ubuntu上安装GD图片支持库遇到的问题|Zam9036的博客</title>
    <url>/2019/10/30/%E8%AE%B0Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85GD%E5%9B%BE%E7%89%87%E6%94%AF%E6%8C%81%E5%BA%93%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>​    配置Ubuntu对php-gd的支持，网上大多是都是通过逐一配置freetype、libpng、libjpeg…..这样的方法过于繁琐，且出错率过高。CentOS中的yum指令<code>yum install php-gd</code>，可以一条指令配置对php-gd的支持，但是Ubuntu默认软件包管理器不是yum，这就导致了配置的时候会出现</p>
<pre><code class="提示">没有已启用的仓库。
执行 &amp;quot;yum repolist all&amp;quot; 查看您拥有的仓库。
您可以用 yum-config-manager --enable &amp;amp;lt;仓库名&amp;amp;gt; 来启用仓库</code></pre>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>​    CentOS的默认软件包管理器是yum，而Ubuntu默认软件包管理器是dpkp，可以尝试<code>apt-get</code>的方法进行安装。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>​    输入命令代码<code>sudo apt-get install php-gd</code>，发现可以安装了。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/30/记Ubuntu上安装GD图片支持库遇到的问题">https://zam9036.gitee.io/2019/10/30/记Ubuntu上安装GD图片支持库遇到的问题</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
        <tag>服务器</tag>
        <tag>教程</tag>
        <tag>Linux环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows与Linux服务器间快速上传、下载文件（SCP指令）|Zam9036的博客</title>
    <url>/2019/10/28/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/</url>
    <content><![CDATA[<h2 id="SCP指令"><a href="#SCP指令" class="headerlink" title="SCP指令"></a>SCP指令</h2><p>​    scp的指令的作用是可以将本地的文件上传到一台远端服务器，或将远端服务器的文件下载到本地，其格式如下：</p>
<p>​    <code>scp 本地文件地址 远端Liunx用户名@远端IP地址:远端文件存储地址    //上传指令</code></p>
<p>​    <code>scp 远端Liunx用户名@远端IP地址:远端文件地址 本地文件存储地址    //下载指令</code></p>
<h2 id="利用SCP指令从Windows上传文件到Linux服务器"><a href="#利用SCP指令从Windows上传文件到Linux服务器" class="headerlink" title="利用SCP指令从Windows上传文件到Linux服务器"></a>利用SCP指令从Windows上传文件到Linux服务器</h2><p>​    现有一个本地的BBS-Forum.zip文件需要上传到Linux服务器。</p>
<p><img src="/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/1.png" alt="本地文件"></p>
<p>​    首先打开命令提示符cmd，按SCP指令格式输入<code>scp F:\GitHub\BBS-Forum.zip root@211.68.46.235:/var/www/html</code>，其中root是远端Liunx用户名，然后输入密码（密码不显示），开始上传。</p>
<p><img src="/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/2.png" alt="命令提示符"></p>
<p>​    然后去云服务器端查看文件，成功上传！</p>
<p><img src="/img/postimg/Windows%E4%B8%8ELinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88SCP%E6%8C%87%E4%BB%A4%EF%BC%89/3.png" alt="云服务器端"></p>
<h2 id="利用SCP指令从Linux服务器下载文件到Windows"><a href="#利用SCP指令从Linux服务器下载文件到Windows" class="headerlink" title="利用SCP指令从Linux服务器下载文件到Windows"></a>利用SCP指令从Linux服务器下载文件到Windows</h2><p>​    原理同上传，执行<code>scp root@211.68.46.235:/var/www/html/BBS-Forum.zip F:\GitHub</code>，输入密码，开始下载。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>在cmd中输入密码时，考虑安全性问题，密码默认不显示，但实际已经成功输入。</li>
<li>请注意用 \ 作为Windows端文件目录，用 / 作为Linux端文件目录。</li>
</ul>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/28/Windows与Linux服务器间快速上传、下载文件（SCP指令）">https://zam9036.gitee.io/2019/10/28/Windows与Linux服务器间快速上传、下载文件（SCP指令）</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
        <tag>Windows</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo在博客中插入本地图片（无需外链）|Zam9036的博客</title>
    <url>/2019/10/27/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在用Hexo写博客的过程中我们往往需要在博客中插入图片。MarkDown中插入图片有两种方式：一种是使用外链，一种是使用本地图片。而如果使用外链图片，我们需要找好用的图床，以防图片链接不定时挂掉，这大大增加了写博客的时间成本。本地图片如果使用绝对路径会导致上传到Github上时链接不到，所以本文提供了一种利用本地图片的相对路径的方式来插入图片。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>​    我们在启用博客主题时会发现，博客主题中的内置图片，会随<code>hexo g</code>指令一起部署到public文件夹，上传时也会一同上传到Github上，这就为我们保存博客中的图片提供了一种思路。</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/1.png" alt="public文件夹中的img文件夹"></p>
<h2 id="新建本地图片库"><a href="#新建本地图片库" class="headerlink" title="新建本地图片库"></a>新建本地图片库</h2><p>​    查看<code>Hexo-themes</code>中的文件我们可以知道，主题文件的图片存在了<code>source-img</code>文件夹中，所以我们在这个文件夹中新建一个postimg文件夹，用于存放博客中需要保存的图片。</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/2.png" alt="新建postimg文件夹"></p>
<p>​    然后我们把图片存进去，执行<code>hexo g</code>，会发现在<code>public-img</code>文件夹中也多了一个postimg文件夹，里面有我们刚刚存进去的图片。这说明Hexo在部署博客时，也将postimg部署到了博客里。同理，上传时也会将postimg一起上传到Github上，这说明利用相对路径保存图片的方法可行。</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/3.png" alt="postimg文件夹"></p>
<h2 id="图片的相对路径"><a href="#图片的相对路径" class="headerlink" title="图片的相对路径"></a>图片的相对路径</h2><p>​    我们查看主题的配置文件，发现图片的相对路径是<code>/img/XXXXX.jpg</code>，所以可以推算出我们刚刚保存的图片的相对路径是<code>/img/postimg/XXXXX.jpg</code>（其中XXXXX为文件名，<code>.jpg</code>为文件后缀，均可修改）</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/4.png" alt="图片的相对路径"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    所以我们只需要在MarkDown中插入图片时，填写图片的相对路径，然后将图片保存到主题文件夹下的<code>source-img-postimg</code>就可以实现利用本地图片的相对路径的方式来插入图片。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>​    在插入图片时，本地的MarkDown编辑器会找不到图片，这忽略这个问题。因为图片的相对路径在部署博客时会自动更新到public文件夹，自动更新后的相对路径才是正确的，才是可以被服务器访问的。</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%A4%96%E9%93%BE%EF%BC%89/5.png" alt="本地的MarkDown编辑器会找不到图片"></p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/27/利用Hexo在博客中插入本地图片（无需外链）">https://zam9036.gitee.io/2019/10/27/利用Hexo在博客中插入本地图片（无需外链）</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Web</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown简易语法快速入门|Zam9036的博客</title>
    <url>/2019/10/26/MarkDown%E7%AE%80%E6%98%93%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 <code>*</code> 表示斜体 ，<code>**</code> 表示粗体。</p>
<p>示例：</p>
<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>
<hr>
<h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><pre><code># 这是一级标题
## 这是二级标题
### 这是三级标题
#### 这是四级标题
##### 这是五级标题
###### 这是六级标题</code></pre><p>上方代码效果：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><blockquote>
<p>Tips：部分软件及网页对标题层级支持有限</p>
</blockquote>
<hr>
<h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p>
<p>示例：</p>
<p><code>[百度一下，你就知道](https://www.baidu.com)</code></p>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下，你就知道</a></p>
<hr>
<h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>在句首使用<code>*</code> 或<code>+</code>或 <code>-</code> 表示无序列表。</p>
<p>示例：</p>
<ul>
<li>无序列表项 一</li>
</ul>
<ul>
<li>无序列表项 二</li>
</ul>
<ul>
<li>无序列表项 三</li>
</ul>
<hr>
<h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>在句首使用数字和<code>.</code>表示有序列表。</p>
<p>示例：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<hr>
<h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 <code>&gt;</code> 表示文字引用。</p>
<p>示例：</p>
<blockquote>
<p>野火烧不尽，春风吹又生。</p>
</blockquote>
<hr>
<h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p>
<p>示例：</p>
<p>让我们聊聊 <code>Java</code>。</p>
<hr>
<h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>以```开头并结尾表示代码块，在开头注明所用编程语言即可高亮语法。</p>
<p>示例：</p>
<pre><code class="c">include staio.h

void main()
{
    print(&quot;Hello World&quot;);
}</code></pre>
<pre><code class="java">public class Main
{
    public void main(String[] args)
    {
        System.out.print(&quot;Hello World&quot;);
    }
}</code></pre>
<hr>
<h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p>
<p>示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0cb6750a04553993453b54ef72e8b62d_r.jpg" alt="我的知乎背景图"></p>
<hr>
<h3 id="10-内容目录"><a href="#10-内容目录" class="headerlink" title="10. 内容目录"></a>10. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>
<p>[TOC]</p>
<hr>
<h3 id="11-删除线"><a href="#11-删除线" class="headerlink" title="11. 删除线"></a>11. 删除线</h3><p>使用 ~~ 于文字两端表示删除线。</p>
<p><del>删除</del></p>
<hr>
<h3 id="12-LaTeX-公式"><a href="#12-LaTeX-公式" class="headerlink" title="12. LaTeX 公式"></a>12. LaTeX 公式</h3><p>$ 表示行内公式： </p>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<p>$$ 表示整行公式：</p>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p>
<p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<p>详见LaTeX语法</p>
<hr>
<h3 id="13-流程图"><a href="#13-流程图" class="headerlink" title="13. 流程图"></a>13. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="flow">st=&gt;start: Start
io=&gt;inputoutput: verification
op=&gt;operation: Your Operation
cond=&gt;condition: Yes or No?
sub=&gt;subroutine: Your Subroutine
e=&gt;end

st-&gt;io-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;sub-&gt;io</code></pre>
<p>详见流程图语法</p>
<hr>
<h3 id="14-表格支持"><a href="#14-表格支持" class="headerlink" title="14. 表格支持"></a>14. 表格支持</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<hr>
<h3 id="15-HTML标签"><a href="#15-HTML标签" class="headerlink" title="15. HTML标签"></a>15. HTML标签</h3><p>支持在 Markdown 语法中嵌套HTML标签，譬如，你可以用HTML写一个纵跨两行的表格：</p>
<pre><code class="html">&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>

<hr>
<h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>
<pre><code> [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>Cmd Markdown 开发</strong><ul>
<li><input disabled="" type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li><input disabled="" type="checkbox"> 支持以 PDF 格式导出文稿</li>
<li><input checked="" disabled="" type="checkbox"> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li>
<li><input checked="" disabled="" type="checkbox"> 改进 LaTex 功能<ul>
<li><input checked="" disabled="" type="checkbox"> 修复 LaTex 公式渲染问题</li>
<li><input checked="" disabled="" type="checkbox"> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> <strong>七月旅行准备</strong><ul>
<li><input disabled="" type="checkbox"> 准备邮轮上需要携带的物品</li>
<li><input disabled="" type="checkbox"> 浏览日本免税店的物品</li>
<li><input checked="" disabled="" type="checkbox"> 购买蓝宝石公主号七月一日的船票</li>
</ul>
</li>
</ul>
<h2 id="转载声明"><a href="#转载声明" class="headerlink" title="转载声明"></a>转载声明</h2><p>​    原文作者：Cmd Markdown 开发</p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>语法指令</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo写一篇博客|Zam9036的博客</title>
    <url>/2019/10/25/%E5%88%A9%E7%94%A8Hexo%E5%86%99%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="文章布局（Layout）"><a href="#文章布局（Layout）" class="headerlink" title="文章布局（Layout）"></a>文章布局（Layout）</h2><p>​    在写博客之前，先了解一下Hexo的文章布局。 Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；大家自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。 </p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody></table>
<h2 id="文章模板（Scaffold）"><a href="#文章模板（Scaffold）" class="headerlink" title="文章模板（Scaffold）"></a>文章模板（Scaffold）</h2><p>​    在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>
<pre><code>$ hexo new photo &quot;My Gallery&quot;</code></pre><p>​    在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章。所以大家可以在 <code>source/_posts</code> 文件夹中自定义文章模板，来节省重复操作的时间。</p>
<h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><p>​    你可以执行下列命令来创建一篇新文章或者新的页面。</p>
<pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>​    你可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>
<p>​    新建文章后，可以在 <code>source</code> 中找到新建的文章（.md文件），然后使用Typora或其他md编辑器编写博客。MarkDown的语法请关注我后续的博客！</p>
<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>​    文章保存后，在<code>Hexo工作区</code>利用Git bash输入<code>hexo g</code>来发布博客，<code>hexo s</code>本地预览博客，没有问题以后用<code>hexo d</code>或者Github Desktop来上传代码。至此，一篇博客已经生成。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/25/利用Hexo写一篇博客">https://zam9036.gitee.io/2019/10/25/利用Hexo写一篇博客</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Web</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>更改Hexo博客的主题|Zam9036的博客</title>
    <url>/2019/10/24/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><h3 id="从网上选择主题"><a href="#从网上选择主题" class="headerlink" title="从网上选择主题"></a>从网上选择主题</h3><p>​    互联网资源丰富，大家可以在网上（如GitHub）查找自己喜欢的Hexo的模板主题并下载。一般情况下，Hexo的模板主题下载后会有以下文件（当然每个主题包含的文件也是不一样的），如果文件内容出入比较大，大家就需要进一步确认一下下载的主题是不是一个Hexo的主题。</p>
<p><img src="/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/1.png" alt="主题文件参考"></p>
<h3 id="从Hexo官方主题库选择主题"><a href="#从Hexo官方主题库选择主题" class="headerlink" title="从Hexo官方主题库选择主题"></a>从Hexo官方主题库选择主题</h3><p>​    访问<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官方主题库</a>，选择并下载自己所需的主题。不得不说，官方的主题库还是有很多好用的模板的。</p>
<p><img src="/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/2.png" alt="官方主题页"></p>
<h3 id="自创主题"><a href="#自创主题" class="headerlink" title="自创主题"></a>自创主题</h3><p>​    如果你是大神，你还可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a>自己写主题模板！</p>
<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>​    一般情况下，主题文件内会含有README.md文件供大家参考，大家可以查看README.md文件查看主题的启用方式和注意事项。</p>
<p>​    来说说通用启用主题的方式：打开 <code>Hexo</code> 配置文件 <code>_config.yml</code>, 设置主题为你所下载主题的主题名。注意是Hexo工作区的<code>_config.yml</code>，不是主题文件夹内的<code>_config.yml</code>。Hexo工作区的<code>_config.yml</code>是修改整个博客的基础配置文件，而主题文件夹内的<code>_config.yml</code>是主题的配置文件。</p>
<p>例：</p>
<pre><code>...
theme: obsidian
...</code></pre><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>​    不同的主题配置方法不同，大家需要查看主题的README.md文件来了解自己主题的配置方式和注意事项。</p>
<p><img src="/img/postimg/%E6%9B%B4%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98/3.png" alt="配置主题"></p>
<h2 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h2><p>​    主题启用配置好后，在<code>Hexo工作区</code>利用Git bash输入<code>hexo g</code>来部署主题，<code>hexo s</code>本地预览主题，没有问题以后用<code>hexo d</code>或者Github Desktop来上传代码。至此，博客的主题更改完成。</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/24/更改Hexo博客的主题">https://zam9036.gitee.io/2019/10/24/更改Hexo博客的主题</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Web</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>利用GitHub+Hexo搭建个人博客详细教程|Zam9036的博客</title>
    <url>/2019/10/23/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是GitHub"><a href="#什么是GitHub" class="headerlink" title="什么是GitHub"></a>什么是GitHub</h3><p>​    GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。<br>​    GitHub于2008年4月10日正式上线，除了Git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。</p>
<h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><p>​    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><p>Windows</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>创建github账号</li>
<li>安装Node.js、npm，并了解相关基础知识</li>
<li>安装git for windows 或 GitHub Desktop（或者其它git客户端）</li>
</ul>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="创建GitHub博客仓库"><a href="#创建GitHub博客仓库" class="headerlink" title="创建GitHub博客仓库"></a>创建GitHub博客仓库</h3><p>​    如没有GitHub账号请自行百度并注册。在GitHub上新建一个名为<code>username.github.io</code>的仓库，其中username为GitHub的用户名（注意而非昵称！），那么最终生成的博客链接就为<code>https://username.github.io</code></p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.png" alt="创建仓库"></p>
<p><strong>例</strong>：如果你的github用户名是jack，那么你应该新建jack.github.io的仓库（其他名称无效）</p>
<p><strong>注</strong>：</p>
<ul>
<li><p>每一个GitHub账户最多只能创建一个可以直接使用域名访问的仓库。</p>
</li>
<li><p>GitHub账号需要验证邮箱，否则无效。</p>
</li>
<li><p>仓库创建成功后需要等待一定时间后才能生效。</p>
</li>
</ul>
<p>​    如在上图中勾选自动创建ReadMe，创建成功后尝试访问<code>https://username.github.io</code>查看ReadMe.md文件（如未勾选影响也不大）。</p>
<h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>​    在很多地方都会用到SSH Key来解决直接使用账号密码不安全的问题。打开Git for Windows</p>
<p>​    <code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></p>
<p>​    然后按提示进行并点击回车，最终会在电脑的<code>C:\Users\XXX\.ssh</code>目录下（XXX为电脑当前登录的用户名）生成 <code>.ssh\id_rsa.pub</code> 文件，用记事本打开并将里面的内容全部复制。</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2.png" alt="生成SSH Key"></p>
<p>​    打开你的GitHub主页，进入<code>个人设置— SSH and GPG keys — New SSH key</code>，将刚刚复制的文本复制到Key方框内，Title可随意填写。</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/3.png" alt="配置SSH Key"></p>
<p>​    下面来检测一下是否通过SSH连接成功</p>
<p>​    <code>$ ssh -T git@github.com # 无需更改git@github.com</code></p>
<p>​    应该会提示 <code>Are you sure you want to continue connecting (yes/no)?</code> 输入yes，提示<code>Hi Zam90! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>说明SSH配置成功，然后输入以下指令</p>
<pre><code>$ git config --global user.name &quot;Username&quot;// 你的github用户名，注意不是昵称
$ git config --global user.email  &quot;xxx@xxx.com&quot;// 填写已经验证过的github注册邮箱</code></pre><h3 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h3><p>​    在电脑中新建一个文件夹（名字随意），但创建好之后无法随意更改，所以考虑好建在一个合适的位置。以我的<code>F:\Hexo</code>为例来做说明。</p>
<pre><code>$ cd /f/Hexo/  #跳转到文件夹位置
$ hexo init  #在此文件内创建Hexo工作区</code></pre><p><img src="/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/4.png" alt="创建Hexo工作区"></p>
<p>​    创建完成后文件夹内应该有以上内容（除了public）</p>
<p>​    然后执行以下指令</p>
<p>​    <code>$ hexo g # 生成Hexo博客文件</code></p>
<p>​    此时Hexo会自动在public文件夹内生成博客文件</p>
<p>​    <code>$ hexo s # 启动本地预览服务</code></p>
<p>​    此时打开浏览器访问<code>localhost:4000</code>，可以看到默认生成的博客主页</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/5.png" alt="默认博客主页"></p>
<h3 id="上传博客至GitHub"><a href="#上传博客至GitHub" class="headerlink" title="上传博客至GitHub"></a>上传博客至GitHub</h3><h4 id="Git-bash上传"><a href="#Git-bash上传" class="headerlink" title="Git bash上传"></a>Git bash上传</h4><p>​    首先，验证你的SSH成功配置</p>
<p>​    然后用记事本打开Hexo工作区内的配置文件 <code>_config.yml</code> ，修改<code>deploy</code>部分：</p>
<pre><code>deploy:
  type: git
  repository: git@github.com:zam90/zam90.github.io.git
  branch: master</code></pre><p>​    然后在Git bash中输入</p>
<p>​    <code>hexo d</code></p>
<p>​    如报错： <code>Deployer not found: github 或者 Deployer not found: git</code> </p>
<p>​    输入以下指令安装插件解决：</p>
<p>​    <code>npm install hexo-deployer-git --save</code></p>
<p>​    然后再次<code>Hexo d</code>就可以了。</p>
<h4 id="GitHub-Desktop上传"><a href="#GitHub-Desktop上传" class="headerlink" title="GitHub Desktop上传"></a>GitHub Desktop上传</h4><p>​    自从GitHub Desktop上线后，上传代码就有了更方便的选择。</p>
<p>​    安装GitHub Desktop后，clone你的username.github.io仓库到Hexo工作区内的public文件夹，这样<code>Hexo g</code>后public文件夹内的新文件就会被GitHub Desktop检测到：</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/6.png" alt="GitHub Desktop端"></p>
<p>​    然后输入Summary，点击Fetch origin就可以直接上传。</p>
<p>​    当然你也可以选择不把仓库clone到public文件夹内。clone时选择其他文件夹，然后把public内的文件复制到那个clone的文件夹，然后依然可以用GitHub Desktop上传。</p>
<h3 id="检测连接"><a href="#检测连接" class="headerlink" title="检测连接"></a>检测连接</h3><p>​    尝试访问<a href="https://username.github.io，如果成功显示和本地预览相同的界面说明博客搭建成功！" target="_blank" rel="noopener">https://username.github.io，如果成功显示和本地预览相同的界面说明博客搭建成功！</a></p>
<h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><h3 id="在启动本地预览界面后访问localhost-4000显示空白界面"><a href="#在启动本地预览界面后访问localhost-4000显示空白界面" class="headerlink" title="在启动本地预览界面后访问localhost:4000显示空白界面"></a>在启动本地预览界面后访问localhost:4000显示空白界面</h3><p>​    如打开页面显示为空白界面，大概率因为4000端口被占用，执行<code>$ hexo server -p 5000</code>，然后访问localhost:5000。</p>
<h3 id="Git上传失败"><a href="#Git上传失败" class="headerlink" title="Git上传失败"></a>Git上传失败</h3><p>​    请检查SSH Key的配置是否生效。同时注意修改Hexo工作区内的配置文件 <code>_config.yml</code> 。</p>
<p>​    修改<code>deploy</code>部分时：</p>
<pre><code>deploy:
  type: git
  repository: git@github.com:zam90/zam90.github.io.git
  branch: master</code></pre><p>​    注意<code>repository:</code>处不要写成 <code>repository: https:</code>（我遇过的坑）</p>
<h3 id="博客上传成功后访问时收到GitHub的Error邮件"><a href="#博客上传成功后访问时收到GitHub的Error邮件" class="headerlink" title="博客上传成功后访问时收到GitHub的Error邮件"></a>博客上传成功后访问时收到GitHub的Error邮件</h3><p>​    如收到GitHub的以下邮件：（我遇过的坑）</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/7.jpg" alt="Error邮件"></p>
<p>​    请到<code>Hexo工作区—themes/landscape</code>下删除README.md文件后尝试重新上传，此问题可能是index.html与README.md文件冲突导致。</p>
<h3 id="博客上传成功后访问时收到GitHub的Warning邮件"><a href="#博客上传成功后访问时收到GitHub的Warning邮件" class="headerlink" title="博客上传成功后访问时收到GitHub的Warning邮件"></a>博客上传成功后访问时收到GitHub的Warning邮件</h3><p>​    如收到GitHub的以下邮件：（我遇过的坑）</p>
<p><img src="/img/postimg/%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/8.jpg" alt="Warning邮件"></p>
<p>​    请尝试重新配置SSH Key文件，并使用Git for Windows上传博客。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>​    如有其他问题，请参考<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">官方文档</a>，逐一排查尝试解决。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    至此个人博客已经搭建完成，在后续的文章中我会详细讲解如何更换博客主题、写博客、创建新页面、不使用外链插入图片……感谢您的持续关注！</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/23/利用GitHub+Hexo搭建个人博客详细教程">https://zam9036.gitee.io/2019/10/23/利用GitHub+Hexo搭建个人博客详细教程</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>技术Demo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Web</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客|Zam9036的博客</title>
    <url>/2019/10/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>​    这是第一篇博客，网站已经能够稳定运行，博客系统可以使用。！</p>
<h2 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a>原创声明</h2><p>​    文章作者：Zam9036</p>
<p>​    文章链接：<a href="https://zam9036.gitee.io/2019/10/23/第一篇博客">https://zam9036.gitee.io/2019/10/23/第一篇博客</a></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam9036.gitee.io/">Zam9036的博客</a>！</p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>无趣杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>archives</title>
    <url>/archives/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于About|Zam9036的博客</title>
    <url>/about/index.html</url>
    <content><![CDATA[<img src="/img/avatar.png" style="height: 100px; width: 100px; border-radius: 50%; margin-bottom: 15px" />

<h3 id="欢迎Welcome"><a href="#欢迎Welcome" class="headerlink" title="欢迎Welcome"></a><code>欢迎Welcome</code></h3><p>​    欢迎来到<b style="color: #42d2ca"> <strong>Zam9036的博客</strong> </b>，在这里记录了一些生活的点滴和技术Demo。</p>
<p>​    Welcome to the <b style="color: #42d2ca"> <strong>Zam9036’s Blog</strong> </b>, where you’ll find something for life and some demo.</p>
<h3 id="个人介绍Introduction"><a href="#个人介绍Introduction" class="headerlink" title="个人介绍Introduction"></a><code>个人介绍Introduction</code></h3><p>​    我是Zam9036，现就读于北京信息科技大学-计算机学院-计算机科学与技术系。</p>
<p>​    我的微信公众号：<b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>；</p>
<img src="/img/OfficialAccountQRCode.png" style="height: 150px; width: 525px; margin-bottom: 15px" />

<p>​    微信小程序：<b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>，欢迎大家关注！</p>
<img src="/img/MiniProgramQRCode.png" style="height: 150px; width: 525px; margin-bottom: 15px" />

<p>​    I am Zam9036 and I am currently studying at the Department of Computer Science and Technology, Beijing Information Science and Technology University.</p>
<p>​    My WeChat  Official Accounts : <b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>; </p>
<p>​    WeChat mini program : <b style="color: #42d2ca"> <strong>极客杂货铺Z</strong> </b>, welcome everyone to follow and pay attention!</p>
<h3 id="手机应用APP"><a href="#手机应用APP" class="headerlink" title="手机应用APP"></a><code>手机应用APP</code></h3><p>​    2019.11.3日，Zam9036正式推出了<b style="color: #42d2ca"> <strong>博客的Android端</strong> </b>，欢迎大家下载~</p>
<p>​    On 2019.11.3, Zam9036 officially launched <b style="color: #42d2ca"> <strong>the Android APP of the blog</strong> </b>, welcome everyone to download ~</p>
<p>​    <a href="https://pan.baidu.com/s/1wT_aJCdWudE73XFQL5FtwQ" target="_blank" rel="noopener">下载地址Download</a></p>
<h3 id="原创声明"><a href="#原创声明" class="headerlink" title="原创声明"></a><code>原创声明</code></h3><p>​    博客作者：<b style="color: #42d2ca"> <strong>Zam9036</strong> </b></p>
<p>​    版权声明: 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 许可协议</a>。转载请注明来自<a href="https://zam90.github.io/" target="_blank" rel="noopener">Zam9036的博客</a>！</p>
]]></content>
  </entry>
  <entry>
    <title>分类Categories|Zam9036的博客</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签Tags|Zam9036的博客</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
